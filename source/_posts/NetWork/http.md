---
title: "了解 HTTP HTTPS"
date: 2022-03-12 12:22:54
categories:
- 网络
tags:
- 网络
toc: true # 是否显示目录
---
了解 HTTP HTTPS
<!-- more -->
## HTTP1.0/HTTP1.1/HTTP2.0
### HTTP1.0
  * 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

### HTTP1.1
  * 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用
  * 在同一个TCP连接里面，客户端可以同时发送多个请求
  * 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
  * 新增了一些请求方法
  * 新增了一些请求头和响应头
### HTTP2.0
  * 采用二进制格式而非文本格式
  * 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
  * 使用报头压缩，降低开销
  * 服务器推送

## » HTTP和HTTPS

* http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。
* https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。

### HTTP 和 HTTPS 的区别
  1. http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 `ssl` 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。
  2. http 协议的默认端口为 80，https 的默认端口为 443。
  3. http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。
  4. https 缓存不如 http 高效，会增加数据开销。
  5. Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。
  6. SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。

## » TCP三次握手
  * 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
  * 第二次握手：服务器收到syn包并确认客户的SYN（ack=j+1），同时也发送一个自己的SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
  * 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

  >  握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。 

## » TCP四次挥手
  1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

  2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
  3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。
  4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
  5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
  6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

## » 从输入URL到页面加载的全过程
  1. URL解析，查找缓存
     * 浏览器首先对 URL 解析，解析出协议、域名、端口、资源路径、参数
     * 浏览器为了提升性能，在 URL 解析之后，实际会先查询是否有缓存，如果缓存命中，则直接返回缓存资源
       * 浏览器缓存(强缓存和协商缓存)
       * 系统缓存
       * 路由缓存
  2. DNS域名解析 浏览器向DNS服务器发送请求，根据域名解析ip地址，DNS服务器基于UDP，因此会用到 `UDP协议`
  3. 建立TCP连接 三次握手
  4. 发起HTTP请求
  5. 服务器响应并返回结果 服务器发送相应的html及其他文件给浏览器
  6. 关闭TCP连接 四次挥手
  7. 浏览器渲染 解析html文件内容并渲染
     * 构建DOM树
     * 构建CSS规则树
     * 生成render树
     * 布局
     * 绘制
  8. js引擎解析 调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）

## HTTP状态码
### 1xx
代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束，常见如下：
* 100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
* 101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级
### 2xx
代表请求已成功被服务器接收、理解、并接受，常见如下：
* 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
* 201（已创建）：请求成功并且服务器创建了新的资源
* 202（已创建）：服务器已经接收请求，但尚未处理
* 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源
* 204（无内容）：服务器成功处理请求，但没有返回任何内容
* 205（重置内容）：服务器成功处理请求，但没有返回任何内容
* 206（部分内容）：服务器成功处理了部分请求
### 3xx
表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向，常见如下：
* 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
* 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
* 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
* 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码
* 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
* 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
### 4xx
代表了客户端看起来可能发生了错误，妨碍了服务器的处理，常见如下：
* 400（错误请求）： 服务器不理解请求的语法
* 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
* 403（禁止）： 服务器拒绝请求
* 404（未找到）： 服务器找不到请求的网页
* 405（方法禁用）： 禁用请求中指定的方法
* 406（不接受）： 无法使用请求的内容特性响应请求的网页
* 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
* 408（请求超时）： 服务器等候请求时发生超时
### 5xx
* 表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，常见如下：
* 500（服务器内部错误）：服务器遇到错误，无法完成请求
* 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
* 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
* 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
* 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
* 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本
### 常用场景
* 100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输
* 101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级
* 206：一般用来做断点续传，或者是视频文件等大文件的加载
* 301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名
* 302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面
* 304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分
* 400：参数有误，请求无法被服务器识别
* 401：未授权，请求要求身份验证。对于需要登录的网页，服务器可能返回此响应
* 403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回
* 404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时
* 502：错误网关，服务器作为网关或代理，从上游服务器收到无效响应
* 503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503
* 504：网关超时

## 强缓存 & 协商缓存
强缓存和协商缓存是浏览器缓存机制中的两种策略，用于提高网页加载速度和减少服务器负担。它们在控制浏览器是否需要重新请求资源时起着不同的作用。
### 强缓存：
* 强缓存是通过设置响应头中的`Cache-Control`和`Expires`字段来实现的。当浏览器请求一个资源时，会先检查该资源的缓存是否过期，如果没有过期，浏览器直接使用缓存副本，不会向服务器发起请求。
* 常用的`Cache-Control`字段有：
  * `public`：表示响应可以被任何对象（包括代理服务器）缓存。
  * `private`：表示响应只能被单个用户缓存，不允许代理服务器缓存。
  * `max-age=<seconds>`：表示资源在多少秒内有效。
* Expires字段是一个过时的方式，表示资源过期的时间点。
### 协商缓存：
* 当资源的缓存过期或者浏览器强制刷新时，浏览器会向服务器发送请求，服务器会根据请求头中的`If-Modified-Since（Last-Modified）`和`If-None-Match（ETag）`字段来判断资源是否有更新。
* 如果资源没有更新，服务器会返回`304 Not Modified`状态码，告诉浏览器可以继续使用缓存的资源，节省带宽和加快加载速度。
* 如果资源有更新，服务器会返回新的资源内容，浏览器会使用新的资源并更新缓存。   
总的来说，强缓存通过设置响应头来告诉浏览器资源的有效期，而协商缓存则是通过与服务器通信来验证资源是否有更新。合理地使用强缓存和协商缓存可以有效提升网页加载速度，并减少对服务器的请求压力。
## » 参考 ☞
* [🔥 连八股文都不懂还指望在前端混下去么](https://juejin.cn/post/7016593221815910408#heading-12)
* [说说 HTTP1.0/1.1/2.0 的区别?](https://juejin.cn/post/6909239354418266119#comment)
* [说说TCP为什么需要三次握手和四次挥手？](https://www.developers.pub/wiki/1065322/1067962)
* [说说HTTP 常见的状态码有哪些，适用场景](https://www.developers.pub/wiki/1065322/1067997#head7)