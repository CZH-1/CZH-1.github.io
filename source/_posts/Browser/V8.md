---
title: "V8垃圾回收"
date: 2022-04-12 12:22:54
categories:
- 浏览器
tags:
- 浏览器
toc: true # 是否显示目录
---

> V8垃圾回收机制 

<!-- more -->
## 浏览器内核
  浏览器中存在 渲染引擎（负责渲染页面） 和 JavaScript引擎（负责js执行）。以Chrome为例：渲染引擎为 Blink(13 年之前使用的是 Safari 的 Webkit, Blink 是谷歌与欧朋一起搞的) 以及 Javascript引擎： V8

## 内存
  计算机五大硬件之一存储器的核心之一。分别为：运算器，控制器，存储器（内部存储，外部存储），输入设备（键盘鼠标等），输出设备（打印机等）

## 内部分配
  ### 栈

  简单说，栈内存，小且存储连续，操作起来简单方便，一般由系统自动分配，自动回收，所以文章内所说的垃圾回收，都是基于堆内存。

  ### 堆
  堆内存 大(相对于栈内存)且不连续
  ### V8 中内存分类 （堆内存）
  在讲内存分配之前，先了解一下弱分代假说，V8 的垃圾回收主要建立在这个假说之上。
  概念：

   - 绝大部分的对象生命周期都很短，即存活时间很短
   - 生命周期很长的对象，基本都是常驻对象

  基于以上两个概念，将内存分为 新生代 (new space)与老生代 (old space) 两个区域。划重点，记一下。

### 垃圾产生&为何回收
JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。
常见的内存泄漏：
* 意外声明的全局变量
* 被遗忘的定时器
* 使用不当的闭包
* 未清理的 DOM 引用

## 垃圾回收( Garbage Collection 简称 GC )
  GC 即 Garbage Collection （垃圾回收），程序工作过程中会产生很多 垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 GC 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，GC 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 垃圾回收机制 了
  ### 新生代
  新生代算法为 Scavenge 算法，分为 From区 和 To区，广度优先
  * 首先，V8 引擎中的垃圾回收器检测到 from space 空间快达到上限了，此时要进行一次垃圾回收了
  * 从根部开始遍历，不可达对象(即无法遍历到对象)就标记，可达的对象不标记然后复制到to区
  * 清除 from space 中的数据，同时将 from space 置为空闲状态，即变为 to space ,对应的 to space 变为 from space，俗称翻转

  当然优秀的 V8 是不可能容忍，一个对象来回的在 form space 和 to space 中蹦跶的，当经历一次 form => to 翻转之后，发现某些未被标记的对象居然还在，会直接扔到老生代里面去，好似后浪参加比赛，晋级了，优秀的嘞。
  除了上面一种情况，还有一个情况也会晋级，当一个对象，在被复制的时候，大于 to space 空间的 25% 的时候，也会晋级了，这种自带背景的选手，那是不敢动的，直接晋级到老生代。

  ### 老生代
  老生代回收算法为：标记和清除/整理（mark-sweep/mark-compact）。深度优先
  标记过程中，引入三色：

  * 白色： 未被标记的对象，即不可达对象（没有扫描到的对象），可回收
  * 灰色： 已被标记，可达对象，未扫描完，不可回收
  * 黑色： 已被编辑，可达对象，扫描完，不可回收
  过程：
  1. 首先将所有的非根部对象全部标记为白色，然后使用深度优先遍历，是深度优先哈，和新生代不一样哈，按深度优先搜索沿途遍历，将访问到的对象，直接压入栈中，同时将标记结果放在 marking bitmap (灰色) 中，一个对象遍历完成，直接出栈，同时在 marking bitmap 中记录为黑色，直到栈空为止
  2. 标记完成后，接下来就是等待垃圾回收器来清除了，清除完了之后，会在原来的内存区域留下一大堆不连续的空间，小对象还好说，这个时候如果来一个稍微大一点的对象，没有内存可以放的下这个傻大个了，怎么办？只能触发 GC，但是吧，原来清除的不连续的空间加起来又可以放的下这个傻大个，很可惜啊，启动一次 GC 性能上也是嗖嗖的往下掉啊；V8 能容许这样的事发生？肯定不存在嘛！
  3. 所以在清除完之后，新生代中对象，再一次分配到老生带并且内存不足的时候，会优先触发标记整理（mark-compact）, 在标记结束后，他会将可达对象(黑色)，移到内存的另一端，其他的内存空间就不会被占用，直接释放，等下次再有对象晋升的时候，轻松放下。


## 参考
* [V8 引擎垃圾回收与内存分配](https://juejin.cn/post/6909239354418266119#comment)
* [一文搞懂V8引擎的垃圾回收](https://juejin.cn/post/6844904016325902344#comment)


