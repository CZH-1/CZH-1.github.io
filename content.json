{"pages":[{"title":"关于我","text":"","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/03/07/hello-world/"},{"title":"基础排序算法","text":"冒泡排序选择排序插入排序快速排序二分查找动态规划贪心算法 冒泡排序12345678910111213141516171819// 比较相邻的两个数，若大于交换位置，每一轮找出一个最大值function bubbleSort(arr) { // 缓存数组长度 const len = arr.length; // 外层循环用于控制从头到尾的比较+交换到底有多少轮 for (let i = 0; i &lt; len; i++) { // 内层循环用于完成每一轮遍历过程中的重复比较+交换 for (let j = 0; j &lt; len - 1; j++) { // 若相邻元素前面的数比后面的大 if (arr[j] &gt; arr[j + 1]) { // 交换两者 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } } // 返回数组 return arr;}console.log(bubbleSort([3, 6, 2, 4, 1])); 选择排序 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕 123456789101112131415161718function selectionSort(arr) { var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) { minIndex = i; for (var j = i + 1; j &lt; len; j++) { // 寻找最小的数 if (arr[j] &lt; arr[minIndex]) { // 将最小数的索引保存 minIndex = j; } } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } return arr;} 插入排序 把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的 从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 重复上述过程直到最后一个元素被插入有序子数组中1234567891011121314function insertionSort(arr) { const len = arr.length; let preIndex, current; for (let i = 1; i &lt; len; i++) { preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) { arr[preIndex+1] = arr[preIndex]; preIndex--; } arr[preIndex+1] = current; } return arr;} 快速排序123456789101112131415161718192021// 找一个基点，小于放左边，大于放右边function quickSort(arr,startIndex = 0) { // console.log(startIndex) if (arr.length &lt;= 1) return arr const startNum = arr.splice(startIndex, 1)[0]; console.log(startNum); const right = [], left= [] for (let i = 0; i &lt; arr.length; i++) { if (arr[i] &lt; startNum) { left.push(arr[i]); } else { right.push(arr[i]); } } return [...quickSort(left), startNum, ...quickSort(right)];}const arr = [6, 4, 7, 5, 1, 2, 9, 8]console.log(arr)console.log(quickSort(arr)) 二分查找使用前提想要应用二分查找法，则有如下特性： 存储在数组中 有序排序 搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束，如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较，如果在某一步骤数组为空，则代表找不到，这种搜索算法每一次比较都使搜索范围缩小一半 1234567891011121314151617181920212223function BinarySearchFirst(arr, target) { if (arr.length &lt;= 1) return -1 // 低位下标 let lowIndex = 0 // 高位下标 let highIndex = arr.length - 1 while (lowIndex &lt;= highIndex) { // 中间下标 const midIndex = Math.floor((lowIndex + highIndex) / 2) if (target &lt; arr[midIndex]) { highIndex = midIndex - 1 } else if (target &gt; arr[midIndex]) { lowIndex = midIndex + 1 } else { // 数组中存在重复项，而我们需要找出第一个符合的值 // 当 target 与 arr[midIndex] 相等的时候，如果 midIndex 为0或者前一个数比 target 小那么就找到了第一个等于给定值的元素，直接返回 if (midIndex === 0 || arr[midIndex - 1] &lt; target) return midIndex // 否则高位下标为中间下标减1，继续查找 highIndex = midIndex - 1 } } return -1} 动态规划简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决，然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。一般这些子问题很相似，可以通过函数关系式递推出来，例如斐波那契数列，我们可以得到公式：当 n 大于 2的时候，F(n) = F(n-1) + F(n-2) ，f(10)= f(9)+f(8),f(9) = f(8) + f(7)…是重叠子问题，当n = 1、2的时候，对应的值为2，这时候就通过可以使用一个数组记录每一步计算的结果，以此类推，减少不必要的重复计算 适用场景如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划，比如一些求最值的场景，如最长递增子序列、最小编辑距离、背包问题、凑零钱问题等等，都是动态规划的经典应用场景。关于动态规划题目解决的步骤，一般如下： 描述最优解的结构 递归定义最优解的值 按自底向上的方式计算最优解的值 由计算出的结果构造一个最优解 参考 说说常见的排序算法有哪些？","link":"/2024/02/29/Arithmetic/sort/"},{"title":"Canvas 和 SVG","text":"Canvas 和 SVG Canvas介绍Canvas，画布！很好理解就是用来画画的。那具体怎么“画”咱们就得看一下具体的 API 文档了。下面是对 canvas 的一些概述： canvas 是一个可以使用脚本(通常为JavaScript)来绘制图形的 HTML 元素. Canvas API 提供了一个通过JavaScript 和 HTML的Canvas元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。 Canvas API 主要聚焦于2D图形。而同样使用Canvas元素的 WebGL API 则用于绘制硬件加速的2D和3D图形。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt; &lt;script&gt; var canvas = document.getElementById('canvas'); var context = canvas.getContext('2d'); context.moveTo(10,100); context.lineTo(30,10); context.lineTo(50,100); context.lineTo(70,10); context.lineTo(90,100); context.stroke(); &lt;/script&gt; 应用 首先是可视化数据的应用，比如说：百度的ECharts、阿里的G2等图表可视化插件。 其次是游戏的应用，Canvas 在基于Web的图像显示方面比 Flash 更加立体、精巧，且Canvas游戏在流畅度和跨平台方面更牛。 还有图形编辑器的应用，比如可视化组态编辑工具HT，它完全基于Canvas绘制。未来Photoshop能够基于Canvas在web端100%实现。 最后模拟器的应用，模拟器产品可以完全由 canvas 来实现，视觉效果上更加逼真模拟实际生活中的工具，进一步优化物联网环境下的使用体验，降低使用者的学习成本。未来Canvas的应用只会越来越普遍，所以具备Canvas这门技术是必不可缺的。 SVGSVG 英文全称为 Scalable Vector Graphics，意思为可缩放的矢量图。 HTML5 支持内联 SVG。 HTML &lt;svg&gt; 元素是 SVG 图形的容器。 SVG 有多种绘制路径、框、圆、文本和图形图像的方法。 12345678910&lt;!-- 绘制矩形：使用 rect 标签，主要属性：x/y：绘图位置，width/height：矩形长宽，fill：填充颜色，默认黑色，stroke：描边的颜色。stroke-width：描边的宽度。rx/ry：描边的圆角。 --&gt;&lt;svg width=&quot;500&quot; height=&quot;500&quot;&gt; &lt;rect x=&quot;100&quot; y=&quot;100&quot; width=&quot;150&quot; height=&quot;100&quot; fill=&quot;red&quot; stroke=&quot;green&quot; stroke-width=&quot;2&quot; rx=&quot;10&quot;&gt;&lt;/rect&gt;&lt;/svg&gt; 区别 SVG 是一种使用 XML 描述 2D 图形的语言。 Canvas 通过 JavaScript 来绘制 2D 图形。 SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 Canvas 是逐像素进行渲染的。在 Canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 Canvas 依赖分辨率； 不支持事件处理器； 弱的文本渲染能力； 能够以 .png 或 .jpg 格式保存结果图像； 最适合图像密集型的游戏，其中的许多对象会被频繁重绘。 SVG 不依赖分辨率； 支持事件处理器； 最适合带有大型渲染区域的应用程序（比如谷歌地图）； 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）； 不适合游戏应用。","link":"/2024/03/20/Html&Css/canvas/"},{"title":"em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别?","text":"em/px/rem/vh/vw区别? 一、区别 px：绝对单位，页面按精确像素展示 em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算，整个页面内1em不是一个固定的值 rem：相对单位，可理解为root em, 相对根节点html的字体大小来计算 vh、vw：主要用于页面视口大小布局，在页面布局上更加方便简单 参考说说em/px/rem/vh/vw区别?","link":"/2024/03/02/Html&Css/css-px-em/"},{"title":"对 BFC 的理解","text":"BFC 一、概念BFC（Block Formatting Context），即块级格式化上下文，它是页面中的一块渲染区域，并且有一套属于自己的渲染规则： 内部的盒子会在垂直方向上一个接一个的放置 对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关。 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此 BFC的区域不会与float的元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 BFC 目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素 二、形成条件触发 BFC 的条件包含不限于： 根元素，即HTML元素 浮动元素：float值为left、right overflow值不为 visible，为 auto、scroll、hidden display的值为inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid position的值为absolute或fixed三、应用场景利用 BFC 的特性，我们将 BFC 应用在以下场景：防止margin重叠（塌陷）1234567891011121314151617181920212223242526272829303132333435&lt;style&gt; p { color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; }&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p &gt; &lt;p&gt;Hehe&lt;/p &gt;&lt;/body&gt;/* margin重叠100px 利用BFC修改为200px：*/&lt;style&gt; .wrap { overflow: hidden;// 新的BFC } p { color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; }&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p &gt; &lt;div class=&quot;wrap&quot;&gt; &lt;p&gt;Hehe&lt;/p &gt; &lt;/div&gt;&lt;/body&gt; 清除内部浮动12345678910111213141516171819202122&lt;style&gt; .par { border: 5px solid #fcc; width: 300px; } .child { border: 5px solid #f66; width:100px; height: 100px; float: left; }&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;par&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;/* 父高度丢失 利用BFC修改为父元素包裹子元素 */.par { overflow: hidden;} 自适应多栏布局123456789101112131415161718192021222324252627&lt;style&gt; body { width: 300px; position: relative; } .aside { width: 100px; height: 150px; float: left; background: #f66; } .main { height: 200px; background: #fcc; }&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/body&gt;/* 虽然.aslide为浮动元素，但是main的左边依然会与包含块的左边相接触 bfc修改为不会与浮动的.aside元素重叠 */.main { overflow: hidden;} 参考","link":"/2024/03/01/Html&Css/css-BFC/"},{"title":"布局方案","text":"布局方案 水平垂直居中方案flex适用场景：子元素宽高不固定、子元素宽高固定 1234567891011121314151617&lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;children&quot;&gt;HZFE&lt;/div&gt;&lt;/div&gt;#parent { background: red; height: 600px;}#children { background: blue;}#parent { display: flex; justify-content: center; align-items: center;} transform适用场景：子元素宽高不固定、子元素宽高固定 123456789101112131415#children { display: inline-block; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%);}#children { width: 400px; height: 300px; position: relative; top: 50%; left: 50%; transform: translate(-200px, -150px);} 两栏布局两栏布局非常常见，往往是以一个定宽栏和一个自适应的栏并排展示存在 float1234567891011121314151617181920&lt;style&gt; .box{ overflow: hidden; /* 添加BFC */ } .left { float: left; width: 200px; background-color: gray; height: 400px; } .right { margin-left: 210px; background-color: lightgray; height: 200px; }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;左边&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边&lt;/div&gt;&lt;/div&gt; flex弹性布局123456789101112131415&lt;style&gt; .box{ display: flex; } .left { width: 100px; } .right { flex: 1; }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;左边&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边&lt;/div&gt;&lt;/div&gt; 三栏布局实现三栏布局中间自适应的布局方式有： 两边使用 float，中间使用 margin 两边使用 absolute，中间使用 margin 两边使用 float 和负 margin display: table 实现 flex实现 grid网格布局 两边使用 float，中间使用 margin12345678910111213141516171819202122232425262728293031&lt;style&gt; .wrap { background: #eee; overflow: hidden; &lt;!-- 生成BFC，计算高度时考虑浮动的元素 --&gt; padding: 20px; height: 200px; } .left { width: 200px; height: 200px; float: left; background: coral; } .right { width: 120px; height: 200px; float: right; background: lightblue; } .middle { margin-left: 220px; height: 200px; background: lightpink; margin-right: 140px; }&lt;/style&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;中间&lt;/div&gt;&lt;/div&gt; 两边使用 absolute，中间使用 margin1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; .container { position: relative; } .left, .right, .main { height: 200px; line-height: 200px; text-align: center; } .left { position: absolute; top: 0; left: 0; width: 100px; background: green; } .right { position: absolute; top: 0; right: 0; width: 100px; background: green; } .main { margin: 0 110px; background: black; color: white; }&lt;/style&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;左边固定宽度&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边固定宽度&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;中间自适应&lt;/div&gt;&lt;/div&gt; flex实现12345678910111213141516171819202122232425262728293031323334&lt;style type=&quot;text/css&quot;&gt; .wrap { display: flex; justify-content: space-between; } .left, .right, .middle { height: 100px; } .left { width: 200px; background: coral; } .right { width: 120px; background: lightblue; } .middle { background: #555; width: 100%; margin: 0 20px; }&lt;/style&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;中间&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt;&lt;/div&gt; 参考 元素水平垂直居中的方法有哪些 如何实现两栏/三栏布局，右侧自适应？","link":"/2024/02/20/Html&Css/css-grid/"},{"title":"Iterator概念及用法","text":"Iterator概念及用法 参考JavaScript基础：Iterator概念及用法","link":"/2024/02/27/JavaScript/javaScript-Iterator/"},{"title":"概括总结 ES6 特性","text":"ES6 参考 1.5万字概括ES6全部特性(已更新ES2020)","link":"/2022/03/12/JavaScript/javaScript-ES6/"},{"title":"理解JS Event Loop","text":"Event Loop同步/异步 基本概念执行 &amp; 运行 JavaScript 的执行和运行是两个不同概念的，执行，一般依赖于环境，比如 node、浏览器 等， JavaScript 在不同环境下的执行机制可能并不相同。而今天我们要讨论的 Event Loop 就是 JavaScript 的一种执行方式。而运行呢，是指JavaScript 的解析引擎，这是统一的。 JavaScript Engine 和 JavaScript Runtime 为了让 JavaScript 运行起来，要完成两部分工作（当然实际比这复杂的多）： 编译并执行 JavaScript 代码，完成内存分配、垃圾回收等； 为 JavaScript 提供一些对象或机制，使它能够与外界交互。 这里的第一部分，是 Engine（执行引擎）；第二部分，是 Runtime（执行环境）。 关于 JavaScript JavaScript 是单线程语言，只有一个调用栈，决定了它在同一时间只能做一件事情。 在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！ 在 JavaScript 运行的时候，JavaScript Engine 会创建和维护相应的堆（Heap）和栈（Stack），同时通过 JavaScript Runtime 提供的一系列 API（例如 setTimeout、XMLHttpRequest 等）来完成各种各样的任务。 在 JavaScript 的运行过程中，真正负责执行 JavaScript 代码的始终只有一个线程，通常被称为主线程，各种任务都会用排队的方式来同步执行。这种方式最常见的一个问题就是：如果你尝试执行一段非常耗时的同步代码，浏览器就没办法同时去渲染 GUI，导致界面失去响应，也就是被阻塞了。 事件循环（Event Loop）什么是 Event Loop？ 事件循环（Event Loop） 是让 JavaScript 做到既是单线程，又绝对不会阻塞的核心机制，也是 JavaScript 并发模型（Concurrency Model）的基础，是用来协调各种事件、用户交互、脚本执行、UI 渲染、网络请求等的一种机制。 简单一点：Event Loop 只不过是实现异步的一种机制而已。 JavaScript 有一个主线程 main thread，和调用栈 call-stack 也称之为执行栈。所有的任务都会放到调用栈中等待主线程来执行。 任务队列(task queue)执行和协调各种任务时，Event Loop 会维护自己的任务队列。任务队列又分为 Task Queue 和 Microtask Queue 两种。 实际上，称任务队列为事件队列（Event Queue）可能会更容易理解。所谓的事件驱动（Event-driven），就是将一切抽象为事件（Event），比如 AJAX 完成、鼠标点击、I/O 操作等等，都是一个个的事件，而 Event Loop 就是一个事件循环的过程。同步任务(SyncTask): 主线程来执行的时候立即就能执行的代码异步任务(AsyncTask): 先去执行别的 task，等我这 xxx 完之后再往 Task Queue 里面塞一个 task 的同步任务来等待被执行 主线程自上而下执行所有代码 同步任务直接进入到主线程被执行，而异步任务则进入到 Event Table 并注册相对应的回调函数 异步任务完成后，Event Table 会将这个函数移入 Event Queue 主线程任务执行完了以后，会从Event Queue中读取任务，进入到主线程去执行。 循环如上 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 上述动作不断循环，就是我们所说的事件循环(Event Loop)。 例如： 123456789101112ajax({ url:www.Nealyang.com, data:prams, success:() =&gt; { console.log('请求成功!'); }, error:()=&gt;{ console.log('请求失败~'); }})console.log('这是一个同步任务'); ajax 请求首先进入到 Event Table ，分别注册了onError和onSuccess回调函数。 主线程执行同步任务：console.log(‘这是一个同步任务’); 主线程任务执行完毕，看Event Queue是否有待执行的 task,这里是不断地检查，只要主线程的task queue没有任务执行了，主线程就一直在这等着 ajax 执行完毕，将回调函数push 到Event Queue。（步骤 3、4 没有先后顺序而言） 主线程“终于”等到了Event Queue里有 task可以执行了，执行对应的回调任务。 如此往复。 Task Queue(宏任务队列)一个 Event Loop 会有一个或多个 Task Queue，这是一个先进先出（FIFO）的有序列表，存放着来自不同 Task Source（任务源）的 Task。在 HTML 标准中，定义了几种常见的 Task Source: DOM manipulation（DOM 操作）； User interaction（用户交互）； Networking（网络请求）； History traversal（History API 操作）。 Task Source 的定义非常的宽泛,包括整体代码script，setTimeout，setInterval，常见的鼠标、键盘事件，AJAX，数据库操作（例如 IndexedDB），等等都属于 Task Source，所有来自这些 Task Source 的 Task 都会被放到对应的 Task Queue 中等待处理。 Microtask Queue(微任务队列)Microtask Queue 与 Task Queue 类似，也是一个有序列表。不同之处在于，一个 Event Loop 只有一个 Microtask Queue。在 HTML 标准中，并没有明确规定 Microtask Source，通常认为有以下几种： Promise.then catch finally(注意我不是说 Promise) Process.nextTick MutationObserver setTimeoutsetTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？看一个例子： 12345setTimeout(() =&gt; { task();},3000)console.log('执行console'); 前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是： 12//执行console//task() 去验证一下，结果正确！ 然后我们修改一下前面的代码： 123456setTimeout(() =&gt; { task()},3000)sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明： 123456//代码1console.log('先执行这里');setTimeout(() =&gt; { console.log('执行啦')},0); 1234567//代码2console.log('先执行这里');setTimeout(() =&gt; { console.log('执行啦')},3000); 代码1的输出结果是： 12//先执行这里//执行啦 代码2的输出结果是： 123//先执行这里// ... 3s later// 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。 事件循环执行顺序整体script作为第一个宏任务进入主线程执行栈进，将宏任务(例如setTimeout)，其回调函数存放入宏任务队列中，微任务(例如process.nextTick())，将其回调函数存放入微任务队列中（队列：先进先出FIFO），所有异步任务都存在调用栈（栈：后进先出LIFO）中。开始第一次循环，接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。如下： 123456789101112setTimeout(function() { console.log('setTimeout');})new Promise(function(resolve) { console.log('promise'); resolve() // 注意：若无resolve将报错}).then(function() { console.log('then');})console.log('console'); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。结果如下：// promise console then setTimeout 事件循环，宏任务，微任务的关系如图所示： 分析一段较复杂的代码，看看你是否真的掌握了js的执行机制： 12345678910111213141516171819202122232425262728293031323334353637console.log('1');setTimeout(function() { console.log('2'); process.nextTick(function() { console.log('3'); }) new Promise(function(resolve) { console.log('4'); resolve(); }).then(function() { console.log('5') })})process.nextTick(function() { console.log('6');})new Promise(function(resolve) { console.log('7'); resolve();}).then(function() { console.log('8')})setTimeout(function() { console.log('9'); process.nextTick(function() { console.log('10'); }) new Promise(function(resolve) { console.log('11'); resolve(); }).then(function() { console.log('12') })}) 事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。 (请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 参考文章 【THE LAST TIME】彻底吃透 JavaScript 执行机制 这一次，彻底弄懂 JavaScript 执行机制 深入理解 JavaScript Event Loop","link":"/2022/03/12/JavaScript/javaScript-async/"},{"title":"call apply bind","text":"call apply bind 三者的区别: 1）三者都可以显式绑定函数的this指向 2）三者第一个参数都是this要指向的对象，若该参数为undefined或null，this则默认指向全局window 3）传参不同：apply是数组、call是参数列表，而bind可以分为多次传入，实现参数的合并 4）call、apply是立即执行，bind是返回绑定this之后的函数，如果这个新的函数作为构造函数被调用，那么this不再指向传入给bind的第一个参数，而是指向新生成的对象 手写call: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 手写callFunction.prototype.Call = function(context, ...args) { // context为undefined或null时，则this默认指向全局window if (context === undefined || context === null) { context = window; } // 利用Symbol创建一个唯一的key值，防止新增加的属性与obj中的属性名重复 let fn = Symbol(); // this指向调用call的函数 context[fn] = this; // 隐式绑定this，如执行obj.foo(), foo内的this指向obj let res = context[fn](...args); // 执行完以后，删除新增加的属性 delete context[fn]; return res;};// apply与call相似，只有第二个参数是一个数组，Function.prototype.Apply = function(context, args) { if (context === undefined || context === null) { context = window; } let fn = Symbol(); context[fn] = this; let res = context[fn](...args); delete context[fn]; return res;};// bind要考虑返回的函数，作为构造函数被调用的情况Function.prototype.Bind = function(context, ...args) { if (context === undefined || context === null) { context = window; } let fn = this; let f = Symbol(); const result = function(...args1) { if (this instanceof fn) { // result如果作为构造函数被调用，this指向的是new出来的对象 // this instanceof fn，判断new出来的对象是否为fn的实例 this[f] = fn; let res = this[f](...args, ...args1); delete this[f]; return res; } else { // bind返回的函数作为普通函数被调用时 context[f] = fn; let res = context[f](...args, ...args1); delete context[f]; return res; } }; // 如果绑定的是构造函数 那么需要继承构造函数原型属性和方法 // 实现继承的方式: 使用Object.create result.prototype = Object.create(fn.prototype); return result;}; 参考 深入理解 JavaScript 原型 实现 apply、call、bind","link":"/2022/05/12/JavaScript/javaScript-call-apply-bind/"},{"title":"函数式编程","text":"函数式编程 纯函数 高阶函数 柯里化 组合与管道 参考 js中如何实现函数缓存 函数式编程的理解","link":"/2024/02/25/JavaScript/javaScript-func/"},{"title":"JS 手写函数","text":"this 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 深拷贝function deepClone(source) { if (!source &amp;&amp; typeof source !== 'object') { return source } const target = Array.isArray(source) ? [] : {} Object.keys(source).forEach(key =&gt; { if (source[key] &amp;&amp; typeof key === 'object') { target[key] = deepClone(source[key]) } else { target[key] = source[key] } }) return target}// 深拷贝function deepClone(target,hash = new weakMap){ if(target === null &amp;&amp; target!=='object'){ return target } if(hash.get(target)) return hash.get(target) const newObj = Array.isArray(target)? []:{} hash.set(target,newObj) for(let key in target){ if(target.hasOwnProperty(key)){ if(target[key] !== null &amp;&amp; target[key] === 'object'){ newObj[key] = deepClone(target[key]) } else { newObj[key] = target[key] } } } return newObj}function deepClone(obj, hash = new WeakMap()) { if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作 if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); // 可能是对象或者普通的值 如果是函数的话是不需要深拷贝 if (typeof obj !== &quot;object&quot;) return obj; // 是对象的话就要进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) { if (obj.hasOwnProperty(key)) { // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); } } return cloneObj;} 123456// newfunction newSelf(fn, args) { const constructor = Object.create(fn.prototype) const obj = fn.apply(constructor, args) return typeof obj === 'object' &amp;&amp; obj !== null ? obj : constructor} 12345// 判断类型function dataType(data){ return Object.prototype.toString.call(data).slice(8,-1).toLowerCase()}console.log(dataType(new Date()));","link":"/2024/02/29/JavaScript/javaScript-handleFunc/"},{"title":"new","text":"new new 一个对象，到底发生什么？ 1）创建一个对象，该对象的原型指向构造函数的原型2）调用该构造函数，构造函数的this指向新生成的对象3）判断构造函数是否有返回值，如果有返回值且返回值是一个对象或一个方法，则返回该值；否则返回新生成的对象 构造函数有返回值的案例: 123456function Dog(name) { this.name = name; return { test: 1 };}let obj = new Dog(&quot;ming&quot;);console.log(obj); // {test:1} 手写new: 1234567891011121314151617181920212223242526function selfNew(fn, ...args) { // 创建一个instance对象，该对象的原型是fn.prototype let instance = Object.create(fn.prototype); // 调用构造函数，使用apply，将this指向新生成的对象 let res = fn.apply(instance, args); // 如果fn函数有返回值，并且返回值是一个对象或方法，则返回该对象，否则返回新生成的instance对象 return typeof res === &quot;object&quot; || typeof res === &quot;function&quot; ? res : instance;}function mynew(func, ...args) { const obj = {} obj.__proto__ = func.prototype let result = func.apply(obj, args) return result instanceof Object ? result : obj}function Person(name, age) { this.name = name; this.age = age;}Person.prototype.say = function () { console.log(this.name)}let p = mynew(Person, &quot;huihui&quot;, 123)console.log(p) // Person {name: &quot;huihui&quot;, age: 123}p.say() // huihui 参考 new 操作符做了什么 「历时8个月」10万字前端知识体系总结（基础知识篇）🔥","link":"/2022/03/12/JavaScript/javaScript-new/"},{"title":"原型 &amp; 原型链","text":"原型 &amp; 原型链 参考 深入理解 JavaScript 原型 「历时8个月」10万字前端知识体系总结（基础知识篇）🔥","link":"/2022/03/12/JavaScript/javaScript-prototype/"},{"title":"this","text":"this 箭头函数和普通函数有什么区别123456789101112131415161718192021222324252627var obj2 = { a: 2, foo1: function () { console.log(this,this.a) // 2 }, foo2: function () { setTimeout(function () { console.log(this) // window console.log(this.a) // 3 }, 0) }}var a = 3console.log(this);obj2.foo1()obj2.foo2() var id = 'aa'console.log(this);console.log(global);function ab(){ let id = 'b' console.log(this === global) return this.id}console.log(ab()) 参考https://juejin.cn/post/7204707115062411320#heading-9https://juejin.cn/post/7146973901166215176#heading-8谈谈this的理解","link":"/2022/03/12/JavaScript/javaScript-this/"},{"title":"节流 &amp; 防抖","text":"节流 &amp; 防抖 节流和防抖的区别节流：事件触发后，立即执行且n秒内只执行一次 防抖：事件触发后，等待n秒执行，n秒内再次触发，则取消上次，执行最后一次 节流和防抖的使用场景节流：表单重复提交，按钮高频点击，滚动加载 防抖：搜索框自动搜索，输入框校验，窗口大小改变重新渲染 节流和防抖的实现123456789101112131415# 节流函数 一个函数执行一次后，只有大于设定的执行周期才会执行第二次。有个需要频繁触发的函数，出于优化性能的角度，在规定时间内，只让函数触发的第一次生效，后面的不生效。# @param fn要被节流的函数# @param delay规定的时间function throttle(delay){ let lastTime = 0 return function (){ let nowTime = Date.now() if(nowTime - lastTime &gt; delay){ # 修正this指向问题 fn.call(this) lastTime = nowTime } }} 12345678910111213141516171819# 防抖函数 一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效# @param fn要被防抖的函数# @param delay规定的时间function debounce(delay){ let timer = null return function (){ # 清除上一次的演示器 clearTimeout(timer) timer = setTimeout(()=&gt;{ # 修正this指向问题 fn.apply(this) },delay) }}document.getElementById('btn').onclick = debounce(function () { console.log('按钮被点击了' + Date.now());}, 1000); https://juejin.cn/post/7204707115062411320#heading-54","link":"/2022/03/12/JavaScript/javaScript-throttle/"},{"title":"V8垃圾回收","text":"V8垃圾回收机制 浏览器内核浏览器中存在 渲染引擎（负责渲染页面） 和 JavaScript引擎（负责js执行）。以Chrome为例：渲染引擎为 Blink(13 年之前使用的是 Safari 的 Webkit, Blink 是谷歌与欧朋一起搞的) 以及 Javascript引擎： V8 内存 计算机五大硬件之一存储器的核心之一。分别为：运算器，控制器，存储器（内部存储，外部存储），输入设备（键盘鼠标等），输出设备（打印机等） 内部分配栈简单说，栈内存，小且存储连续，操作起来简单方便，一般由系统自动分配，自动回收，所以文章内所说的垃圾回收，都是基于堆内存。 堆堆内存 大(相对于栈内存)且不连续 V8 中内存分类 （堆内存）在讲内存分配之前，先了解一下弱分代假说，V8 的垃圾回收主要建立在这个假说之上。概念： 绝大部分的对象生命周期都很短，即存活时间很短 生命周期很长的对象，基本都是常驻对象 基于以上两个概念，将内存分为 新生代 (new space)与老生代 (old space) 两个区域。划重点，记一下。 垃圾产生&amp;为何回收JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。常见的内存泄漏： 意外声明的全局变量 被遗忘的定时器 使用不当的闭包 未清理的 DOM 引用 垃圾回收( Garbage Collection 简称 GC )GC 即 Garbage Collection （垃圾回收），程序工作过程中会产生很多 垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 GC 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，GC 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 垃圾回收机制 了 新生代新生代算法为 Scavenge 算法，分为 From区 和 To区，广度优先 首先，V8 引擎中的垃圾回收器检测到 from space 空间快达到上限了，此时要进行一次垃圾回收了 从根部开始遍历，不可达对象(即无法遍历到对象)就标记，可达的对象不标记然后复制到to区 清除 from space 中的数据，同时将 from space 置为空闲状态，即变为 to space ,对应的 to space 变为 from space，俗称翻转 当然优秀的 V8 是不可能容忍，一个对象来回的在 form space 和 to space 中蹦跶的，当经历一次 form =&gt; to 翻转之后，发现某些未被标记的对象居然还在，会直接扔到老生代里面去，好似后浪参加比赛，晋级了，优秀的嘞。除了上面一种情况，还有一个情况也会晋级，当一个对象，在被复制的时候，大于 to space 空间的 25% 的时候，也会晋级了，这种自带背景的选手，那是不敢动的，直接晋级到老生代。 老生代老生代回收算法为：标记和清除/整理（mark-sweep/mark-compact）。深度优先标记过程中，引入三色： 白色： 未被标记的对象，即不可达对象（没有扫描到的对象），可回收 灰色： 已被标记，可达对象，未扫描完，不可回收 黑色： 已被编辑，可达对象，扫描完，不可回收过程： 首先将所有的非根部对象全部标记为白色，然后使用深度优先遍历，是深度优先哈，和新生代不一样哈，按深度优先搜索沿途遍历，将访问到的对象，直接压入栈中，同时将标记结果放在 marking bitmap (灰色) 中，一个对象遍历完成，直接出栈，同时在 marking bitmap 中记录为黑色，直到栈空为止 标记完成后，接下来就是等待垃圾回收器来清除了，清除完了之后，会在原来的内存区域留下一大堆不连续的空间，小对象还好说，这个时候如果来一个稍微大一点的对象，没有内存可以放的下这个傻大个了，怎么办？只能触发 GC，但是吧，原来清除的不连续的空间加起来又可以放的下这个傻大个，很可惜啊，启动一次 GC 性能上也是嗖嗖的往下掉啊；V8 能容许这样的事发生？肯定不存在嘛！ 所以在清除完之后，新生代中对象，再一次分配到老生带并且内存不足的时候，会优先触发标记整理（mark-compact）, 在标记结束后，他会将可达对象(黑色)，移到内存的另一端，其他的内存空间就不会被占用，直接释放，等下次再有对象晋升的时候，轻松放下。 参考 V8 引擎垃圾回收与内存分配 一文搞懂V8引擎的垃圾回收","link":"/2023/04/12/Browser/V8/"},{"title":"Vue项目性能优化","text":"Vue项目性能优化 代码层面 合理使用 v-for 以及 v-show v-for 增加 key 使diff算法更快速 不需要响应式处理的数据可以通过Object.freeze处理，或者直接通过this.xxx = xxx的方式进行定义 避免内存泄漏，合理定义变量，计时器，监听事件销毁回收 长列表性能优化，例如虚拟渲染，滚动加载等等 图片懒加载 https://blog.csdn.net/mynewdays/article/details/124446128 第三方插件按需引入 精简优化代码，例如组件化等 减少回流重绘 防抖节流 webpack层面 webpack对图片压缩 模板预编译 减少 ES6 转为 ES5 的冗余代码 babel-plugin-transform-runtime减少 提取公共代码 提取组件的 CSS 优化 SourceMap 构建结果输出分析 Vue 项目的编译优化 代码分离 splitChunksPlugin 将代码分离到不同的bundle中，之后我们可以按需加载，或者并行加载这些文件 代码压缩，Html,js和css mode:production，使用的是terser-webpack-plugin css-minimizer-webpack-plugin HtmlwebpackPlugin Tree Shaking 去除未引用代码 基础的 Web 技术的优化 减小入口文件体积 开启 gzip 压缩 浏览器缓存 CDN 的使用 使用 Chrome Performance 查找性能瓶颈 其他 尽量使用图标，不用图片 首屏性能优化分析加载慢的原因利用 performance.timing 提供的数据计算首屏时间。在页面渲染的过程，导致加载速度慢的因素可能如下： 网络延时问题 资源文件体积是否过大 资源是否重复发送请求去加载了 加载脚本的时候，渲染内容堵塞了解决方案常见的几种SPA首屏优化方式： 减小入口文件体积 静态资源本地缓存 UI框架按需加载 图片资源的压缩 避免组件重复打包 开启GZip压缩 使用SSR 减小入口文件体积路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加.在 vue-router 配置路由的时候，采用动态加载路由的形式 12345routes:[ path: 'Blogs', name: 'ShowBlogs', component: () =&gt; import('./components/ShowBlogs.vue')] 以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件 静态资源本地缓存后端返回资源问题： 采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头 采用Service Worker离线缓存前端合理利用 localStorage UI框架按需加载123456789// 直接引用整个UI库import ElementUI from 'element-ui'Vue.use(ElementUI)// 按需引用import { Button, Input, Pagination, Table, TableColumn, MessageBox } from 'element-ui';Vue.use(Button)Vue.use(Input)Vue.use(Pagination) 避免组件重复打包假设A.js文件是一个常用的库，现在有多个路由使用了A.js文件，这就造成了重复下载，解决方案：在webpack的config文件中，修改CommonsChunkPlugin的配置: 1minChunks: 3 minChunks为3 表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件 图片资源的压缩图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素，对于所有的图片资源，我们可以进行适当的压缩，对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力。 开启GZip压缩拆完包之后，我们再用gzip做一下压缩 安装compression-webpack-plugin 1cnmp i compression-webpack-plugin -D 在vue.congig.js中引入并修改webpack配置 12345678910111213const CompressionPlugin = require('compression-webpack-plugin')configureWebpack: (config) =&gt; { if (process.env.NODE_ENV === 'production') { // 为生产环境修改配置... config.mode = 'production' return { plugins: [new CompressionPlugin({ test: /\\.js$|\\.html$|\\.css/, //匹配文件名 threshold: 10240, //对超过10k的数据进行压缩 deleteOriginalAssets: false //是否删除原文件 })] } } 在服务器我们也要做相应的配置 如果发送请求的浏览器支持gzip，就发送给它gzip格式的文件 我的服务器是用express框架搭建的 只要安装一下compression就能使用 12const compression = require('compression')app.use(compression()) // 在其他中间件使用之前调用 使用SSRSSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器，从头搭建一个服务端渲染是很复杂的，vue应用建议使用Nuxt.js实现服务端渲染 参考 SPA（单页应用）首屏加载速度慢怎么解决？ 首屏加载速度优化 参考Vue性能优化 当面试官问我前端可以做的性能优化有哪些","link":"/2022/03/12/Optimizing/vue-Optimizing/"},{"title":"js.map文件的作用","text":"js.map文件的作用 source map 文件是 js 文件压缩后，文件的变量名替换对应、变量所在位置等元信息数据文件，一般这种文件和 min.js 主文件放在同一个目录下。 比如压缩后原变量是 map，压缩后通过变量替换规则可能会被替换成 a，这时 source map 文件会记录下这个 mapping 的信息，这样的好处就是说，在调试的时候，如果有一些 JS 报错，那么浏览器会通过解析这个 map 文件来重新 merge 压缩后的 js,使开发者可以用未压缩前的代码来调试，这样会给我们带来很大的方便！","link":"/2024/03/05/Engineering/source-map/"},{"title":"说下Vite的原理","text":"说下Vite的原理 说下Vite的原理","link":"/2024/03/27/Engineering/vite/"},{"title":"Webpack 打包流程","text":"Webpack 打包流程 大致流程整个实现过程大致分为以下步骤： 搭建结构，读取配置参数 用配置参数对象初始化 Compiler 对象 挂载配置文件中的插件 执行 Compiler 对象的 run 方法开始执行编译 根据配置文件中的 entry 配置项找到所有的入口 从入口文件出发，调用配置的 loader 规则，对各模块进行编译 找出此模块所依赖的模块，再对依赖模块进行编译 等所有模块都编译完成后，根据模块之间的依赖关系，组装代码块 chunk 把各个代码块 chunk 转换成一个一个文件加入到输出列表 确定好输出内容之后，根据配置的输出路径和文件名，将文件内容写入到文件系统 参考 webpack官网 二十张图片彻底讲明白Webpack设计理念，以看懂为目的 【webpack系列】从核心概念到上手配置 webpack配置完全指南","link":"/2024/03/05/Engineering/webpack/"},{"title":"了解 HTTP HTTPS","text":"了解 HTTP HTTPS HTTP1.0/HTTP1.1/HTTP2.0HTTP1.0 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接 HTTP1.1 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用 在同一个TCP连接里面，客户端可以同时发送多个请求 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着 新增了一些请求方法 新增了一些请求头和响应头HTTP2.0 采用二进制格式而非文本格式 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行 使用报头压缩，降低开销 服务器推送 » HTTP和HTTPS http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。 https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。 HTTP 和 HTTPS 的区别 http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。 http 协议的默认端口为 80，https 的默认端口为 443。 http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。 https 缓存不如 http 高效，会增加数据开销。 Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。 SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。 » TCP三次握手 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包并确认客户的SYN（ack=j+1），同时也发送一个自己的SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。 » TCP四次挥手 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 » 从输入URL到页面加载的全过程 URL解析，查找缓存 浏览器首先对 URL 解析，解析出协议、域名、端口、资源路径、参数 浏览器为了提升性能，在 URL 解析之后，实际会先查询是否有缓存，如果缓存命中，则直接返回缓存资源 浏览器缓存(强缓存和协商缓存) 系统缓存 路由缓存 DNS域名解析 浏览器向DNS服务器发送请求，根据域名解析ip地址，DNS服务器基于UDP，因此会用到 UDP协议 建立TCP连接 三次握手 发起HTTP请求 服务器响应并返回结果 服务器发送相应的html及其他文件给浏览器 关闭TCP连接 四次挥手 浏览器渲染 解析html文件内容并渲染 构建DOM树 构建CSS规则树 生成render树 布局 绘制 js引擎解析 调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等） HTTP状态码1xx代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束，常见如下： 100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应 101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级2xx代表请求已成功被服务器接收、理解、并接受，常见如下： 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回 201（已创建）：请求成功并且服务器创建了新的资源 202（已创建）：服务器已经接收请求，但尚未处理 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源 204（无内容）：服务器成功处理请求，但没有返回任何内容 205（重置内容）：服务器成功处理请求，但没有返回任何内容 206（部分内容）：服务器成功处理了部分请求3xx表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向，常见如下： 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求4xx代表了客户端看起来可能发生了错误，妨碍了服务器的处理，常见如下： 400（错误请求）： 服务器不理解请求的语法 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403（禁止）： 服务器拒绝请求 404（未找到）： 服务器找不到请求的网页 405（方法禁用）： 禁用请求中指定的方法 406（不接受）： 无法使用请求的内容特性响应请求的网页 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理 408（请求超时）： 服务器等候请求时发生超时5xx 表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，常见如下： 500（服务器内部错误）：服务器遇到错误，无法完成请求 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护） 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本常用场景 100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输 101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级 206：一般用来做断点续传，或者是视频文件等大文件的加载 301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名 302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面 304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分 400：参数有误，请求无法被服务器识别 401：未授权，请求要求身份验证。对于需要登录的网页，服务器可能返回此响应 403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回 404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时 502：错误网关，服务器作为网关或代理，从上游服务器收到无效响应 503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503 504：网关超时» 参考 ☞ 🔥 连八股文都不懂还指望在前端混下去么 说说 HTTP1.0/1.1/2.0 的区别? 说说TCP为什么需要三次握手和四次挥手？ 说说HTTP 常见的状态码有哪些，适用场景","link":"/2022/03/12/NetWork/http/"},{"title":"Cookie session localStorage sessionStorage的区别","text":"Cookie session localStorage sessionStorage的区别 一、cookie Cookie是服务器发送到用户浏览器并保存在本地的一小块数据。 客户端给服务端发送http请求时，服务端会在响应头里面添加一个 Set-Cookie 选项，浏览器收到响应后通常会保存下 Cookie。浏览器得到Cookie之后，每次请求都要带上Cookie Cookie会被用户篡改 临时Cookie（会话Cookie） 永久Cookie 不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。 设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。 二、session 服务器通过cookie给用户一个sessionID，sessionID对应服务器中的一小块内存。 每次用户访问服务器的时候，服务器通过sessionID 读取对应的session，然后获取用户的隐私信息。 三、localStorage html5提供的一个API 永久有效，除非用户主动清除缓存 设置缓存：localStorage.setItem(‘key’, ‘value’); 获取缓存：localStorage.getItem(‘key’); 清除缓存：localStorage.removeItem(‘key’); 删除所有保存的数据：localStorage.clear(); 只能存入字符串，无法直接存对象 四、sessionStorage sessionStorage用户关闭页面就失效 试题1: Cookie 和 Session 的区别 Cookie则是服务器通过set-cookie头给客户端发送的一段字符串，客户端每次访问同个域名都会带上这串字符串 Session是基于Cookie实现的，通过Cookie向客户端发送SessionID，Cookie进行存储。 cookie是浏览器上的hash表，session是服务器上的hash表。 cookie能被篡改，session更安全。 试题2: Cookie 和 LocalStorage SessionStorage 的区别 存储大小：cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+ 有效时间：cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除 数据与服务器交互方式：cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地","link":"/2022/03/12/NetWork/cookie-storage/"},{"title":"Babel 系列【基础篇】","text":"Babel 系列【基础篇】 Babel的原理主要内容如下： Parse(解析)阶段: 解析源码，生成 AST Transform(转换)阶段: 对 AST 进行转换，生成新的 AST Generator(生成)阶段: 根据新的 AST 生成目标代码 Plugin 插件Preset 预设参考Babel 系列【基础篇】","link":"/2024/02/27/Other/babel/"},{"title":"基于 vue + electron 编写一个桌面应用","text":"基于 vue-cli3.0 + Electron 编写一个桌面应用 「 说明 」 项目地址：Monit 根据 README.md 文件教程安装依赖并运行 由于对 Electron 暂不熟悉，详细代码实现后续详写，本次先对项目安装构建过程中遇到的几个注意事项记录一下。 ⚠️注意事项 安装依赖时有些依赖文件较大，需要等待下载一段时间； npm run build 过程中需要安装打包后应用的环境文件等，可能需要80M以上，若不想长时间等待可以使用科学上网或者根据地址手动下载安装包放入文件的方法解决； vue-cli-plugin-electron-builder已集成跨系统打包功能，只需修改打包命令及配置即可实现打包 mac 及 windows 应用；修改如下 vue.config.js 中修改构建选项 builderOptions 12345678910111213141516171819202122232425262728// 构建选项builderOptions: { productName: 'Monit', // 应用名 icon: 'public/logo/icon.png', // 图标 appId: 'top.fzf404.monit', // app id artifactName: '${productName}-${version}-${os}-${arch}.${ext}', // 打包命名方式 linux: { target: 'AppImage', publish: ['github'], }, mac: { target: { target: 'dmg', arch: ['x64', 'arm64'], }, }, win:{ //win相关配置 &quot;target&quot;: [ { &quot;target&quot;: &quot;nsis&quot;,//利用nsis制作安装程序 &quot;arch&quot;: [ &quot;x64&quot;,//64位 &quot;ia32&quot;//32位 ] } ] }} package.json 中修改构建命令 12345678 &quot;scripts&quot;: { &quot;serve&quot;: &quot;vue-cli-service electron:serve&quot;, &quot;build&quot;: &quot;vue-cli-service electron:build --win --ia32&quot;, &quot;package-win&quot;:&quot;electron-packager ./ --platform=win32 --out ./dist --overwrite --ignore=node_modules --arch=x64&quot;, &quot;release&quot;: &quot;vue-cli-service electron:build --publish always&quot;, &quot;prettier&quot;: &quot;prettier --write .&quot;}// 不加 --win --ia32 默认打包成当前系统应用 参考： 基于vue + electron创造一个随心开发组件的跨端桌面应用 使用vue-cli-plugin-electron-builder开发vue-cli3.0+Electron桌面开发应用","link":"/2022/06/12/Other/vue-electron/"},{"title":"部署vue项目至服务器","text":"部署vue项目至服务器 步骤如下 下载 finalShell 点击文件夹点击ssh连接 名称 自定义 主机 服务器公网ip 连接名 root 密码 服务器登记密码 点击确认 接受并保存 进入命令界面 安装PCRE pcre-devel 和Zlib 可能还需安装GCC和OpenSSL 安装 Nginx 版本不对可能会报错（可以通过注释 -Wrong 或者 换版本 解决） 目前是 1.16.1 123456789101112131415161718192021222324252627282930# 下载[root@iZbp1e31bqkj6opg1bsdr0Z ~]# wget -c https://nginx.org/download/nginx-1.14.0.tar.gz# 解压并进入nginx目录[root@iZbp1e31bqkj6opg1bsdr0Z ~]# tar -zxvf nginx-1.14.0.tar.gz[root@iZbp1e31bqkj6opg1bsdr0Z ~]# cd nginx-1.14.0# 使用nginx的默认配置, 编译安装./configuremakemake install# 查找nginx位置[root@iZbp1e31bqkj6opg1bsdr0Z ~]# whereis nginx# 进入 nginx sbin 文件下启动[root@iZbp1e31bqkj6opg1bsdr0Z ~]# cd /usr/local/nginx[root@iZbp1e31bqkj6opg1bsdr0Z nginx]# cd sbin/[root@iZbp1e31bqkj6opg1bsdr0Z sbin]# ./nginx# 查看启动状态[root@iZbp1e31bqkj6opg1bsdr0Z sbin]# ps -ef|grep nginx# root 600651 1 0 13:57 ? 00:00:00 nginx: master process ./nginx# nobody 600652 600651 0 13:57 ? 00:00:00 nginx: worker process# root 665038 658796 0 14:35 pts/0 00:00:00 grep --color=auto nginx# 验证你的nginx.conf文件是否是正确的, 文件位置 /usr/local/nginx/conf[root@iZbp1e31bqkj6opg1bsdr0Z sbin]# ./nginx -t# nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok# nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful# 修改nginx.conf文件[root@iZbp1e31bqkj6opg1bsdr0Z nginx]# cd conf[root@iZbp1e31bqkj6opg1bsdr0Z conf]# vim /nginx.conf# 重启 nginx[root@iZbp1e31bqkj6opg1bsdr0Z sbin]# ./nginx -s reload 浏览器输入服务器IP(公网IP)即可看到页面 若nginx启动成功，浏览器无法访问，可能是防火墙开了 服务器端口配置的不与.conf中一致（以我为例：服务器是22，.conf为80），修改conf或者服务器端口设置（阿里云服务器可设置一段区间都可访问） 打包个人vue项目 打包配置可能需设置 将dist文件放入nginx目录下 finalShell 无法直接上传文件夹，只能单文件（文档写的是支持的，可能是操作问题） 因为第一步的问题，所以我手动新建 dist 文件夹，再把 vue 打包的dist文件中单个文件共同上传至该文件夹中 修改.conf中访问文件的目录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849location / { # root后默认是html root /usr/local/nginx/dist; index index.html index.html;}注意：npm run bulid 中，设置 vue2： publicPath : process.env.NODE_ENV === 'production' ? &quot;/meal&quot; : &quot;/&quot;})，生成的路径应带上文件根目录地址vue3: base: './' 生成 相对路径 ./assets/ (vite配置：https://blog.csdn.net/weixin_45822171/article/details/127275984)上述 /meal 生成路径 /meal/assets/ 打包之后index.html中路径如下：(若不加/meal,上传至服务器之前，无法访问)&lt;!doctype html&gt;&lt;html lang=&quot;&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1&quot;&gt;&lt;link rel=&quot;icon&quot; href=&quot;/meal/favicon.ico&quot;&gt;&lt;title&gt;today-meal&lt;/title&gt;&lt;script defer=&quot;defer&quot; src=&quot;/meal/js/chunk-vendors.0833686f.js&quot;&gt;&lt;/script&gt;&lt;script defer=&quot;defer&quot; src=&quot;/meal/js/app.31f1556d.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;/meal/css/chunk-vendors.e18646e2.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;/meal/css/app.8bd79ca3.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;noscript&gt;&lt;strong&gt;We're sorry but today-meal doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;&lt;/noscript&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; location /meal { root /usr/local/nginx; index index.html index.htm; } http://web.czhhx.cn/neck === http://web.czhhx.cn/neck/index.html location /neck { root /usr/local/nginx; try_files $uri $uri/ /index.html; index index.html index.htm; }location /refresh-step/ { proxy_pass http://127.0.0.1:7001; # 转发规则 proxy_set_header Host $proxy_host; # 修改转发请求头，让8080端口的应用可以受到真实的请求 proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;} meal: /usr/local/nginx/meal refresh-steps: /server/refresh-steps 重启nginx [root@iZbp1e31bqkj6opg1bsdr0Z sbin]# ./nginx -s reload 访问浏览器即可看到vue项目 完结linux服务器安装nginx以及vue项目打包部署(Mac)","link":"/2022/03/12/Other/nginx/"},{"title":"常见知识点汇总","text":"165d50f05814027fb7fe5e4ae8a088d829f96e3a1515b3df41063f132a3914ad9b36fd3758d13b07932d7c1410f1e84b6e35ce0794f98d746a18571012d14dcbd2ecda21e7914dddd82f7e15467ebe58bab0651ee3ce91318056e61547ce77833d0b54753e0095b6c2ee6cac3879645afc074cb758ca4ee5b928d8752283ce95d37cddcf7fc66ea2a40f080db3f8471d4502264dbdf8723f36d60061a33c01cbe8468d93ae7ee409d6ef9d66bcdccee73a95bebb2e87996ecac9e441e41ee6dfd9ab850412d461ab9fcf732296412e683a3df4ed71a6e5d745ba6ae7046b0e7546038712164cf61a196da9d24c637c2c380f1a2a7bd1a67d387b252517ef41f92b0d3582cb65e5d283c22ed3890dc890ed00e429550846d457a0a3710a4f39edc74be1813da123028437f1bab8d6aeeaed7fa559fab28a39eb470db12fcd6086ca65bdd412ce81bedf7db9abd83f717859870ecba43480a26c1bf3b287a27a4b8cd2dea1f59b9fade4ba079311bf4ace46a47f53b8846279f73e7ee04c2d5de4b96feb3a5a01a96e7edfc3aeeb6f3481e8749d890515e7a3fe64919f33df0a732565b47fea190c8d66911a7e0c103a59f38a10109b1f8aa91c84f17b66685fe233101d2ff46e3791fabcb131e5801c11bc7ec29426aa88ef2582b09033cadc80075071268cbe62e8ca2b06d5ad7cb53f957d5b317e961c44d3472f1c732c0a21e2b5f12b23a119e97c0ddef4efed8ca249955062db9aedd6811dc8ff9fc2248a3414690240b0f515946d8867811d922bee63041def17f009a4ffa1c31bde267eae050603caddad1080357882eb606305a9fc0b684ae71f62a77bf2e4e5c7fa0288fec9dbb3ad2429975fad16169da9db429f10c10a3d6cd93cbdd15be8fcf376af83c44f6d10d1f60c997fcc55f1db8c6bfb86243265dbe4ead48053d0c75593d5d1be57beb332970843970b2f8e5b82a7aaffcb6ed2faa1e5496f21992e0f090d28c3419940057ae0e020bcb9ae82bd74c429e43e9431923fb4c81175cc1b2dad3b66ab10c5ad37fb98d10cbff5f29c77fca1908a9954599a5f6c304cc3ba181e755b7850294dac448caf96b60b6a2d959675a8113222655a23ba5aabd46a94fd97717b2c431a3b7f400c9ad398c072c9fc92a910903d32329f9067d65d6f1185604c5d4fb3c288ea586c0efc7442914ace907fcb548b0e375a6abbba5faf1073088686fa491b0357b58c0837babdb4be17f66cdf8b118de940643f56bd15cc9516b0438edf4d7ec89b713e9ee3bd5828fab7a237bd36dd8632e849d4bb806d135f4b6069f83226018134c41e079537dc0fbcf6de7e52fc7acf1f518ed4d608b01f61b67a15dfcb766976404c72bbf738b39998d6487692b20a8c415361741a605453a3d26f01ade617f1e5acf34a7e3cc0fdd7f6beb8f16b55570b51555c01e6bfe6e307f23463e1dfb4ab70bec2ce7d96997f650106be9a740da4ba92ce1cadf643279d58ab13e89aeb33e9dab28eb73a708311468abd0946717800fadb6883ab37ce6219d119f03545a409b811ef535a330297682c22f5646e861edfa68f2f05e1bb8c34e7dfe082e07d587dffb6cd8dee386410e639135f9d3a02b995251bca190180bda58e65acef13a0c6502186d84e6b040062a9fdef8c0ba4f9e8161e623dd54073ed4cae0e493357b05d604747564be0585f60a3630c42cd101e988ae3b41cb8f4008b35cfa50eadf4ada1d8f24714af9fba8cd3316af3c14dbb9dd60b20f79898cb7fe8d4d74be99d6a933e31b9b2c8abd89057bbee36ae935a65b6e98b307f5e5601716395b289218f0a5de8123e9d826d3d508049e1ee10b76849f5cad3a76f793ab2bfb53c2811481f555adc72587ccbcf9251e08a889f433b88130af53ba1c252d6199c268e9db6deaef924915b96858da6f04d32f9995daf644b187d7eecef4f48a18f5c00e0061f0467ce3868005c21befa90379def671acb47780ecf679afdc28688dff80ce7f5e5fdd614bd3670d672e4de4ae6883180c00c28112160daebe76b856ba642137d17e6de29bd3dd93d5c05a5851b90d14987211779ec3540a4d6f615dcea9bca9feeef6fbc2cc71ae4e3312f2725f15d5e7a92564c3805bab8b6223d49d05b6764fa522c93f419d7bc604bdd4a9bf2e65998d247504cb902e0a220e280e1527ac90d2d5cbe3b1e352f1eacefe374651b87ca22aee315011de6d9ea9e5179618c316a1b3f6ba1d60a80f34a0c3a70d26292c2de29c22797b031f9f078c81d1f79fb62cb8360585ae9f7e4ca2d38e466fff6f5c9f1b4c857865a0572e1942f9ef32554c8b9655349fb126f18e5433ed43045b7bc9e91a37e544950f7961f8fd23d401e6ed62c4acd2016dfb615920ed1633da12e0410b4b5e3788f3d74eb7bbc694bd42cf5438d2e7b11ddc00913cf03660155e0f4ad03996dcaf3d92e8aef2d1ca75a8da60194292e9c13cf861a460993368cd3334b33efd13fcd262aa6bd7819e219ad80b19cf6c3562b02b834939d8c62903433e6c6961704dde028e30f9a4fc4c6573c4782618ee44023e76d1c127d7a770bc89f5c7eeee6a654c992e18737b58fd197bb46cf167b116555b8b5c4edbaa7aa6b7a590d0fa255cdd141805d97de7e4d692ac85700c9e0e1a5ba0f223f4fa0b4ba35767f1ecd7f67a434e1fc5942fc2cbf9186333ec77b844acdc1fb1f1076b47c3eb3a3b60706f4962e2dc981dc98654c001132011c45c43ff814ffcb3fa30a497c1d39aae17ff569a9974a200863955853182fc0c20527507231fb7db27b07b25d246b0cce54f1e85d5bea507f5b594e055e4256aaa890e17ab2d4e6fa2f0b2a7bf4e682ce91c35d3d8b6a95d095cbc694a9dca0b47931f9e96b3c4bfe399fe4c201c26b2501cd813e9ae629db4e18b7f4e4f3fd724ec18185f7cc75064ca957daee4379dafa655abf160b3a56151eb08a151225132a9b0e3af710eb6a82d2eda8cdfe63487b5952764d103904044d61eab093b394433b77535e42c136452b636cdadc37c4be7c37b981bf249595d7b48af5d2609e3cb5492bb600ad6b15639fea6be26bc5b4ab756dc6f464482af427d548f2449b6a3130421cfe38db838ee79d6cb9b8e3e620809cd6fd88f2bd5dcce79a7c524b0cadc31389dc8c68187f9275ffd5b70b76132ea8e4f0fe5cf9f5380e9da07c290282b13171088da6c9ffb2b2eff6271e030dd2f281fd3edc64f0fc97f9a5ec67dd147992e4fdfe5ee592a875c2db46424b8d23d7725c69aeb1eae17aa182de9a89cb70d994058ce89353facbdf6fb646e1e0f4696927de063d69fd75a0ad3ef13701fa661b0fa1714a2e814949c3e6e15ddf9a0d9ba5929a1e216b6a2dad5816be46569cc870bb70c5f1a7d09334d0ee5d4fdd041e96a722a45582c65faf89ad6c08597bf39de8c2f0f12643a1e30116d3572610c7c5dd14b2d8ec0ba1a004fb8a1351ee404cc6bbcf67676fb973c81a8f0b22011efea6059215adc3eeb26ea9a83ab5a13aeb870ffb3eda1031ec309644fcbbfd8d399ec8824a00bad2af62fa627366c2d807b042d8da5496025f18a71316e2f4efdd187db9fa4ca743ac6b877fa32cb17a04f38d0bbc5714a808de632a05319375979c86c9c90cdc25f7e0cfc4f7c29ddd6fd8dd47dd528021ac3bc92d9442f302c4b74a018e72ba56c38c35ba5b781ba9c204fd837c88a79b07a898fb77029f3c9b6346e9a40c4d57132656113473b493fad89b0a64dcfeb6239bdcbb72db31e24747f3ea2d8fae772bd17f6ff964f68b6923b63d62167686932e7a463e9dda698d4bedafe910c19657c578685e4902897ef8e96e3d65aebbc8b1baca5e287dd3915457b1903cee4ea2693c4e568012d0469c8a4a7de62c61adb28cd35d41a85cb80b46023cc83787a7c9ab5a80ad0699139580cf33949d937c16494c115d5d45d68a6a8dee9289421550f1ba4a2a3210c3e2eea2040469d43625bc8917057016ec7d7abda28a0b1da13a8efe1aa344b1a13d499daa2ca9665cce5d74fd5e21179afb3f758117894624bb4d7660a6ed542df842c804562f73db0a64a0e9c659d4f231417446a52dc0d9bf53e7cc7ce5636dd060caf1d986053f04a38ace2554ed8ae865840c55cc3d94fe323096adfd27add548530050aa1985c00ac755943e17a710e4a196da5c5d6d936e1f7348753c7014e6489796f2e464d842e7b85c6c528f79fdad3731c7ef13685cf56cb3472d2e64bdccb1c134092c871e3bc5fc5ba3d96801463cf30778336489641f5b0d466520fa0f815bf14f28c478866503f2043f5f7032d69395a3c9ccc65996a05d30a1630a671a95257c004fd717c260b9b613bd6cb6095bb49fa9f431020f055d18f92ce3476e15d5250baf38bdcfdf774ce37255a15bf59c5b13fcfe77c2e87214e0e573dfa35fb95a1116b097168b131cc44b5cdfaafde2e8b9e1e8447c42aa1500c65f1d3ddae40fd96985e7f8ec3ad27ee445a0de227947db32106f8b320e6e1c53984b8e30a5d07ae19f65dc3afd9a096a6ea21afcd173c4a8d112b996db35e80eb491a1cdab6b980d3d17acc3a26fc90eb2fdde3f54b431fe0f38ac9ff4c9c663465b1a16759e0c49e1374663645ac7511bd4189b88534a36414b71bacec07ca6f48cd7d933669d4170728adec0b3c7fccd0b506cb56a1d5d1c8b3f11bdd553b0efb013777afe64037bb151a06da9eb10c6dd884efe1c5840664e7334155031702b9fe226e01fc82be7850c4e5af30da1a53ff29a78bc897535a6cdc703663c9f86343d5d4e6a8e929c8a60c731a2a652e8e7d173ffc2b7d5ec67a52202e390351aadb4928cc164fff01e40a8fa4c95d960290feae721ba942cf57c7552278d528f0971452e31845458844090d54ba1e8890d229e0567963477189184be8e90312902a8d367412a76f44286c7049c7e027ea5091c8d8d07860212bf42cd17bc3fbfa356ae7e8580b0647a52ab969a6421c95294365da21cb515f80eabbcb926a1a9d1cf736ebf18cb6b766af431dac6e67888e1f2dbe7976c7c85d36eb0942481e017a05f7d22c474929f0cec3acc6ee7b753575998eac13bf2beb5caa3c757ddd9ebe969fd99f677914792da7eca033eb3114c0cc1b244ecde429461abff378fabdbf3b531eaf78490377acbf4dbed2406c52590cf2df79caa11e564224543a7ef13afadaf71126ccc625d994c1c32061f92a3c4dd2b6f691495bd551ea335011cd40d5038c9e835d797b697848bead6c181b5c9198947cd50dec63f43b95821e58e0223d73e5df9307b945fca89ba3a4f3f8ef910dfc0e661d7dce9485f6b9ab77c17704b1ba5a7c0d5b84a6d52c0c5a1b0b73a935a9ab58b7311db8ecc4e150504cad9f6788eadbcba376826a27575fa0891977838260f34d017f61801554d7e8b7e26849dc6562428b65766d30e03e6c42cae9d5246a4e53e717d9d7c35b99caaf515b42c17d9fff5c3c30e9085092dfc84c3c61c3c8556686e2f2f8eb5f02517b97282bd791272b5a7814b53ed3d9721b270265243c87be48f717b62846e7aa9b12107f1ed7d810561953ca5bedbc45565c9f19a80a0962872c25b86c5f497b31c3a2152f316440d751e2e48bf3c7e248df6931382c52054862c2c157f49a47ea00d6a6e7a64f343dae4902912607c7ec215280646bd8251baf2c2a859eccc7547adb0fa2f21ab32a0ccb4d0ec727abefc3df5110f61263180b8980c6dfe473d35dd2e21a7dbe630994b155108aab51a520805be37283811e4287b88b7d76da2f21f9749225e28ba5e87c97cfd9623c9247113040f046743fed023159e479c3ad75fb2403c8a6b85caa67976dac26067df8baee2fd223e2101cbe35079646cbc0506e6790f4cf377c645b1350b52ddb3db8c68db628a32094216643cc07e3f9e70f2d85e5bc85e0e776f446cd78a3361cae26e29f6bbd0eda15b6c04aeef66d9705acc46b169c0f370ade97f032ea7eb52995d0949e2e095b6d7f75e84b8246a3d4049d4ae7d1dd4d60ee7a634ab5b0472db9ab6da9c5814d9ef5e393a53721e09d1d40eaca07f27923fab808b1c0e35ce075647f85a05db567be447410e63f928bdb0c95654210bff21d728e796f93596c591708d1ec12f5b97670723fef6dc2e53d6728d0d9e3e834d5ead237cf6633aea13ce83ee80ea8804b8b2b39c866df1da970499c9748f3e9ea3e60e42c272598471581e43e5009806787db6327a62b0474c0bc7ea9d149421cc318e22f1ac1a7550750447ea44cb53c27e252bd8fabf081a19e4b67e94eb8fd36462c4593c830d48615d943c3f227a8fe097c241d7b3ac566a7bdab7637976323f2f8f6f287ee44e67574b6fa3f6afd97e6af4b083161e454947eac87d024dea6782cd3e90378633fb238648710f13310b20f87b099f2062aa7ae0def5302dc17b59b62ac7a2a9c4b8a179bd129e76756a1250acd9964ecc69d07cbfe777711041a070101824c280cc2ea6189f0134fd55e4a6d0c4c7f1dd0775ae579a7fe8b25b58320ba3f335ee4013f77078f9fde3c18aaa844f7967623782c758b75a8e1c11b98d5fcde5d929d5303316872d8d2c12073c10ae741cf6d98b5fb9b7b6ba61ffe92fa23a3d24929f8d1d13b54697f0da134983e4f47910c2443be95565444108a0debe323a5a70131e998a1ce4952ac65cc937b0d8d9e8f6b650f974929cce92b2205cf3db92999e3df9f420361f26debc6b4814d998d88381ed7ea438a2ba270b7b00d2845a9556006cdfc37a739d24da1548093ec56b70cc1b07dfe00fe792b3284dfca8a66b453e3623ffbe557b78a6d1a6e2e8a409b3f1d8019530198d737d806b87f197e676c8821d4b3e4cfad3a61e9a82f3c92a42a0d752eac15b5ae3fc250e02cb412e7466fb5aa3acb2f217903fbefee40d2c9b3f27e67eb6fc24e94fe99c337f02d0799cb5b772737d2c1b50f7e442c99ac800932238b062fbc162afa4ed1d1d2ae162e518ee811e75a7bc135a5c9c3bb42ceae5927215c064db0969a6fbb16462998e62edb7267c5d7fd13ca7e1fe87dc7a4991078bc7e70af5f7a29b5fdfa774dac3432b6ccbffcad9d5a7d785496c7c8ec47e43c4cba5069394778d05830fc476fec7794e25b98adaf9ac54a40c2a393fb037d306018ea8e0286ed06bff4ae819781c1e00141ed2e2ac066bd5fae171462864c091b7890d777ec4cf486793a0f685c68bfdbe2831c778f16338725d5cb2a33498d1c013f79a3afa3e08efbcf4c6a1ab4da0a6467513f2c5b799bfb53f03daa4f0ae819cb1fa3250fe7500f800d41e54cee54c699bd04403471027957e63c6cba5df6a26a39b8d29a7c9cd59ffbdcfe06b2e861d9a0c74032f174ae6ca2818750d3ccd37e16c34efa72383e177e2334a1b97dfe19112cf8a12947d9034f5d705eb9e298652d2f2d7483a60b63879c512ca26351e1a72b71a45378c2b9d68071ad3f651b7b18d16818cf9b56a97157d75fa04bccf73f3db7fde7f8623731732f2eebcc0bf9b3e88e3462e86c7b09a946401c0ec0f1c6849596f7531874f545d26257232668aaa75855813cf2416cff7b02fce7db49eba6debb42d0538eb3d4d7a6a69b8c180ccc45228de0a51423d14c5a009e7ecbd4a12afa1d31d57dbb98d6ba09a683afe0088edd6b8f9afbd299ea975accac2a0a5ad54091d93df39855eb55fce89bd201321bcff84d5f05ad4d1268bc6995a29f6d4c5d384d8eb1dab719a5e84de095ddd2d286f13e393aab482ed19395b15191201f32a60dc16c303234812186c04837fdacf99391cc130a4cf40a2e0e50cea796f0471dadd83bf40ba8b795e55fe6352c9da4042eff7cc18a4c1710e60ed757015c766951723e2a8b3068dd99a514dcddbb02c2ddf81e6b0fd8986b037d8b691c46435bb747a2028d212fb53e6a762cf573eeb9eb30985a43995a93fff1dcf3228bd9011253eb3d25840b3717af9539ad3fb4ac448e0a93f900f711d0886de6f9f78dc325cc0394b5619326d22d2047f365e84063504e4861b0e9258aee5c7a284f0dc7bf745e58ae4685d901186461c21a6526bf3404ec823c2a2de5bae82148ec9a2a72bc412fcb2183c332f0feba697762eca58fefd7e6202b79708c189798308bcd53d07f2a4b8ae43843fc2481a731fe0abb5b20f9aae6c2882f5cc6163ce694430c2b110d6e347f5b41fb981fe5e2ded6afb4f01cc2fdfb5d96d4681c2fa8ba6755b85662d2a05a400295527f810dc07872e4b078bb46e04a97878d15d257568baf0e305643d1228e95b354babb7b7724810c6e1f7663d395f7f557b403f44e5772a08f58c85e99352c18bbabf60f63d9331999d9abac5adb280724cb4bc9ee9042e5e1dbf15a14aa5dc0ac357b2fdf6c990e23b11b84a6da1428a2fc062be3ad44bc624acb51f95af33e6e5c64bc9d452d18f5fde62efcd55adf0aa9df1aa8032a703374d81cc04b7ecbf5bbb2beb7eea7bea128cc6eae15bc78d8c5ce7dbbef30a2e45ebb77031424450d32ec11af708e804f881a906e4fe913e5675e2c82fa74b5fda77f4fefec121894f708eda586be04422d78487e1d25f5047d33f7a1c06aab3a1c91bbd9c0d7a5022174e3d90a1e41741a4b0a89860e8b598ec0c11fa6115c6b91cb531ad6d9f10641cdde4aef1ac5b8de42257f33f0b248c66a38d372a32404352a78625f3edf8d655bbbe39a595bbddc68dad6de08e2d0c4a59899caf953341c2cb246cc92649ed9ae4b29017d6c12aa86c0a2b76ecb739a76afd7479da900a1fd05838233d1c71fba3955435b2a6eadc3fbf4f316e96356e6d2ca1169c6b839dd11f3baa54672e29cac483bd18464c7bb84b290fb9861e96e7f3c94cb64f7bffbe62a88a55478b61043150cfe81c9d7d1f9f707dadc8bd0180fa9369471ffdcb447c9433ba98bed993ac2b1d2001c90add8b12f983eff91439d7668a3bea957c9f6d76f9ff5db6a8753c1057f28cd0a838e6cb83f94d1ef4257dbeaca23350781e4be8d73d68d7848b166bf3146023581f262069f6004b153ac5f733127dfae82ddbe9f45dc642d905242d06504f1468b5af87fa3c6c3e6c5dbd2ff111bbab875df3dcda0132dafe0513ee6677a2c949c01ab87c74b639d0f6bece31513169321ced23195893f9adb2aa2f27de4aa79508761d7ac483cc98b387c968b92553093f739728115150a6f23ad996ba7fbac6077f7b52361eefeee8959ce1d57965b306f81376bacf63b56f5c96350e8dfd8065d7dbcd67961ed97d1b701c6c09cef470104481b2b9acabb4a5f9b4bc3db83594eb35fb682b2d9dad9bdb7248e95ef2c68a14acadc4b99d7cb438fe20153a7f41a4f3ed47a5a027a07476bc988d171d240a8e245bebb0219ccd010789f5d0adc6d33753635c86cf117116f11d9ea9dd00bc4d7c71c2267ef4053a83981a0567f635138e8c2539cbb4e106a3055354384476bacfb173fd68ce0fd1fe4947b3529ce0ceb35809dd2dff2094694f2f273c3567c062e7744c79dbc4357a2f7996f371fca011f853cfbf4dad2f817c73c4a3499b2edec1f451a18d24726199e8d172ba0e6adba43e220462c80ab7c770630d3bed3c92eaa042e328c1ba50038a00f90e915659507c29d34f56e58b90cc59242bff25e923989ff139984bf667456f26d8a2d2ca695a9c08143dd15c3e85ffa21cb87d75d1b1639157c10ff5dadb5974e733295df2e4192e032c21db1d823fa9bc6dab131068438c868b0ce5349d59adc6d64a009c173c7965a0ec6a1307b4032d925cad29a34b27296ce19e0d3273d7d5d216e1ea3173ffc8914a4cd21e3312730777a46249f8063a8f4b63ec7b14363c96cca279d2d92968f340006b8e0d2d84c37a9c9770484e9b726f6385ec50f2fe0b89d06ac2e9ebeb5475ef7580d205c15f645effc340e74e439fd30d1ba277dad9a090b0786a902b46941a281bbea40ce6cf7a3a96988adb4b119494d96daec4bf5368e40e49652f4ad6a64b87bb96d4ec0ec1181d543008c61a9b181166c5ab0d91e2b0ef46249b84af0f8fb0cdaea248cb4dfbd7b571270bfaf6f860210273e9688ce05ec8d46e32ad2bc444a6523f5de94adc10c5c9d73c82a2e7619ab38363d4e5faac6924f4c3a25f349f192693204eb3e1f4646e5f84512b3e92837b5f0da4bb0eb042073a0fe7fd20798d8e251f44236f7a47f2b768a68062d6ba56bb8ab2c12bf2ac247eb95e20dbb9e3c9908f7509a71781cfaa38e25d0c4d41b286676f87c62453e72e5839451c945d03b545fa7bcb1449aac60876c1efcdb2630e86b6a6b95442618766285194d09223b705dd1e09c5996e644a9bedefa2185d14035a79bb9fde91f77fcee18ce2ee1eb61a399c5149ed82465c7fa531efd8844e1f6430fa02f74a3deae9e7b71c0ff12e85393bca736f66969faa957a2962e2238b27b9f693435921aa6c65ca56da4220d5fa355b075a14cdbe58970cb936d53c7822e7f60a758c4d5f7e3e09ec16f54e268a9463e6a1226a788f275f482de0ea1b94344caac8b95ed304791379d4cee3105459b443456712c26d20de91a54630f34e810b5a8b70592f79de61508622e3c373493081cba21d88053d1d174f2172be2ecdf4066d7ec8e3fc0993cba14772580917e555750f3be3780cfe78174c5d585c9d96f336111f29316bc9e860e22b4004323dab8ba65fe549b318a6ec9f0095aff05e678b85f7aeefd50f0d55d6990b7c8eb42a31ce6221fce4f2aff01019771fa1b8cd60b607b91ce1476983096c6ce007b1ff49bab995bab6fa3186a97492edd8ab7410321af7cf0b8b526aeaee8f20ea5b8f69133e25282b880bc84dcdded139e8829d45afbcfa4bf5f8d4311cfbc2c071727421cb8b64b9e8132143e032fc67690adc1bd0d2fd2d98fd7def77848c91c8a6900d652f8f0e85fd6c4f7282f50a2498c691dc88900658476821d3949a29c25de037ac24c921706e68f69d40a8fc37c26a3dfe4d1a3a52616d04bd3aba31af98ed9272c254cce3a2f52a7924c72538104f37dff37f8eb86f1b07b55a39e87fcb59a2bba4726c2230431c59047ac23c8450b1412849c21130b477c4206a5cccf45a62bfb8edf6f5e70c17e5aadc7e4fe26ab480136267420ffd3cb1db09a3c05c810b48676dff22d2c2f842086750839727893c19ac4ff5be2e9acfdac57c0e346b4db182bc7fec9f42e7d964fda1389e6ed188bbc220f7f4cbaf3748f8efe39229db6dfc832b9e30436b6fc6dda32ea2724d3ad2f664d6fc110f954dbd327ce355be7723e3770bec8ed2596aa98364665e2997e613452d21840d8a211d6c4749c4d7606a019f1939d0a9ba87c5e056999d1c10d0b4be15160e813b5b31da276243873e48a5145363e0246c2ce1e167f08831f30a28cf0a76ed9b0c148363767b82560889fb00c43d5cbd663221c031fe09f77bad730e156c58c105772fa9b8008459f36532140bbb9654d4974dc9eb4a46a34ba041de533e8bad7f08155e482f050376cf0d59df45dc565fa7352d6a9db408cfca9348ed845f97ee2c8f29d44b947a9acd77dcb9882c7b7efc4f69a9b363533b4f9fbfc341a823616d6294af79fbbdd10086c970b3cc091b06d91d5741a17f2f63f2fa12a147b0496a0f1217d95a53306a5cbd82c8e774156ee50af55ae98c77d3e53ab38dddf39e84d11b1a772ff9348d235a9e3e78b6bda59975c223942aaa6c9a49345b7f732dc81127be670def9892ffea3d04440308766037a2973a61643ebad2490183652e0325ab5e5b06849a8297d1b8c778200e0026e6ca94e0f025c3a52f0d8b933d3fd112b40d6195d0e4fb1202f5f03b4a0db28851cd18582fae0250bfe5f4f551e9591b4a4b1d52ab336d5c48493ae49b958ee0f2194dd787d25fc62a09167856f49674227c4b7e22e4e9fb1d2cb5e114de9776b98889f964cf8f94b90be013fd52d394831469bf220273a4a7f33c4878dda12e9b28c965f962bd96d43d13608d9bf5d5417b59b01ab37843212ba6e22400b821c3c1140c65e07abb0987136d0234d144944f8e6801494ace14ecb925daa0130b823d549f2e5b79f2ed6f902761886705b4c6bbd6bec58969d9d96313726b8b8d61c266bf07daf1285f34f40c5282c49f116e75350091f140afe473df900470a64b946140449d495dbb8ec0265fd00f98406b1641501583026dd0d6ec9b057ad3cb40db1f645201277fcb5a060611d38d16436b38a9992b0cf8b8a58fd6c808c851259c5052a47604ecba1be9bb03fb58c435409ce0b370dae89e24e041e74ba995d91468a7aabfcf1d9ed6a2d201e447be19f32ce3b5b1ebe78aa3d6c5caf9a3183b33f48cc5ebac7e81c2a109454ab88109583ef6cb2552a5cd6888e5111606c4f631ab257e291102838b15c2062aa22a192a20302adccafd62547d0e54b774a4415f6a4027d9f5f118bc0568158e921d6a23e27411e558c9bc438785a6b70f18fa352f476f38b9cbec9a6962575e6da4b2e21a3f6360f079d8a42487a44cf6166ecfef3ef52b987c71edbc75ebe43d06662d41a5fe0f4518552a48cb5c011fe43972527ec85eb3d77b4d5667bc7a1d51afa84461c397ef2e077367e075a8f0c8693a75d4158d24bf7d1ac4e1d1136b1cadc912081bb5876347cdf6f889b3150fad4a05eda7b723714893e42acda090a526f7187131d74435c58d0f5e6bf69c7b262ab0e191caa7fe00850c02a1d6360642d2e1ff1bf4235c4d0b972106146b85927622b723755e87138e7cf791864e8e79e403ca9cc8d1646ad05f714a3cf10e9f262254460a71eab81eda69e661437d0721c948215d1d6a0e65f3229d205032c023a9891c5f2e3722bad2341fb609cda02aec477b15fc9ac51dcf428072b595552991a9c3e703b745fa00efe86862f165e3d4b7c108f00cd8be8400baa7590ea513179817bd5e6a290a7be62b9450682e8a7ebaff49ad130108e065bc38d4f3386ba07992587116b740ebdea5552de935f6737ca2d66c174b0c3417d2b3b469f401c51cb60f7078dabccde2e4b84f972b8bffa505fec329f47b6cbf0aaff77af80ef6f97171a69ec4f42ee53ae025794b0d84a7764fecf99362d97e1015e0908c0eb4ca2e844aa359da57164935458cb19d37efebcf033a836d14f65811c043184c5d713e59931a0540c23346b76376eccc71c0b68d27be2e27d3181da0f5eafd2d6f3f164f60e4f6c83b9c98839083fbd553910fa3a47198e7695e589911454856b2d1fdae2d61eb9a428100af03bdab1feb34771a725cb812b88d9df7d3d7699775a511584346568d1348a1b57b3b51bd339655402866c092db9a3cbd896fee251a25178ee6fda62c8d802ade6d7a023456644e283c6e347ddcea1a614cf323a724258a668d3b5b05b981adda85c2e843a0250c67d31f3929bea43f820e3b85e6c31b4dcacf817671c9acb2492e9192d97ca2c95e7e1ad434af3ce961da5da508f441cbdbc69c8937d6f6e0b893165733ed2211797b5a18580319a6029cf8f4172884e842475432ac34e7760c876562880af63493ba405974be51b6c20f7ee686f61f4d7a7070c788780833aa004d8a024740c7727ffb0c9d2a5565448b2da29dd3a1e08500d6efa151109e97fd5a9629f71d580356faed9e39a085d54de4fbfeaeea62c194d975b42f1c75a3635844af52b8fff9209828d3010d6820e6412bc892bce963df0c390e6ed570e9edcf6220f037efc1c7123f5360a9bf9283f6590d3649fb6a6e3a9e19547e5cfc47491d04363dd43f7cb23d64f09d996e3aa575842595d9f0235b02709c983745476cbe9fa7c3d3a702dcf54ce8736d3c1553fb0117794595fb1dc4fa9d245b0605fe4739fda45cd677808cab4a0d01721f09863fd4132f278a9ab4fe853e8c75b50458f157ef73a83198b5026662604eba99c422809201330b79c5258559e57c72420e5d6cf1743f3bd46a775a63c6c4da537b0a68bf6bd0b08e583600c53b7388da7d4d88427d286935d6ecd7988a02f169fd7e2228e5a0a3ae2459cd1ed7d09d14029897d1b2ff0f9c5c438090a571869d726a6f69d3818aeef8eb39b7e4a1b0c36edf84213984ae0e8c905450db41b0170dc0f68525abbbf84e3d7559cc9bc585bafee31902a691e1e6958f1de36092e8ed627b7cfca8d43a3e36c4ac5dc03901e37d794c01591491fcf98be11ba9fc5a086ae1e6fc346280c2386fab74dba0d01b7bdb3df8a9512b92b6486ef34a256074e65be22ed81b03815ab3422054d0ee51c24ec6a6127132d4d905cce0e36b7dcf82ccb4ae5a58286e097dc9c79ab0b8ea726e9ffa490d1b71a5cd9ccb874286b58474a8b1f68fae5167eb095497d48d245bf078478057c2daae7ac7fbbe557046fe2440cbd858a97f9e29821a98780dc1967fa1d8b1a4164086f8ba8e4b52b2387ea186dd086c057c1eb3ad90dc6e80ae162f8838b5d6bdc091b281b3c484d41dbe34ee83302bd9343295d637eebd965f0492bfc26b9e149fd4870e0d273ea010a0217cbeff510593bed90c906b17b10910209f4a1a5a0ab03d8181e147f969233b0b9577072c15595b51ea0848435e47bcb11b6c2c99eff4b24fdada6972c047f810b835cde5aa795c126a37804e38399e57efafb1bbbf88d7432a98900d4b73d797037fcc041a56cdadb31aceaa01da5acd514576871f4312845eba6ba5de1144393fbca91dc74a52cf1f0034bd5b5b79e68f436b5775ab7dc33ad91bcf1789812731b0b9d9de63d8daea9d4e04b90ee227b7f0cc70b7cc0f86accf1907b6fffb41589b51979a3d9b08bf06f9f739d6f81c4246767b6958f19639a99c6cbd7550597c4cc36da5145e8714d7fea69a9d61d2d981c0df4307d08db6b246c46e966e42079f725e533ae3e399a10dfc24ecfbb363538d6a232484a93dd31e5e79228acd45a326cbd6df867bd2a3c54b4a655fa40dd3dd2d244b3387e1e0cf708607e5351a7795b03e9732adb2a18bfe28a6dc573800dc1ac327679c83cd96b71bcec28cb5f1773f69f4e333fc3c6a884bf4bd50ea2b56d5752f171d828554ea762f77f37d129b00b5346c33063e021cf1a9c4dc808a4bec68521c86961a9e46bab63395e20a812c326c87456a23e42d10a34a19cc461acdadf695eb6e175d102178b428adb8ecdd7c400a86af25921ffa0aa2932f217702dcf1cf843ecc0083a47e7638ffc104389d273290b5aa44d7f1aa23b35049731aff968cc664b66d0ef61265429c7717e0bff8fe310e3d35eedb0da36c170558fc206254ef1f3cba4c40b67e7507e72f0bac3a45e00565771e435960469d45b7aeffa21d02b70fb8c30ecaadc17659c1c873e843b26b4b7fa392fbf24b78f6e11c763c850aa34b9ccf3478e3eb4d621d1157fd5a70531ecc428eb8835c6c3b78ca7376bbb74ff2722120a3e54610603612613dc37b635ef46af2166aeb879b466a35981c516517608eeba48064d0583120b60ad5e76755c3f05555dc1fa816d2f95dc19df42dc2202e563a13a270969f4fd58be847aeaacc71f7055efbd6f4162d376de29fb9c9307f636803b2447d3b01f58f1c9ce88072b207f183364c8c7f4afd991c8d6526c3e30e6bcd7b5afe6be32fea0f05a19a70fd5c9b4165745c5de23f440ca7b232b082b033ca9fe27b0858a7d2e3ccc5fb0eaf304e9bc8157c1ac6cbb485211e5f6496194cc2eecddc7582573f57078763e2a0d8a5db700337cc376bcbe5a3fb66eca3c96182c88fe17d01e6b67c1d1f732db5cb817505b1031753db86be91719f31a63014b3ef0b9945365ec6782505fdf46d0f06a24faa55c42f88decf51ecef2ff7dee15f030ecf39913f02f4c9de9397fe67c2c0ea3b3a54d9cfbf0860c86785707f50b4e4fb41e57aa23f1833ce3e02f4773df34b16555752ac0bab4066f8e5cb6013ae7991f353dc6a3ae0a4b9d26877af06e33c4d2315ccb23f09c1f7ba5a46888885ebdcc1b1d67df51f7d3254797deab2ba8fd6993bab4407d3e6ca0507f55a61cbe70f8cef7988f92b6a3af34969e895a49329d65df0d7d1e2f68e92c20585712a8681c70eae8b88f62acc53de72149ba1c85cb6e77210d47b39f04c9df2529da2d3342a0378cc64e42e8659504d00219fff11c93338dd32318b6042d4f9bf8c895b1026bf2be624018a481e380e4d64547c5304f08a6e098ee27a171d5fd983e0416ce26ee5202a924609dd17be0ae8e7bf7836a2bb6a154f71c1f007944277db8e9f6664d0a060c9a7f4fe86ad4f3a9ece57f897ef948bcc26d129a003efd526f0dff43224d3d7190c3519cd0739987eb00edcd6a4d60f0742e14f211748beddbe280c596fb28db94c976cd6fbdffc70d3f150005ed7e0ff1fae6a1429ea97ab400164c34c3717c8a53c4613c01a0dd6a787b030631cc4e3f952b8bb57123c6a80d76de2db94fb9c358fcb1eb8003861b879281e980880ab40f81cefca20d27ab43cc682186c869ce8383d27bfbfa4c6491d53b30c86d945253572c2d470f4cd2ad914389708c4d166038e73a4e99d3e57fb046585ef71e82636b2747902153e387227bf180e25e7b2ccf830d0578d2965f5a5b72ba7e024a7b5230f7a8459ec6815626efa24063cea0fa3d2fc494775cb00ea1974bf6c5ddfc17397e779819f7a9d2525d7adcef2f4b5f6dfbd69f3c410f2f9dfc5c199c5ff1724ca0251ffe19eebdc7a310e9577d98ca00aaa4c189cca5c716628c9a6ecc85fe740eaca1cf10e7dc65ac627de1308df1ee472ab68c399f2e778745b797cbb4dea61cd2353d069d756babb2dabebda7666bc86e2a312bb1be49b2bb00759631b15e9ebee70ebfd99658b80f165e2538a62d706e51420e890fe227a207ee571d6d0eb6855fff09a7095aa0b9eff6d3cc8b0df09c887214fc704dfc1c7814c3da07b24a75c413dd407ee44eda4558e0abc18a36c5c2d0fbc6412f9d80a51b392448ef6a21a062de289626a1b6cd23fced4a09e7d03765640067c3e5701d88c24b94221f0bdee9c2ff461623b3067d52680526735f378a21b937c833238e8ef01557560ffde99d75eae1f9698863d859dae665c8ae5383d69154bf8300a0de70a3bd4f77ac40ea80e377b698f8a79db5979e399fa62c2f6908a2f289dc3c19b88ecaf9c06a0ab649caa1171167b7596a4de99fcb25e681446a47b6c7eb9b4d8e4b864dc64e9fda271f1e7144787a4aaae63fd9e5447a11bb0862b862ad3d510ff45e413c0703a6e92a7772c023960f1ee95ab62c5ee9745872330cf9261677366104b34c14fa08c739e15e3fa9eaa3ad4d472a69df8ae932627ae194857e1b6c2bcbd2c476c97f73a20dfdbe0164d9243c4ba36af7dfddb680b7747d7280cf22076e9e6f9f89372c54ea3aa355313ad0e1677df30a7e51fad3690aa2210e9e1a995096ed0ac40c956dcb3ad15afada4138caa39486a6f085f3c0660957a316c160e31e4830c8ecadf4503f5bfdc8285a237a94f9db8fde745f32568cd98cae9a99fef9d0c827e7152e713ec3879fcb6b0034831c13b0fbf41b705d9b1061ab2c39bad7062edda2286258e4745dcc9b5329cd4c52ab375b3d97986f3d7ff16e64592dd70a933abb1d1149833f268f4fb292ab31000955e2b8c9bcc826843 请输入密码查看详细内容","link":"/2022/03/12/Other/question/"},{"title":"web常见的攻击方式","text":"XSS (Cross Site Scripting) 跨站脚本攻击 CSRF（Cross-site request forgery）跨站请求伪造 SQL注入攻击 参考web常见的攻击方式","link":"/2024/02/27/Safe/safe-web/"},{"title":"Vue组件通信的8种方式","text":"props 和 $emit $children 和 $parent ref provide 和 inject eventBus $attrs 和 $listeners Vuex localStorage 和 sessionStorage 父子关系的组件数据传递选择 props 与 $emit 进行传递，也可选择 ref 兄弟关系的组件数据传递可选择 $bus，其次可以选择 $parent 进行传递 祖先与后代组件数据传递可选择 attrs 与 listeners 或者 Provide 与 Inject 复杂关系的组件数据传递可以通过 vuex 存放共享的变量参考 Vue组件通信 Vue通信方式","link":"/2022/03/12/Vue/vue-communication/"},{"title":"TS 对象类型","text":"对象类型 对象类型在 JavaScript 中，最基本的将数据成组和分发的方式就是通过对象。在 TypeScript 中，我们通过对象类型 （object types） 来描述对象。对象类型可以是匿名的： 123function greet(person: { name: string; age: number }) { return &quot;Hello &quot; + person.name;} 也可以使用接口进行定义： 12345678interface Person = { name: string; age: number;}function greet(person: Person) { return &quot;Hello &quot; + person.name;} 或者通过类型别名： 1234567type Person = { name: string; age: number}function greet(person: Person) { return &quot;Hello &quot; + person.name;} 属性修饰符（Property Modifiers）可选属性对象类型中的每个属性可以说明它的类型、属性是否可选、属性是否只读等信息。 123456789interface PaintOptions { shape: Shape; xPos?: number; // 可选属性 yPos?: number;} function paintShape(opts: PaintOptions) { // ...} 在这个例子中，xPos 和 yPos 就是可选属性。因为他们是可选的，所以上面所有的调用方式都是合法的。我们也可以尝试读取这些属性，但如果我们是在 strictNullChecks 模式下 (tsconfig文件中，strictNullChecks默认为false) ，TypeScript 会提示我们，属性值可能是 undefined。 1234567891011121314151617181920interface PaintOptions { shape: Shape; xPos?: number; // 可选属性 yPos?: number;}function paintShape(opts: PaintOptions) { let xPos = opts.xPos; // (property) PaintOptions.xPos?: number | undefined let yPos = opts.yPos; // (property) PaintOptions.yPos?: number | undefined}// ===&gt; 针对 undefined 特殊处理为：function paintShape(opts: PaintOptions) { let xPos = opts.xPos === undefined ? 0 : opts.xPos; // let xPos: number let yPos = opts.yPos === undefined ? 0 : opts.yPos; // let yPos: number} 这种判断在 JavaScript 中很常见，以至于提供了专门的语法糖： 12345function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) { console.log(&quot;x coordinate at&quot;, xPos); // (parameter) xPos: number console.log(&quot;y coordinate at&quot;, yPos); // (parameter) yPos: number // ...} readonly 属性在 TypeScript 中，属性可以被标记为 readonly，这不会改变任何运行时的行为，但在类型检查的时候，一个标记为 readonly的属性是不能被写入的。 12345678910interface SomeType { readonly prop: string;}function doSomething(obj: SomeType) { // We can read from 'obj.prop'. console.log(`prop has the value '${obj.prop}'.`); // But we can't re-assign it. obj.prop = &quot;hello&quot;; // Cannot assign to 'prop' because it is a read-only property.} readonly 仅仅表明属性本身是不能被重新写入的，属性内的值可以重新写入： 1234567891011121314151617interface Home { readonly resident: { name: string; age: number };}function visitForBirthday(home: Home) { // We can read and update properties from 'home.resident'. console.log(`Happy birthday ${home.resident.name}!`); home.resident.age++;} function evict(home: Home) { // But we can't write to the 'resident' property itself on a 'Home'. home.resident = { // Cannot assign to 'resident' because it is a read-only property. name: &quot;Victor the Evictor&quot;, age: 42, };} 索引签名有的时候，你不能提前知道一个类型里的所有属性的名字，但是你知道这些值的特征。 12345interface StringArray { [index: number]: string;} const myArray: StringArray = getStringArray();const secondItem = myArray[1]; // const secondItem: string 这样，我们就有了一个具有索引签名的接口 StringArray，这个索引签名表示当一个 StringArray 类型的值使用 number 类型的值进行索引的时候，会返回一个 string 类型的值。 尽管字符串索引用来描述字典模式（dictionary pattern）非常的有效，但也会强制要求所有的属性要匹配索引签名的返回类型。这是因为一个声明类似于 obj.property 的字符串索引，跟 obj[&quot;property&quot;]是一样的。在下面的例子中，name 的类型并不匹配字符串索引的类型，所以类型检查器会给出报错： 12345678910111213interface NumberDictionary { [index: string]: number; length: number; // ok name: string; // Property 'name' of type 'string' is not assignable to 'string' index type 'number'.}// ====&gt; 修改为联合类型：interface NumberOrStringDictionary { [index: string]: number | string; length: number; // ok, length is a number name: string; // ok, name is a string} 最后，你也可以设置索引签名为 readonly： 1234567interface ReadonlyStringArray { readonly [index: number]: string;}let myArray: ReadonlyStringArray = getReadOnlyStringArray();myArray[2] = &quot;Mallory&quot;;// 因为是readonly，所以无法修改值// Index signature in type 'ReadonlyStringArray' only permits reading. 属性继承（Extending Types）对接口使用 extends 关键字允许我们有效的从其他声明过的类型中拷贝成员，并且随意添加新成员。接口也可以继承多个类型： 1234567891011interface Colorful { color: string;}interface Circle { radius: number;}interface ColorfulCircle extends Colorful, Circle {}const cc: ColorfulCircle = { color: &quot;red&quot;, radius: 42,}; 交叉类型（Intersection Types）TypeScript 也提供了名为交叉类型（Intersection types）的方法，用于合并已经存在的对象类型。交叉类型的定义需要用到 &amp; 操作符： 1234567interface Colorful { color: string;}interface Circle { radius: number;}type ColorfulCircle = Colorful &amp; Circle; 这里，我们连结 Colorful 和 Circle 产生了一个新的类型，新类型拥有 Colorful 和 Circle 的所有成员。 12345678910function draw(circle: Colorful &amp; Circle) { console.log(`Color was ${circle.color}`); console.log(`Radius was ${circle.radius}`);}// okaydraw({ color: &quot;blue&quot;, radius: 42 });// oopsdraw({ color: &quot;red&quot;, raidus: 42 });// Argument of type '{ color: string; raidus: number; }' is not assignable to parameter of type 'Colorful &amp; Circle'.// Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful &amp; Circle'. Did you mean to write 'radius'? 这两种方式在合并类型上看起来很相似，但实际上还是有很大的不同。最原则性的不同就是在于冲突怎么处理，这也是你决定选择那种方式的主要原因。 12345678910111213141516171819interface Colorful { color: string;}interface ColorfulSub extends Colorful { color: number}// Interface 'ColorfulSub' incorrectly extends interface 'Colorful'.// Types of property 'color' are incompatible.// Type 'number' is not assignable to type 'string'.// 以上使用继承的方式，如果重写类型会导致编译错误，但交叉类型不会：interface Colorful { color: string;}type ColorfulSub = Colorful &amp; { color: number}// 虽然不会报错，那 color 属性的类型是什么呢，答案是 never，取得是 string 和 number 的交集。 泛型对象类型（Generic Object Types）把 Box 想象成一个实际类型的模板，Type 就是一个占位符，可以被替代为具体的类型。当 TypeScript 看到 Box&lt;string&gt;，它就会替换为 Box&lt;Type&gt; 的 Type 为 string ，最后的结果就会变成 { contents: string }。换句话说，Box&lt;string&gt; 和 StringBox 是一样的。 1234567891011121314interface Box&lt;Type&gt; { contents: Type;}interface StringBox { contents: string;} let boxA: Box&lt;string&gt; = { contents: &quot;hello&quot; };boxA.contents; // (property) Box&lt;string&gt;.contents: string let boxB: StringBox = { contents: &quot;world&quot; };boxB.contents; // (property) StringBox.contents: string 不过现在的 Box 是可重复使用的，如果我们需要一个新的类型，我们完全不需要再重新声明一个类型。 12345678910111213interface Box&lt;Type&gt; { contents: Type;}interface Apple { a: string // ....}// Same as '{ contents: Apple }'.type AppleBox = Box&lt;Apple&gt;;let new1 : AppleBox = { contents: {a: '1'}} 这也意味着我们可以利用泛型函数避免使用函数重载: 123function setContents&lt;Type&gt;(box: Box&lt;Type&gt;, newContents: Type) { box.contents = newContents;} 类型别名不同于接口，可以描述的不止是对象类型，所以我们也可以用类型别名写一些其他种类的的泛型帮助类型: 1234567891011type OrNull&lt;Type&gt; = Type | null;type OneOrMany&lt;Type&gt; = Type | Type[]; type OneOrManyOrNull&lt;Type&gt; = OrNull&lt;OneOrMany&lt;Type&gt;&gt;; type OneOrManyOrNull&lt;Type&gt; = OneOrMany&lt;Type&gt; | null type OneOrManyOrNullStrings = OneOrManyOrNull&lt;string&gt;; type OneOrManyOrNullStrings = OneOrMany&lt;string&gt; | null Array 类型我们之前讲过 Array 类型，当我们这样写类型 number[] 或者 string[] 的时候，其实它们只是 Array&lt;number&gt; 和 Array&lt;string&gt; 的简写形式而已。 1234567function doSomething(value: Array&lt;string&gt;) { // ...}let myArray: string[] = [&quot;hello&quot;, &quot;world&quot;];// either of these work!doSomething(myArray);doSomething(new Array(&quot;hello&quot;, &quot;world&quot;)); 类似于上面的 Box 类型，Array 本身就是一个泛型： 123456789101112131415161718interface Array&lt;Type&gt; { /** * Gets or sets the length of the array. */ length: number; /** * Removes the last element from an array and returns it. */ pop(): Type | undefined; /** * Appends new elements to an array, and returns the new length of the array. */ push(...items: Type[]): number; // ...} ReadonlyArray 类型ReadonlyArray 主要是用来做意图声明。当我们看到一个函数返回 ReadonlyArray，就是在告诉我们不能去更改其中的内容，当我们看到一个函数支持传入 ReadonlyArray ，这是在告诉我们我们可以放心的传入数组到函数中，而不用担心会改变数组的内容。 123456789function doStuff(values: ReadonlyArray&lt;string&gt;) { // We can read from 'values'... const copy = values.slice(); console.log(`The first value is ${values[0]}`); // ...but we can't mutate 'values'. values.push(&quot;hello!&quot;); // Property 'push' does not exist on type 'readonly string[]'.} TypeScript 也针对 ReadonlyArray&lt;Type&gt; 提供了更简短的写法 readonly Type[] : 123456789function doStuff(values: readonly string[]) { // We can read from 'values'... const copy = values.slice(); console.log(`The first value is ${values[0]}`); // ...but we can't mutate 'values'. values.push(&quot;hello!&quot;); // Property 'push' does not exist on type 'readonly string[]'.} 元组类型元组类型是另外一种 Array 类型，当你明确知道数组包含多少个元素，并且每个位置元素的类型都明确知道的时候，就适合使用元组类型。 1type StringNumberPair = [string, number]; 如果要获取元素数量之外的元素，TypeScript 会提示错误： 123456function doSomething(pair: [string, number]) { // ... const c = pair[2]; // Tuple type '[string, number]' of length '2' has no element at index '2'.} 我们也可以使用 JavaScript 的数组解构语法解构元组： 12345function doSomething(stringHash: [string, number]) { const [inputString, hash] = stringHash; console.log(inputString); // const inputString: string console.log(hash); // const hash: number} 可选元素和剩余元素的存在，使得 TypeScript 可以在参数列表里使用元组，就像这样： 12345678910function readButtonInput(...args: [string, number, ...boolean[]]) { const [name, version, ...input] = args; // ...}// =====&gt; 基本等同于：function readButtonInput(name: string, version: number, ...input: boolean[]) { // ...} readonly 元组类型这样 TypeScript 就不会允许写入readonly 元组的任何属性： 1234function doSomething(pair: readonly [string, number]) { pair[0] = &quot;hello!&quot;; // Cannot assign to '0' because it is a read-only property.} 在大部分的代码中，元组只是被创建，使用完后也不会被修改，所以尽可能的将元组设置为 readonly 是一个好习惯。 如果我们给一个数组字面量 const 断言，也会被推断为 readonly 元组类型。 1234567let point = [3, 4] as const;function distanceFromOrigin([x, y]: [number, number]) { return Math.sqrt(x ** 2 + y ** 2); // 5}distanceFromOrigin(point);// Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.// The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'. 尽管 distanceFromOrigin 并没有更改传入的元素，但函数希望传入一个可变元组。因为 point 的类型被推断为 readonly [3, 4]，它跟 [number number] 并不兼容，所以 TypeScript 给了一个报错。 参考 TS 中文文档","link":"/2024/03/21/TypeScript/ts-object-type/"},{"title":"vue-question","text":"对 nextTick 的理解 对 mixin 的理解 对 slot 的理解 对 Observable 的理解 vue中key的原理 vue权限管理 render new Vue bus vue2 与 vue3 的区别 nextTick 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新 $nextTick() 会返回一个 Promise 对象，可以是用async/await完成相同作用的事情 1234this.message = '修改后的值'console.log(this.$el.textContent) // =&gt; '原始的值'await this.$nextTick()console.log(this.$el.textContent) // =&gt; '修改后的值' 参考说说你对nextTick的理解？ mixin mixin（混入），提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。 本质其实就是一个js对象，它可以包含我们组件中任意功能选项，如data、components、methods 、created、computed等等。我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins 对象时所有 mixins 对象的选项都将被混入该组件本身的选项中来。 注意事项：当组件存在与mixin对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖mixin的选项，但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行mixin的钩子，再执行组件的钩子 slot 默认插槽 具名插槽 作用域插槽 默认插槽1234567891011// 子组件&lt;template&gt; &lt;slot&gt; &lt;p&gt;插槽后备的内容&lt;/p&gt; &lt;/slot&gt;&lt;/template&gt;// 父组件&lt;Child&gt; &lt;div&gt;默认插槽&lt;/div&gt; &lt;/Child&gt; 具名插槽123456789101112// 子组件&lt;template&gt; &lt;slot&gt;插槽后备的内容&lt;/slot&gt; &lt;slot name=&quot;content&quot;&gt;插槽后备的内容&lt;/slot&gt;&lt;/template&gt;// 父组件&lt;child&gt; &lt;template v-slot:default&gt;具名插槽&lt;/template&gt; &lt;!-- 具名插槽⽤插槽名做参数 --&gt; &lt;template v-slot:content&gt;内容...&lt;/template&gt;&lt;/child&gt; 作用域插槽1234567891011121314151617// 子组件&lt;template&gt; &lt;slot name=&quot;footer&quot; testProps=&quot;子组件的值&quot;&gt; &lt;h3&gt;没传footer插槽&lt;/h3&gt; &lt;/slot&gt;&lt;/template&gt;// 父组件&lt;child&gt; &lt;!-- 把v-slot的值指定为作⽤域上下⽂对象 --&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; 来⾃⼦组件数据：{{slotProps.testProps}} &lt;/template&gt; &lt;template #default=&quot;slotProps&quot;&gt; 来⾃⼦组件数据：{{slotProps.testProps}} &lt;/template&gt;&lt;/child&gt; 小结 v-slot属性只能在 template 上使用，但在只有默认插槽时可以在组件标签上使用 默认插槽名为default，可以省略default直接写v-slot 缩写为#时不能不写参数，写成#default 可以通过解构获取v-slot={user}，还可以重命名v-slot=&quot;{user: newName}&quot;和定义默认值v-slot=&quot;{user = '默认值'}&quot; Observable Vue.observable 让一个对象变成响应式数据。Vue 内部会用它来处理 data 函数返回的对象 返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器 123Vue.observable({ count : 1})// 其作用等同于new vue({ count : 1}) 实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// store.jsimport Vue from &quot;vue&quot;export const state = Vue.observable({ count: 0})export const mutations = { add(payload) { if (payload &gt; 0) { state.count = payload } }, reduce(payload) { if (payload &gt; 0) { state.count = payload } }}// page.vue&lt;template&gt; &lt;div class=&quot;observable&quot;&gt; &lt;h4&gt;Observable1&lt;/h4&gt; &lt;div class=&quot;observable-layout&quot;&gt; &lt;button @click=&quot;add&quot;&gt;add&lt;/button&gt; &lt;h4&gt;{{ count }}&lt;/h4&gt; &lt;button @click=&quot;reduce&quot;&gt;reduce&lt;/button&gt; &lt;/div&gt; &lt;div&gt;&lt;button @click=&quot;go&quot;&gt;go to Observable2&lt;/button&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { state } from &quot;./store.js&quot;;export default { data() { return {}; }, computed: { count() { return state.count; }, }, methods: { add() { state.count++; }, reduce() { state.count--; }, go() { this.$router.push({ name: &quot;About&quot; }); }, },};&lt;/script&gt; 在 Vue 2.x 中，被传入的对象会直接被 Vue.observable 变更，它和被返回的对象是同一个对象在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的 使用场景在非父子组件通信时，可以使用通常的bus或者使用vuex，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。这时，observable就是一个很好的选择。 1234567891011121314151617// 创建js文件// 引入vueimport Vue from 'vue// 创建state对象，使用observable让state对象可响应export let state = Vue.observable({ name: '张三', 'age': 38})// 创建对应的方法export let mutations = { changeName(name) { state.name = name }, setAge(age) { state.age = age }} 1234567891011121314151617181920212223242526// .vue文件中使用&lt;template&gt; &lt;div&gt; 姓名：{{ name }} 年龄：{{ age }} &lt;button @click=&quot;changeName('李四')&quot;&gt;改变姓名&lt;/button&gt; &lt;button @click=&quot;setAge(18)&quot;&gt;改变年龄&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;import { state, mutations } from '@/storeexport default { // 在计算属性中拿到值 computed: { name() { return state.name }, age() { return state.age } }, // 调用mutations里面的方法，更新数据 methods: { changeName: mutations.changeName, setAge: mutations.setAge }} vue中key的原理 key是给每一个 vnode 的唯一id，也是 diff 的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点 背后的逻辑当我们在使用v-for时，需要给单元加上key： 如果不用key，Vue会采用就地复地原则：最小化element的移动，并且会尝试尽最大程度在同适当的地方对相同类型的element，做patch或者reuse。 如果使用了key，Vue会根据keys的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed区别123456789101112131415161718&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;p v-for=&quot;item in items&quot; :key=&quot;item&quot;&gt;{{item}}&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;../../dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 创建实例 const app = new Vue({ el: '#demo', data: { items: ['a', 'b', 'c', 'd', 'e'] }, mounted () { setTimeout(() =&gt; { this.items.splice(2, 0, 'f') // }, 2000); }, }); &lt;/script&gt;&lt;/body&gt; 在不使用key的情况，vue会进行这样的操作： 比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较C，F，相同类型的节点，进行patch，数据不同，发生dom操作 比较D，C，相同类型的节点，进行patch，数据不同，发生dom操作 比较E，D，相同类型的节点，进行patch，数据不同，发生dom操作循环结束，将E插入到DOM中 一共发生了3次更新，1次插入操作 在使用key的情况：vue会进行这样的操作： 比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较C，F，不相同类型的节点 比较E、E，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较D、D，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较C、C，相同类型的节点，进行patch，但数据相同，不发生dom操作循环结束，将F插入到C之前 一共发生了0次更新，1次插入操作 通过上面两个小例子，可见设置key能够大大减少对页面的DOM操作，提高了diff效率 设置key值一定能提高diff效率吗？其实不然，官方文档明确表示： 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素 这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。 建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 vue权限管理 接口权限(返回401) 路由权限 菜单权限 按钮权限 renderrender: 对template的解析步骤大致分为以下几步： 将html文档片段解析成ast描述符 将ast描述符解析成字符串 生成render函数 生成render函数，挂载到vm上后，会再次调用mount方法 render的作用主要是生成vnode _update主要功能是调用patch，将vnode转换为真实DOM，并且更新到页面中 new Vuenew Vue 挂载发生的过程： new Vue的时候调用会调用_init方法 定义 $set、 $get 、$delete、$watch 等方法 定义 $on、$off、$emit、$off 等事件 定义 _update、$forceUpdate、$destroy生命周期 调用$mount进行页面的挂载 挂载的时候主要是通过mountComponent方法 定义updateComponent更新函数 执行render生成虚拟DOM _update将虚拟DOM生成真实DOM结构，并且渲染到页面中 Bus12345678910111213import Vue from 'vue'const Bus = new Vue()Vue.prototype.bus = new Vue();new Vue({ render: h =&gt; h(App) ...}).$mount('#app');/**通过把一个vue实例赋于Vue构造函数原型上的一个属性bus（当然起任何名称都是可以的）*而每个Vue实例都是有$emit和$on方法的*由于bus属性在Vue原型上，根据原型链查找规则，在页面中我们就可以通过 this.bus.$emit 和 *this.bus.$on来进行跨组件通信了*/ vue2 与 vue3的区别 打包体积更小 性能优化：Vue.js 3.0使用了 Proxy 替代 Object.defineProperty 实现响应式，并且使用了静态提升技术来提高渲染性能。新增了编译时优化，在编译时进行模板静态分析，并生成更高效的渲染函数。 Composition API：Composition API是一个全新的组件逻辑复用方式，可以更好地组合和复用组件的逻辑。 TypeScript支持：Vue.js 3.0完全支持TypeScript，在编写Vue应用程序时可以更方便地利用TS的类型检查和自动补全功能。 新的自定义渲染API：Vue.js 3.0的自定义渲染API允许开发者在细粒度上控制组件渲染行为，包括自定义渲染器、组件事件和生命周期等。 改进的Vue CLI：Vue.js 3.0使用了改进的Vue CLI，可以更加灵活地配置项目，同时支持Vue.js2.x项目升级到Vue.js 3.0。 移除一些API：Vue.js 3.0移除了一些不常用的API，如过渡相关API，部分修饰符，.sync等。 diff 算法 Proxy和Object.defineProperty的区别？Proxy 和 Object.defineProperty 都可以用来实现JavaScript对象的响应式，但是它们有一些区别： 实现方式：Proxy 是ES6新增的一种特性，使用了一种代理机制来实现响应式。而 Object.defineProperty 是在ES5中引入的，使用了getter和setter方法来实现。 作用对象：Proxy可以代理整个对象，包括对象的所有属性、数组的所有元素以及类似数组对象的所有元素。而Object.defineProperty只能代理对象上定义的属性。 监听属性：Proxy可以监听到新增属性和删除属性的操作，而Object.defineProperty只能监听到已经定义的属性的变化。 性能：由于Proxy是ES6新增特性，其内部实现采用了更加高效的算法，相对于Object.defineProperty来说在性能方面有一定的优势。 综上所述，虽然Object.defineProperty在Vue.js 2.x中用来实现响应式，但是在Vue.js 3.0中已经采用了Proxy来替代，这是因为Proxy相对于Object.defineProperty拥有更优异的性能和更强大的能力。 参考 Vue系列题集 Vue3与Vue2的优势及区别","link":"/2024/02/21/Vue/vue-question/"},{"title":"vue-router","text":"路由模式 路由守卫 路由模式vue-router 有 3 种路由模式：hash、history、abstract： hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器; history: 依赖 HTML5 History API 和服务器配置(常用); abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式; hash 模式例如：xxx.com/index.html/#/mine#号后面的，就是一个URL中关于hash的组成部分，不同路由对应的hash是不一样的，但是它们都是在访问同一个静态资源index.html。我们要做的，就是如何能够监听到URL中关于hash部分发生的变化，从而做出对应的改变。其实浏览器已经暴露给我们一个现成的方法hashchange，在hash改变的时候，触发该事件。有了监听事件，且改变hash页面并不刷新，这样我们就可以在监听事件的回调函数中，执行我们展示和隐藏不同UI显示的功能，从而实现前端路由。 history 模式history路由模式 的实现，是要归功于HTML5提供的一个 history 全局对象，可以将它理解为其中包含了关于我们访问网页（历史会话）的一些信息。同时它还暴露了一些有用的方法，比如： history: 于HTML5提供的一个history全局对象 window.history.go 可以跳转到浏览器会话历史中的指定的某一个记录页 window.history.forward 指向浏览器会话历史中的下一页，跟浏览器的前进按钮相同 window.history.back 返回浏览器会话历史中的上一页，跟浏览器的回退按钮功能相同 window.history.pushState 可以将给定的数据压入到浏览器会话历史栈中 window.history.replaceState 将当前的会话页面的url替换成指定的数据 而history路由的实现，主要就是依靠于pushState与replaceState实现的。 总结 hash的实现全部在前端，不需要后端服务器配合，兼容性好，主要是通过监听hashchange事件，处理前端业务逻辑 history的实现，需要服务器做以下简单的配置，通过监听pushState及replaceState事件，处理前端业务逻辑 详细：https://juejin.cn/post/7127143415879303204 路由守卫全局守卫：123456const router = createRouter({ ... })router.beforeEach((to, from) =&gt; { // ... // 返回 false 以取消导航 return false}) 路由独享守卫：12345678910const routes = [ { path: '/users/:id', component: UserDetails, beforeEnter: (to, from) =&gt; { // reject the navigation return false }, },] 组件内的守卫：123456789101112const UserDetails = { template: `...`, beforeRouteEnter(to, from) { // 在渲染该组件的对应路由被验证前调用 }, beforeRouteUpdate(to, from) { // 在当前路由改变，但是该组件被复用时调用 }, beforeRouteLeave(to, from) { // 在导航离开渲染该组件的对应路由时调用 },} vue-router中保护路由的方法叫做路由守卫，主要用来通过跳转或取消的方式守卫导航。 路由守卫有三个级别：全局、路由独享、组件级。影响范围由大到小，例如全局的router.beforeEach()，可以注册一个全局前置守卫，每次路由导航都会经过这个守卫，因此在其内部可以加入控制逻辑决定用户是否可以导航到目标路由；在路由注册的时候可以加入单路由独享的守卫，例如beforeEnter，守卫只在进入路由时触发，因此只会影响这个路由，控制更精确；我们还可以为路由组件添加守卫配置，例如beforeRouteEnter，会在渲染该组件的对应路由被验证前调用，控制的范围更精确了。 用户的任何导航行为都会走navigate方法，内部有个guards队列按顺序执行用户注册的守卫钩子函数，如果没有通过验证逻辑则会取消原有的导航。 全局前置/钩子：beforeEach、beforeResolve、afterEach 路由独享的守卫：beforeEnter 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave 参考 https://juejin.cn/post/7204844328111374391 https://juejin.cn/post/6844903918753808398#heading-18","link":"/2022/03/12/Vue/vue-router/"},{"title":"Vue2&#x2F;Vue3优秀开源框架模板","text":"Vue2/Vue3优秀开源框架模板 Vue2 花裤衩大佬的 vue-element-admin Vue3 vue-pure-admin 🔥 全面ESM+Vue3+Vite+Element-Plus+TypeScript编写的一款后台管理系统（兼容移动端） v3-admin-vite–pany ☀️ A vue3 admin template | vue3 admin/element plus admin/vite admin/vue3 template/vue3 后台/vue3 模板/vue3 后台管理系统 vue3-element-admin–有来技术 🔥基于 vue3 + vite5 + typescript + element-plus 构建的后台管理前端模板（配套后端源码），vue-element-admin 的 vue3 版本。 基于 Naive UI 的有 naive-ui-admin 和 soybean-admin 基于 Ant Design Vue 的有 vue-vben-admin 和 vue3-antd-admin fantastic-admin⭐⭐⭐⭐⭐ 一款开箱即用的 Vue 中后台管理系统框架，支持多款 UI 组件库，兼容PC、移动端。vue-admin, vue-element-admin, vue后台, 后台系统, 后台框架, 管理后台, 管理系统 问题vue3-element-admin 项目启动后，vscode命令行提交代码无报错，sourceTree提交报错，pre-commit 报错：.husky/pre-commit: line 8: npm: command not found方案：创建~/.huskyrc文件，根目录/Users/chenzhihao/.huskyrc，增加对nvm路径的支持：vi ~/.huskyrc查看npm路径：which npm/Users/chenzhihao/.nvm/versions/node/v14.18.1/bin/npmhuskyrc文件修改为：export PATH=/Users/chenzhihao/.nvm/versions/node/v18.17.0/bin:$PATH！！！注意对应的版本号 参考 https://ask.csdn.net/questions/1058267https://blog.csdn.net/wuyulkl/article/details/129803496https://blog.csdn.net/qq_39852145/article/details/123867238?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-5-123867238-blog-131233569.235%5Ev43%5Epc_blog_bottom_relevance_base4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-5-123867238-blog-131233569.235%5Ev43%5Epc_blog_bottom_relevance_base4&amp;utm_relevant_index=10 链接 ✨ 一个基于 Vue3 + TS + Element Plus + Pinia 的低成本后台管理模板","link":"/2024/03/06/Vue/vue/"},{"title":"Hexo Icarus -- 搭建赛博朋克风格个人博客","text":"基于 Hexo ，使用酷炫的 Icarus 主题✨ 且加入众多个性化配置，打造出的个人博客，效果惊艳，让我们从零开始，搭建一个专属自己的 赛博朋克 风格博客吧。 安装Node.js 安装Hexo 引入Icarus主题 个性化配置 创建GitHub个人仓库 绑定仓库 发布文章 Hexo及MarkDown语法 安装插件（评论，统计，分享等） 绑定个人域名 使用图床工具 安装Node.jsHexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包(或者使用 nvm 管理node版本)，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v : 1$ npm -v 安装Hexo初始化项目非常简单，按照 Hexo官网文档 操作即可:使用npm安装Hexo 123$ npm install -g hexo-cli# 更新版本# npm update hexo 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 标准的目录结构如下： 1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 使用 generate 命令生成静态文件，可简写如下： 1$ hexo g 使用 server 命令启动本地服务器查看页面效果，可简写如下： 1$ hexo s 此时，打开 localhost:4000, 一个默认的 landscape 主题的博客页面就出现了，如下： 引入Icarus主题引入主题也非常简单，我们查看 Icarus 主题 。更换主题主要有两种方式，一种是使用 npm 安装主题的方式，另一种是下载源码放到 theme 文件夹的方式。简单起见，我们先采用 npm 的方式： 1$ npm add hexo-theme-icarus 使用 hexo 命令修改主题为 Icarus: 1$ npm hexo config theme icarus 启动服务器，报错如下： 根据提示，添加依赖(提示缺少哪些就安装哪些)： 1$ npm add bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 再次尝试构建并启动，成功出现 Icarus 主题了： 在 _config.icarus.yml 文件中修改： 12# Icarus theme variant, can be &quot;default&quot; or &quot;cyberpunk&quot;$ variant: cyberpunk 再次构建启动，成功出现 赛博朋克 风格主题了： 刚才说到使用 Icarus 主题有两种方式， npm 包的方式虽然简便，但是如果想对 Icarus 主题有更深的配置就不太好弄了，尤其是过去 Icarus 一直都采用的是源码模式，很多 Issue 的解决方案都是修改源码的，而对应的 npm 包的方式则很少提及，所以我们也改为使用源码方式，方便后续配置。 首先删掉 hexo-theme-icarus 依赖，在 Icarus 仓库 下载代码，解压后拷贝到 theme 文件夹中。 个性化配置修改配置文件 _config.yml 和 _config.icarus.yml ，配置网站相关信息。 主要包括 logo、favicon、navbar 的 menu 和 links、footer、donates（赞助信息，注释掉没用的支付渠道）、widgets。 首页如果文章过长，用户向下滚动时就只会看到一篇文章，如果只想让用户看一部分内容怎么办呢？非常简单，在 md 文件中添加 &lt;!– more –&gt; 即可，添加完之后，就会出现“阅读更多”的按钮，首页就能看到多篇文章了。 目前文章页仍然和首页一样，是三栏布局，为了有效利用空间，希望文章页能够两栏布局。此时我们需要在 Icarus 源码文件夹添加 _config.post.yml 文件，并配置成两栏布局： 123456789101112widgets: # Profile widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: toc # Whether to show the index of each heading index: true # Whether to collapse sub-headings when they are out-of-view collapsed: false # Maximum level of headings to show (1-6) depth: 3 看看效果(头像及动态背景后面添加)： 创建GitHub个人仓库登录到 全球最大同性交友网站✨(GitHub),如果没有GitHub帐号，使用你的邮箱注册GitHub帐号(此处不赘述可参考: 廖雪峰老师Git教程)。点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.github.io 这个用户名使用你的GitHub帐号名称代替，这是固定写法，如图： 安装成功后，将你的Git与GitHub帐号绑定，同参考 廖雪峰老师Git教程 。 绑定仓库在 _config.yml 中配置你的 GitHub Pages 对应的仓库地址: 1234deploy: type: git repo: https://github.com/xx/xx.github.io branch: master 其中： type 对应部署的服务器类型，我们这里填写git就可以 repo 对应仓库地址，也就是仓库克隆的地址 branch 不写默认是master，通常我们写成master就可以 如图： 以上配置完成后保存 然后回到终端执行 npm install hexo-deployer-git –save 安装插件，将写好的文章部署到github服务器上并让别人浏览到。安装完成后在终端中依次执行如下代码(为了简单后续统称为三步)： hexo clean 清理缓存，整个public文件删除，简写为 hexo c hexo generate 进行渲染，将source中的文件按照某种规则方式渲染成静态的页面文件放到public中，简写为 hexo g hexo server 部署到本地，简写为 hexo s hexo deploy 将public中文件部署到git服务器，简写为 hexo d 发布文章创建一个自己的文章，建立好的文章在 source/_posts 中： 1hexo new post “文章名字” 注意头部配置文件相关信息，在新版 Icarus 中头图需要额外配置 cover 选项，如下： 1234567891011---title: &quot;hello&quot; # 标题date: 2021/03/08 # 日期categories: # 分类- Front-Endtags: # 标签- GitHubtoc: true # 是否显示目录thumbnail: '' # 缩略图cover: '/img/a.png' # 头图--- 编辑完成后执行上面三步操作，刷新下浏览器即可看到新文章啦. Hexo及MarkDown语法大家可前往对应官网学习 MarkDown基本语法 及 Hexo文档 ⚠️注意：可以将HTML标签添加到任何Markdown文件中使用。如果您更喜欢某些HTML标记而不是Markdown语法，这将很有帮助。例如，有些人发现将HTML标签用于图像更容易。 添加网易云音乐打开网页版的 网易云音乐，选择喜欢的音乐，点击生成外链播放器 可自定义配置： 安装插件（评论，统计，分享等）评论系统Hexo的评论插件官方推荐了disqus，但国内无法访问，不能保证所有人都有克服的方法。所有我们打算采用其他的第三方来实现，市面上产品很多，我们做如下对比： Github类：gitment， gitalk，gitter，风格很像github，评论需要github账号； 基于 leancloud 的无后端评论系统：Valine，需要实名注册leancloud帐号； livere 中文名字叫来必力，是一款韩国的评论系统； 畅言云评，安装需要备案号； disqus 比较大牌的评论系统，服务稳定，唯一的缺点是国内无法使用。 最终，推荐使用 valine 评论系统，操作步骤如下： 注册LeanCloud (https://leancloud.app/)，并实名认证 创建应用，应用名称随便取 点击 设置 &gt; 安全中心 把自己博客网址添加到安全中心，保证数据的调用安全。 点击设置 &gt; 应用Key 复制App ID 和 App Key 修改配置 1234567891011121314151617181920212223 # Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true # 启用 appid: xxx # leancloud应用中的appId 必填 appkey: xxx # leancloud应用中的appKey必填 notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: &quot;&quot; # 可选填 avatar: robohash # 默认头像 avatar_force: false # 可选填 meta: [&quot;nick&quot;, &quot;mail&quot;, &quot;link&quot;] # 可选填 page_size: 10 # 可选填 lang: zh-CN # 可选填 visitor: false # 可选填 highlight: true # 可选填 record_ip: false # 可选填 server_urls: # 可选填 emoji_cdn: # 可选填 emoji_maps: # 可选填 enable_qq: false # 可选填 required_fields: [] 测试valine评论执行 hexo c 三步，重启博客，查看效果，评论的数据存在leancloud应用中，如图： leancloud应用数据： ⚠️注意：在 Front-matter 中通过comments属性设置true或false控制该页面或者是文章的评论功能是否打开，如下： 123456---title: Tagsdate: 2019-12-19 16:10:19type: &quot;tags&quot;comments: false--- 加密插件参考文章对 Hexo 博客文章进行加密 ⚠️注意：部署后需使用https协议，问题参考 密码之后没反应 console报错如下 其他个性化设置（统计，分享等），大家可以评论分享，共同探讨。 绑定个人域名域名购买购买渠道有很多，这里以 阿里云的万网域名购买为例，找到合适自己的域名： 选择域名，根据提示绑定邮箱上传实名认证信息，审核通过后即可付款 域名解析域名解析到购买厂商处进行解析，此处在阿里云的 控制台 &gt; 域名 &gt; 域名列表 找到域名右侧对应的解析按钮。点击然后添加解析 按照如下填写添加解析，记得把记录值替换成你自己的博客地址 仓库配置回到github仓库，进入你的仓库设置页面，在添加域名，然后保存即可，github默认在仓库里面创建一个CNAME文件，内容为你的域名，之后就可以通过你的域名访问博客啦。 此处的 Enforce HTTPS 配置，选中时将强制使用HTTPS，您的站点将只通过HTTPS服务，不能使用http服务（后面图床工具中我们将只能使用http，若域名未配置SSL证书），所以会导致图片无法显示 CNAME 即指别名记录，也被称为规范名字。这种记录允你将多个名字映射到同一台计算机。 当需要将域名指向另一个域名，再由另一个域名提供 ip地址，就需要添加 CNAME 记录。 在github中默认生成的CNAME文件，会在下次 hexo d 部署之后丢失，所以，我们可以在项目的 source文件下新建CNAME文件，内容依然是自己的域名，这样每次打包，都会在 public 文件中带有CNAME文件 ⚠️注意：以上步骤完成后可以通过域名访问，但是域名前是http协议，虽说不影响使用和阅读，但如何将自己的博客协议改为Https，可以通过使用一个国外的CDN服务提供商 Cloudflare，详细操作后续补全。 使用图床工具博文中有图片时，若是少量图片，可以直接把存放在source文件夹中，但会占据大量的存储的空间，加载时缓慢 ，所以考虑把博文里的图片上传到某一网站，然后获得外部链接，使用Markdown语法，![图片信息](外部链接) 完成图片的插入，这种网站就被成为图床。常见的简易的图床网站很多，大家有兴趣可以自行搜索，比如 SM.MS ，postimg ，七牛云 等，github也是可以用来当做图床。我们这边以 七牛云 为例。 ⚠️注意：七牛云注册帐号后免费提供一个测试域名，每个域名每日限总流量 10GB，每个测试域名自创建起 30 个自然日后系统会自动回收。所以有长久需求的用户需要自己的个人备案域名。具体步骤如下： 注册七牛云 创建七牛云存储空间 个人域名备案 绑定域名 注册帐号根据提示完成注册绑定邮箱等操作。 创建七牛云存储空间在 控制台 &gt; 对象存储 &gt; 空间管理 中新建存储空间，名称自定义，区域选离自己近的，访问控制可以选公开，若选私有，后续获取图片外链要授权。 ⚠️注意：此处有坑，尽量选择前面的5种，暂时别选华东-浙江2，后面配置PicGo时会有问题。 创建完之后，在 控制台 &gt; CDN &gt; 域名管理 中可看到免费的测试域名： 测试域名有使用限制： 所以需要绑定一个已备案的个人域名： 个人域名备案a. 进入阿里云 控制台 &gt; ICP备案 点击我要备案 b. 根据提示，填写信息 点击 信息校验 ，若报错，则根据提示修改，可以参考ICP备案文档 或右侧智能在线询问。因为域名实名认证通过后还需同步到工信局，需要1-2天时间，所以报如下错： 信息填写完毕之后，需要到app端确认信息 ⚠️注意：其中网站名称及备注等，限制较多词汇，且证件照需要白色背景等，导致阿里初审时可能会不通过，客服会打电话并发邮件通知需修改项，阿里初审通过后需要等待几个工作日工信部审批(我是3天左右)，最后备案成功。 绑定域名域名备案通过之后，即可在七牛云中点击 控制台 &gt; CDN &gt; 域名管理 &gt; 添加域名： 加速域名可以填一个二级域名。即在你的域名（假定为xxxx.com）面前增加一个比如cdn.xxxx.com或者qn.xxxx.com都是可以的，前缀随便输入。 创建完成后，就会有一个CNAME的域名，复制： 到阿里云域名控制台解析DNS增加新的记录（同上面域名解析操作）： 回到七牛云域名列表，可看到状态已成功： 在七牛云 控制台 &gt; 对象存储 &gt; 空间管理 中上传一张图片，复制外链到浏览器看是否成功： 使用图床工具PicGo图传工具就是说可以方便我们上传图片到图床的客户端工具，Mpic 或 PicGo等，我们使用PicGo。可以通过下载PicGo app，因为我主要使用vsCode编辑markdown，所以我们使用vscode PicGo 插件， 安装vscode插件 PicGo： 配置PicGo（绑定七牛云）： 选择七牛云为默认图床 修改其他配置 Access Key 对应 七牛云中 AccessKey Secret Key 对应 七牛云中 SecretKey Bucket 对应 七牛云中 空间名称(以当前博客为例: czh-2) Url 对应 七牛云中 二级域名(以当前博客为例: http://blog.xxx.cn) Area 对应 七牛云中 存储空间内的存储区域 当前插件中 Area 可选项只有5项，对应如图： 七牛云对象存储区域上传表（除华东-浙江2: cn-east-2）: 七牛云可选存储区域： 存储区域若是不能与七牛云匹配，上传图片时会报如下错：PicGo: 上传失败! incorrect region, please use up-cn-east-2.qiniup.com 使用PicGo上传图片 从剪贴板上传快捷键方式，Windows/Unix为 Ctrl + Alt + U，OsX为 Cmd + Opt + U。 从资源管理器选择上传快捷键方式，Windows/Unix为 Ctrl + Alt + E，OsX为 Cmd + Opt + E。 输入本地资源地址上传快捷键方式，Windows/Unix为 Ctrl + Alt + O，OsX为 Cmd + Opt + O。 以上三种方式上传时，若选中文本则以选中文本为上传文件名 其他写到此处，差不到也告一段落，总结一些经验，分享一些有趣的东西，开源精神不灭。希望能给正在阅读文章的你带来一些灵感与帮助。如果有任何疑问或者更好的想法欢迎在评论区交流， 大家一起学习。 —- End —-","link":"/2022/03/12/Hexo/hexo-site/"},{"title":"理解JS 执行上下文 作用域 闭包","text":"执行上下文作用域闭包 执行上下文(参考文章)什么是执行上下文执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。 三种执行上下文类型 全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。 函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。 Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里不讨论它。 创建执行上下文有两个阶段：1) 创建阶段 和 2) 执行阶段 创建阶段 this 值的决定，即我们所熟知的 This 绑定。 创建词法环境组件。（存在差异，还需阅读源码） 创建变量环境组件。 this 绑定：在全局执行上下文中，this 的值指向全局对象。(在浏览器中，this引用 Window 对象)。在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined（在严格模式下）。例如： 12345678let foo = { baz: function() { console.log(this); }}foo.baz(); // 'this' 引用 'foo', 因为 'baz' 被对象 'foo' 调用let bar = foo.baz;bar(); // 'this' 指向全局 window 对象，因为没有指定引用对象 执行阶段完成对所有这些变量的分配，最后执行代码。 ⚠️注意：在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined。 执行栈什么是执行栈是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。 123456789101112131415let a = 'Hello World!';function first() { console.log('Inside first function'); second(); console.log('Again inside first function');}function second() { console.log('Inside second function');}first();console.log('Inside Global Execution Context'); 当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 first() 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。 当从 first() 函数内部调用 second() 函数时，JavaScript 引擎为 second() 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 second() 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 first() 函数的执行上下文。 当 first() 执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。 基本概念 js的执行实际上是放到执行上下文栈的 执行上下文就是为代码的执行做了一系列准备，包括this和词法环境变量环境等等 执行栈：存放执行上下文的地方，在栈顶的执行上下文就是当前执行上下文，js总会到这里寻找资源。函数执行上下文在执行完毕之后就会从栈顶弹出 创建执行上下文的四种情况：进入全局代码，进入function函数体代码，进入eval函数指定的代码，进入module函数 执行上下文的内部结构：词法环境【环境记录（申明，存放变量与函数的地方）+outer指向(形成作用域链的关键)】+ this绑定(这个就是我们熟悉的this指向)(参考文章) 这里我们把写在环境记录上的变量和函数统称为词法环境 作用域就是解析（查找）变量名的一个集合，就是当前运行上下文（也可以是当前上下文的词法环境) 全局作用域就是全局执行上下文 函数作用域就是函数执行上下文 全局执行上下文中的词法环境1234567891011121314151617181920212223242526272829console.log(foo);if (true) { var foo = 'foo'}step1:创建执行上下文，并加入栈顶，当前执行上下文就是这个全局执行上下文，在栈顶tips:全局执行上下文的文本环境（花名册）有两部分组成：全局对象（浏览器执行环境就是window对象）以及全局[[scope]] (其实也是一个块作用域，全局的块)两者的区别：var和function声明创建在全局对象中，而let const class声明的变量创建在全局scope中先到全局scope中查找变量，然后再到全局对象中查找 step2:分析：找到所有非函数中的var声明找到所有的顶级函数声明找到let const class声明step3:名字重复处理1.let const class声明的名字之间不能重复2.let const class和var function的名字之间不能重复3.var 和 function名字重复的 functionstep4:创建绑定声明并初始化var为undefined顶级函数声明：申明function名字，并初始化为新创建对象（这里函数的对象就已经创建完成了）块级中函数声明（比如在if块中）：声明名字，初始化为undefined声明let const class 但未初始化,不能使用 所以会报错step5:执行语句 12345678910js中的代码总是遵循先申明再执行的准则，那么在申明的时候var function是申明在全局对象上的，而let const是登录在全局scope上的。var声明放入变量会提升并初始化为undefined,但是let const 也会提升(此处还需仔细探讨[let到底会不会造成变量提升](https://blog.csdn.net/amyleeYMY/article/details/122555195))，只是不会初始化，所以会报错。查找变量的时候总是从全局scope到全局对象上面查找var a = 10function foo() { console.log(a); let a}foo()// Uncaught ReferenceError: Cannot access 'a' before initialization 变量提升与函数提升的机制 块级作用域 块级作用域,不会形成自己的执行上下文，链接在原来的文本环境之前执行完毕之后就会被销毁 123456let inIf = 'out if statement'if (true) { let inIf = 'in if statement' console.log(inIf); //in if statement}console.log(inIf); //out if statement 判断与我们之前找的var 顶级函数声明 let/const/class声明是否重复 如果重复了，就不做处理如果不重复，就在全局对象中创建一个以函数名命名的变量，并且将其初始化为undefined 1234567891011121314151617181920212223242526272829console.log(foo); //undefinedif (true) { function foo() { console.log('in block'); //in block }}foo()因为块里面是函数，在函数foo执行完毕销毁之前，它会查看全局变量中有没有函数名foo，没有的话，不做处理，有的话，就会把全局变量中foo的值(undefined)替换 全局对象中已经变成函数对象在块里的函数也是会提升的，只不过它没有立即创建函数，它是undefinedconsole.log(foo);if (false) { // function foo() { // console.log('......'); // }}let foo;// 报错,let声明的变量在全局scope上，foo在全局对象上没有找到foo,于是不做处理var foo// ';;',var声明的变量在全局对象上，foo在全局对象上找到foo,于是在执行结束之前完成赋值if (true) { function foo() { console.log(';;'); }}foo()先申明后使用，申明的地方就是执行上下文 函数作用域 function函数会创建在全局执行上下文的词法环境（全局对象）之中，函数创建的时候就已经完成初始化有函数名了。并且函数创建的时候就会携带一个[[scope]]（类似于一个小背包，记录函数创建的环境）所以函数在创建的时候体内就保存了它创建时执行上下文的文本环境。等到它执行的时候，会自动找到它的[[scope]],里面保存着创建时的文本环境 函数调用的执行上下文——函数在哪里创建，就保存哪里的运行上下文；函数的作用域是在函数创建的时候决定的而不是调用的时候决定 函数的作用域链是根据函数创建的位置形成的作用域链，这就是所谓的静态作用域，词法作用域 函数 函数创建 JS声明函数的三种方式（参考文章）: // 函数表达式(function expression) var h = function() { // h } // 函数声明(function declaration) function h() { // h }1.函数声明: 即上面第二种方式,会声明一个具名函数, 且函数能在其所在作用域的任意位置被调用, 其创建的函数为具名函数, 证明这一点你可以 console.log(h.name); 可以看到打印为 “h”. 可在后面的代码中将此函数通过函数名赋值给变量或者对象属性 2.函数表达式: 即上面第一种方式, 这种方法使用function操作符创建函数, 表达式可以存储在变量或者对象属性里. 函数表达式往往被称为匿名函数, 因为它没有名字. 证明这一点你可以 console.log(h.name); 可以看到打印为空 “” 3.Function()构造器: 不推荐这种用法, 容易出问题 1-函数声明 12345关于函数声明，它最重要的一个特征就是函数声明提升，意思是执行代码之前先读取函数声明。不管函数声明写在前面，还是后面，都会出现函数声明的提升。add(1,2); //弹窗显示：3 function add(x,y){ alert(x+y) } 2-命名函数表达式 12345var add = function(x,y){ alert(x+y) }add(1,2) //弹窗显示：3 这种形式看起来好像是常规的变量赋值语句。但是函数表达式和函数声明的区别在于，函数表达式在使用前必须先赋值。所以这段代码执行的时候就会出错： 12345add(1,2) //无弹窗，报错： add is not a function var add = function(x,y){ alert(x+y) } 造成这种现象是因为解析器在向执行环境中加载数据时，解析器会率先读取函数声明，并使其在执行任何代码前可用；至于函数表达式，则必须等到解析器执行到它的所在的的代码行，才会真正的被解析。函数表达式中，创建的函数叫做匿名函数，因为function关键字后面没有标识符。 先说两者的显著区别: 第一种声明方式也就是var声明方式, 函数只有在var语句声明之后才能被调用 第二种申明方式也就是function声明方式, 函数可以在function声明之前被调用 这是因为, 对第一种情况, 函数表达式是在函数运行阶段才赋值给变量h 对第二种情况, 函数申明是在代码运行阶段之前, 也就是代码解析阶段就赋值给标识符h 可以看下面两个例子: 1234567891011121314151617181920212223242526272829var h = function () { // h}console.log(h) h = function () { // h1}打印： ƒ h() { // h }因为赋值发生在代码运行阶段, 代码自上而下运行console.log(h)所在位置只能获取它之前的赋值第二种情况：function h() { // h}console.log(h) function h() { // h1}打印： ƒ h() { // h1 }因为赋值发生在代码解析阶段, 代码运行到console.log(h)时解析早已完成, 而解析的结果是后面那个函数h, 故会打印此结果 函数表达式（匿名函数）调用方式： 使用()将匿名函数括起来，然后后面再加一对小括号（包含参数列表）。我们再看一下以下一个例子： 1234567891011121314151617181920212223242526//表达式的调用/*const add = function (x, y){ return x + y;}const sum = add(1, 2)console.log(sum)*///匿名函数式调用//方式1//这种方式尽量少用const sum1 = function(x, y){ return x + y;}(1, 2);//方式2 自执行函数//推荐const sum = (function(x, y){ return x + y;})(1, 2);console.log(sum1);//方式3(new Function(&quot;x&quot;,&quot;y&quot;,&quot;return x+y&quot;))(1,2) 自执行函数，即定义和调用合为一体。我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。 123456789101112131415161718192021// 下面2个括弧()都会立即执行 (function () { /* code */ } ()) // 推荐使用这个 (function () { /* code */ })() // 但是这个也是可以用的 // 由于括弧()和JS的&amp;&amp;，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的 // 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了 var i = function () { return 10; } (); true &amp;&amp; function () { /* code */ } (); 0, function () { /* code */ } (); // 如果你不在意返回值，或者不怕难以阅读// 你甚至可以在function前面加一元操作符号 !function () { /* code */ } (); ~function () { /* code */ } (); -function () { /* code */ } (); +function () { /* code */ } (); // 还有一个情况，使用new关键字,也可以用，但我不确定它的效率 // http://twitter.com/kuvos/status/18209252090847232 new function () { /* code */ } new function () { /* code */ } () // 如果需要传递参数，只需要加上括弧() 函数声明的函数创建过程使用的是当前运行上下文的词法环境，但是命名函数表达式创建过程是在当前运行上下文词法环境之前加了新的词法环境，在自己的词法环境中添加对函数命名funname的绑定，并通过outer与当前运行上下文的词法环境链接起来。funname在函数外是没有定义的 3-new Function创建 只能访问全局变量，所以不管在哪儿创建都类似于在全局环境中创建 函数的执行不同的函数调用方式会给函数传递不同的thisArg值 普通函数包括IIDE：传递undefined 对象方法：传递对象 new方法：传递新创建的对象 不同调用方式的this指向this就是thisBinding，但是它是动态的，它与在哪儿调用密切相关 普通函数调用：undefined(非严格模式下是window) 作为方法调用：指向someObject new function调用：总是指向新创建的newObject call bind apply 指向参数对象 箭头函数与在哪儿创建有关，不能使用call bind apply 参考js中执行上下文和执行栈是什么 闭包参考 我从来不理解JavaScript闭包，直到有人这样向我解释它… JS 闭包经典使用场景和含闭包必刷题 如果没有闭包的存在，函数执行完了之后，它的词法环境就会被销毁，正是有了闭包的存在，才能在全局环境中引用函数，继而保证整个函数环境的存在（函数体内总是携带着它初始化时的环境）。闭包可以让函数在运行完毕之后，其运行上下文的词法环境仍然能被访问。 123456789function foo() { console.log(a);}function bar() { var a = 3 foo()}var a = 2bar() //2","link":"/2024/02/25/JavaScript/javaScript-bibao/"},{"title":"TS 基础","text":"TS 基础 原始类型: string，number 和 boolean（The primitives）JavaScript 有三个非常常用的原始类型 (opens new window)：string，number 和 boolean，每一个类型在 TypeScript 中都有对应的类型。他们的名字跟你在 JavaScript 中使用 typeof 操作符得到的结果是一样的。 string 表示字符串，比如 “Hello, world” number 表示数字，比如 42，JavaScript 中没有 int 或者 float，所有的数字，类型都是 number boolean 表示布尔值，其实也就两个值： true 和 false 数组（Array）声明一个类似于 [1, 2, 3] 的数组类型，你需要用到语法 number[]。这个语法可以适用于任何类型（举个例子，string[] 表示一个字符串数组）。你也可能看到这种写法 Array&lt;number&gt;，是一样的。我们会在泛型章节为大家介绍 T&lt;U&gt; 语法。 注意 [number] 和 number[] 表示不同的意思，参考元组 (opens new window)章节 anyTypeScript 有一个特殊的类型，any，当你不希望一个值导致类型检查错误的时候，就可以设置为 any 。 当一个值是 any 类型的时候，你可以获取它的任意属性 (也会被转为 any 类型)，或者像函数一样调用它，把它赋值给一个任意类型的值，或者把任意类型的值赋值给它，再或者是其他语法正确的操作，都可以： 123456789let obj: any = { x: 0 };// None of the following lines of code will throw compiler errors.// Using `any` disables all further type checking, and it is assumed // you know the environment better than TypeScript.obj.foo();obj();obj.bar = 100;obj = &quot;hello&quot;;const n: number = obj; 当你不想写一个长长的类型代码，仅仅想让 TypeScript 知道某段特定的代码是没有问题的，any 类型是很有用的。 变量上的类型注解（Type Annotations on Variables）当你使用 const、var 或 let 声明一个变量时，你可以选择性的添加一个类型注解，显式指定变量的类型： 1let myName: string = &quot;Alice&quot;; TypeScript 并不使用“在左边进行类型声明”的形式，比如 int x = 0；类型注解往往跟在要被声明类型的内容后面。不过大部分时候，这不是必须的。因为 TypeScript 会自动推断类型。举个例子，变量的类型可以基于初始值进行推断： 12// No type annotation needed -- 'myName' inferred as type 'string'let myName = &quot;Alice&quot;; 大部分时候，你不需要学习推断的规则。如果你刚开始使用，尝试尽可能少的使用类型注解。你也许会惊讶于，TypeScript 仅仅需要很少的内容就可以完全理解将要发生的事情。 函数（Function）参数/返回值类型注解123function getFavoriteNumber(arg: number): number { return arg+1} 匿名函数匿名函数有一点不同于函数声明，当 TypeScript 知道一个匿名函数将被怎样调用的时候，匿名函数的参数会被自动的指定类型。这是一个例子： 12345678910111213// No type annotations here, but TypeScript can spot the bugconst names = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;];// Contextual typing for functionnames.forEach(function (s) { console.log(s.toUppercase()); // Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?}); // Contextual typing also applies to arrow functionsnames.forEach((s) =&gt; { console.log(s.toUppercase()); // Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?}); 尽管参数 s 并没有添加类型注解，但 TypeScript 根据 forEach 函数的类型，以及传入的数组的类型，最后推断出了 s 的类型。 这个过程被称为上下文推断（contextual typing），因为正是从函数出现的上下文中推断出了它应该有的类型。 跟推断规则一样，你也不需要学习它是如何发生的，只要知道，它确实存在并帮助你省掉某些并不需要的注解。后面，我们还会看到更多这样的例子，了解一个值出现的上下文是如何影响它的类型的。 对象类型123456// The parameter's type annotation is an object typefunction printCoord(pt: { x: number; y?: number }) { console.log(&quot;The coordinate's x value is &quot; + pt.x); console.log(&quot;The coordinate's y value is &quot; + pt.y);}printCoord({ x: 3, y: 7 }); 这里，我们给参数添加了一个类型，该类型有两个属性, x 和 y，两个都是 number 类型。你可以使用 , 或者 ; 分开属性，最后一个属性的分隔符加不加都行。 每个属性对应的类型是可选的，如果你不指定，默认使用 any 类型。 联合类型第一种组合类型的方式是使用联合类型，一个联合类型是由两个或者更多类型组成的类型，表示值可能是这些类型中的任意一个。这其中每个类型都是联合类型的成员（members）。 让我们写一个函数，用来处理字符串或者数字： 1234567891011function printId(id: number | string) { console.log(&quot;Your ID is: &quot; + id);}// OKprintId(101);// OKprintId(&quot;202&quot;);// ErrorprintId({ myID: 22342 });// Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.// Type '{ myID: number; }' is not assignable to type 'number'. 类型别名我们已经学会在类型注解里直接使用对象类型和联合类型，这很方便，但有的时候，一个类型会被使用多次，此时我们更希望通过一个单独的名字来引用它。 这就是类型别名（type alias）。所谓类型别名，顾名思义，一个可以指代任意类型的名字。类型别名的语法是： 12345678910type Point = { x: number; y: number;};// Exactly the same as the earlier examplefunction printCoord(pt: Point) { console.log(&quot;The coordinate's x value is &quot; + pt.x); console.log(&quot;The coordinate's y value is &quot; + pt.y);}printCoord({ x: 100, y: 100 }); 你可以使用类型别名给任意类型一个名字，举个例子，命名一个联合类型： 1type ID = number | string; 接口（Interfaces）1234567891011interface Point { x: number; y: number;} function printCoord(pt: Point) { console.log(&quot;The coordinate's x value is &quot; + pt.x); console.log(&quot;The coordinate's y value is &quot; + pt.y);} printCoord({ x: 100, y: 100 }); 就像我们在上节使用的类型别名，这个例子也同样可以运行，就跟我们使用了一个匿名对象类型一样。TypeScript 只关心传递给 printCoord 的值的结构（structure）——关心值是否有期望的属性。正是这种只关心类型的结构和能力的特性，我们才认为 TypeScript 是一个结构化（structurally）的类型系统。 类型别名和接口的不同类型别名和接口非常相似，大部分时候，你可以任意选择使用。接口的几乎所有特性都可以在 type 中使用，两者最关键的差别在于类型别名本身无法添加新的属性，而接口是可以扩展的。 123456789101112131415161718192021222324252627// Interface// 通过继承扩展类型interface Animal { name: string}interface Bear extends Animal { honey: boolean}const bear = getBear() bear.namebear.honey // Type// 通过交集扩展类型type Animal = { name: string}type Bear = Animal &amp; { honey: boolean }const bear = getBear();bear.name;bear.honey; 123456789101112131415161718192021222324// Interface// 对一个已经存在的接口添加新的字段interface Window { title: string}interface Window { ts: TypeScriptAPI}const src = 'const a = &quot;Hello World&quot;';window.ts.transpileModule(src, {}); // Type// 创建后不能被改变type Window = { title: string}type Window = { ts: TypeScriptAPI}// Error: Duplicate identifier 'Window'. 在后续的章节里，你还会了解的更多。所以下面这些内容不能立刻理解也没有关系： 在 TypeScript 4.2 以前，类型别名的名字可能会出现在报错信息中 (opens new window)，有时会替代等价的匿名类型（也许并不是期望的）。接口的名字则会始终出现在错误信息中。 类型别名也许不会实现声明合并，但是接口可以(opens new window) 接口可能只会被用于声明对象的形状，不能重命名原始类型(opens new window) 接口通过名字使用的时候，他们的名字会总是出现在错误信息中，如果直接使用，则会出现原始结构(opens new window)大部分时候，你可以根据个人喜好进行选择。TypeScript 会告诉你它是否需要其他方式的声明。如果你喜欢探索性的使用，那就使用 interface ，直到你需要用到 type 的特性。 类型断言（Type Assertions）有的时候，你知道一个值的类型，但 TypeScript 不知道。举个例子，如果你使用 document.getElementById，TypeScript 仅仅知道它会返回一个 HTMLElement，但是你却知道，你要获取的是一个 HTMLCanvasElement。这时，你可以使用类型断言将其指定为一个更具体的类型： 1const myCanvas = document.getElementById(&quot;main_canvas&quot;) as HTMLCanvasElement; 就像类型注解一样，类型断言也会被编译器移除，并且不会影响任何运行时的行为。你也可以使用尖括号语法（注意不能在 .tsx 文件内使用），是等价的： 1const myCanvas = &lt;HTMLCanvasElement&gt;document.getElementById(&quot;main_canvas&quot;); 谨记：因为类型断言会在编译的时候被移除，所以运行时并不会有类型断言的检查，即使类型断言是错误的，也不会有异常或者 null 产生。TypeScript 仅仅允许类型断言转换为一个更加具体或者更不具体的类型。这个规则可以阻止一些不可能的强制类型转换，比如： 12const x = &quot;hello&quot; as number;// Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first. 有的时候，这条规则会显得非常保守，阻止了你原本有效的类型转换。如果发生了这种事情，你可以使用双重断言，先断言为 any （或者是 unknown），然后再断言为期望的类型： 1const a = (expr as any) as T; 字面量类型（Literal Types）除了常见的类型 string 和 number ，我们也可以将类型声明为更具体的数字或者字符串。众所周知，在 JavaScript 中，有多种方式可以声明变量。比如 var 和 let ，这种方式声明的变量后续可以被修改，还有 const ，这种方式声明的变量则不能被修改，这就会影响 TypeScript 为字面量创建类型。 123456789101112let changingString = &quot;Hello World&quot;;changingString = &quot;Olá Mundo&quot;;// Because `changingString` can represent any possible string, that// is how TypeScript describes it in the type systemchangingString;// let changingString: string复制代码const constantString = &quot;Hello World&quot;;// Because `constantString` can only represent 1 possible string, it// has a literal type representationconstantString;// const constantString: &quot;Hello World&quot; 字面量类型本身并没有什么太大用： 123456let x: &quot;hello&quot; = &quot;hello&quot;;// OKx = &quot;hello&quot;;// ...x = &quot;howdy&quot;;// Type '&quot;howdy&quot;' is not assignable to type '&quot;hello&quot;'. 如果结合联合类型，就显得有用多了。举个例子，当函数只能传入一些固定的字符串时： 123456function printText(s: string, alignment: &quot;left&quot; | &quot;right&quot; | &quot;center&quot;) { // ...}printText(&quot;Hello, world&quot;, &quot;left&quot;);printText(&quot;G'day, mate&quot;, &quot;centre&quot;);// Argument of type '&quot;centre&quot;' is not assignable to parameter of type '&quot;left&quot; | &quot;right&quot; | &quot;center&quot;'. 数字字面量类型也是一样的： 123function compare(a: string, b: string): -1 | 0 | 1 { return a === b ? 0 : a &gt; b ? 1 : -1;} 当然了，你也可以跟非字面量类型联合： 1234567891011interface Options { width: number;}function configure(x: Options | &quot;auto&quot;) { // ...}configure({ width: 100 });configure(&quot;auto&quot;);configure(&quot;automatic&quot;);// Argument of type '&quot;automatic&quot;' is not assignable to parameter of type 'Options | &quot;auto&quot;'. 还有一种字面量类型，布尔字面量。因为只有两种布尔字面量类型， true 和 false ，类型 boolean 实际上就是联合类型 true | false 的别名。 字面量推断（Literal Inference）当你初始化变量为一个对象的时候，TypeScript 会假设这个对象的属性的值未来会被修改，举个例子，如果你写下这样的代码： 1234const obj = { counter: 0 };if (someCondition) { obj.counter = 1;} TypeScript 并不会认为 obj.counter 之前是 0， 现在被赋值为 1 是一个错误。换句话说，obj.counter 必须是 number 类型，但不要求一定是 0，因为类型可以决定读写行为。这也同样应用于字符串: 1234declare function handleRequest(url: string, method: &quot;GET&quot; | &quot;POST&quot;): void;const req = { url: &quot;https://example.com&quot;, method: &quot;GET&quot; };handleRequest(req.url, req.method);// Argument of type 'string' is not assignable to parameter of type '&quot;GET&quot; | &quot;POST&quot;'. 在上面这个例子里，req.method 被推断为 string ，而不是 &quot;GET&quot;，因为在创建 req 和 调用 handleRequest 函数之间，可能还有其他的代码，或许会将 req.method 赋值一个新字符串比如 &quot;Guess&quot; 。所以 TypeScript 就报错了。有两种方式可以解决：添加一个类型断言改变推断结果： 1234// Change 1:const req = { url: &quot;https://example.com&quot;, method: &quot;GET&quot; as &quot;GET&quot; };// Change 2handleRequest(req.url, req.method as &quot;GET&quot;); 修改 1 表示“我有意让 req.method 的类型为字面量类型 &quot;GET&quot;，这会阻止未来可能赋值为 &quot;GUESS&quot; 等字段”。修改 2 表示“我知道 req.method 的值是 &quot;GET&quot;”.你也可以使用 as const 把整个对象转为一个类型字面量： 12const req = { url: &quot;https://example.com&quot;, method: &quot;GET&quot; } as const;handleRequest(req.url, req.method); as const 效果跟 const 类似，但是对类型系统而言，它可以确保所有的属性都被赋予一个字面量类型，而不是一个更通用的类型比如 string 或者 number 。 null 和 undefinedJavaScript 两个原始类型的值，用于表示空缺或者未初始化，他们分别是 null 和 undefined 。TypeScript 有两个对应的同名类型。它们的行为取决于是否打开了 strictNullChecks (opens new window)选项。 strictNullChecks 关闭当 strictNullChecks (opens new window)选项关闭的时候，如果一个值可能是 null 或者 undefined，它依然可以被正确的访问，或者被赋值给任意类型的属性。这有点类似于没有空值检查的语言 (比如 C# ，Java) 。这些检查的缺少，是导致 bug 的主要源头，所以我们始终推荐开发者开启 strictNullChecks (opens new window)选项。 strictNullChecks 打开当 strictNullChecks (opens new window)选项打开的时候，如果一个值可能是 null 或者 undefined，你需要在用它的方法或者属性之前，先检查这些值，就像用可选的属性之前，先检查一下 是否是 undefined ，我们也可以使用类型收窄（narrowing）检查值是否是 null： 1234567function doSomething(x: string | null) { if (x === null) { // do nothing } else { console.log(&quot;Hello, &quot; + x.toUpperCase()); }} 非空断言操作符（后缀 !）TypeScript 提供了一个特殊的语法，可以在不做任何检查的情况下，从类型中移除 null 和 undefined，这就是在任意表达式后面写上 ! ，这是一个有效的类型断言，表示它的值不可能是 null 或者 undefined： 1234function liveDangerously(x?: number | null) { // No error console.log(x!.toFixed());} 就像其他的类型断言，这也不会更改任何运行时的行为。重要的事情说一遍，只有当你明确的知道这个值不可能是 null 或者 undefined 时才使用 ! 。 枚举（Enums）枚举是 TypeScript 添加的新特性，用于描述一个值可能是多个常量中的一个。不同于大部分的 TypeScript 特性，这并不是一个类型层面的增量，而是会添加到语言和运行时。因为如此，你应该了解下这个特性。但是可以等一等再用，除非你确定要使用它。你可以在枚举类型 (opens new window)页面了解更多的信息。 123456enum Direction { Up = 1, Down, Left, Right,} 不常见的原始类型我们提一下在 JavaScript 中剩余的一些原始类型。但是我们并不会深入讲解。 bigIntES2020 引入原始类型 BigInt，用于表示非常大的整数： 12345// Creating a bigint via the BigInt functionconst oneHundred: bigint = BigInt(100); // Creating a BigInt via the literal syntaxconst anotherHundred: bigint = 100n; 你可以在 [TypeScript 3.2 的发布日志](the TypeScript 3.2 release notes)中了解更多信息。 symbol这也是 JavaScript 中的一个原始类型，通过函数 Symbol()，我们可以创建一个全局唯一的引用： 1234567const firstName = Symbol(&quot;name&quot;);const secondName = Symbol(&quot;name&quot;); if (firstName === secondName) { // This condition will always return 'false' since the types 'typeof firstName' and 'typeof secondName' have no overlap. // Can't ever happen} 你可以在 Symbol 页面 (opens new window)了解更多的信息。","link":"/2024/03/26/TypeScript/ts-basic/"},{"title":"了解 Vue 相关问题","text":"生命周期 vuex vue-router 3种模式 虚拟dom 了解 Vue diff算法 vue 底层代码 Vue.set() vue 生命周期vue 的生命周期钩子核心实现是利用发布订阅模式，先把用户传入的生命周期钩子订阅好，内部使用数组方式存储，然后再创建实例过程中会一次执行对应的钩子方式(发布)： beforeCreate: 是 new Vue() 之后触发的第一个钩子，当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能访问。 created: 可以使用数据，props，methods，data依次可访问，以及更改数据，无法与Dom 进行交互。在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，在当前阶段无法与 Dom 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 Dom。 beforeMount: 虚拟dom已生成，真实dom未挂载。发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 Dom 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。 mounted: 真实Dom已挂载，数据完成双向绑定，可以使用 $refs 对Dom 操作。在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点，使用 $refs 属性对 Dom 进行操作。 beforeUpdate: 发生在更新之前，也就是响应式数据发生更新，虚拟 dom 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。 updated: 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。 beforeDestroy: 发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。 destroyed: 发生在实例销毁之后，这个时候只剩下了 dom 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。 vuex vuex的出现是为了解决组件间的通信问题,如果某个操作或者数据不涉及到公共操作,只是单一组件操作,不要把这些状态值或者function存储到vuex中,因为vuex会把自身挂载到所有组件上,不管当前组件是否用到里面的东西,因此这事实上肯定增加了性能的损耗的. vuex中，有默认的五种基本的对象： state：定义了应用状态的数据结构，可以在这里设置默认的初始状态 getters：对数据获取之前的再次编译，可以理解为state的计算属性。 mutations：修改状态，并且是同步的。这个和我们组件中的自定义事件类似。 actions：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 modules：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 mapGetters 辅助函数 项目的src文件夹如下： 1234567891011121314151617181920│ App.vue│ main.js│├─assets│ logo.png│├─components│ HelloWorld.vue│├─router│ index.js│└─store modules user.js app.js ... getters.js index.js index.js 文件内容如下： 1234567891011121314151617181920212223import Vue from 'vue'import Vuex from 'vuex'import getters from './getters'Vue.use(Vuex)const modulesFiles = require.context('./modules', true, /\\.js$/)// you do not need `import app from './modules/app'`// it will auto require all vuex module from modules fileconst modules = modulesFiles.keys().reduce((modules, modulePath) =&gt; { // set './app.js' =&gt; 'app' const moduleName = modulePath.replace(/^\\.\\/(.*)\\.\\w+$/, '$1') const value = modulesFiles(modulePath) modules[moduleName] = value.default return modules}, {})const store = new Vuex.Store({ modules, getters})export default store getters.js 文件内容如下： 12345678const getters = { userName: state =&gt; state.user.userName, userId: state =&gt; state.user.userId, sessionId: state =&gt; state.app.sessionId, ...}export default getters 存储数据 123// 调用存储// app 为 modules 文件名，setSessionId 为 actions 中方法名this.$store.dispatch('app/setSessionId', data.sessionId) 1234567891011121314151617181920212223// app.jsconst state = { sessionId: null,}const mutations = { SET_SESSIONID: (state, sessionId) =&gt; { state.sessionId = sessionId },}const actions = { setSessionId({ commit }, sessionId) { commit('SET_SESSIONID', sessionId) },}export default { namespaced: true, state, mutations, actions} 调用数据123computed: { ...mapGetters(['userId', 'sessionId']),} 简易版vuexvue.js 2.6 新增了Observable API， 通过这个api，可以应对一些简单的跨组件数据共享。像是简易版vuex 虚拟DOM什么是虚拟DOM虚拟DOM简而言之就是，用JS去按照DOM结构来实现的树形结构对象，你也可以叫做DOM对象Virtual DOM是对真实DOM的抽象,本质上是树形结构JavaScript对象,这个对象就是更加轻量级的对DOM的描述. 虚拟DOM的优点 通过diff算法来对比dom新老节点，更新虚拟DOM，减少对真实DOM的操作开销，提高性能。 跨平台 抽象了原本的渲染过程实现了跨平台，不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI。以及使用Node.js（没有DOM）实现SSR(服务端渲染)。虚拟DOM对象1234567891011121314151617181920212223// 真实DOM&lt;div id=&quot;app&quot;&gt; &lt;p class=&quot;text&quot;&gt;hello world!!!&lt;/p&gt;&lt;/div&gt;// 虚拟DOM{ tag: 'div', props: { id: 'app' }, chidren: [ { tag: 'p', props: { className: 'text' }, chidren: [ 'hello world!!!' ] } ]} 如何转换为虚拟DOMReact.createElement，以及 Vue 中的 render 方法中的 createElement，另外 React 是通过 babel 将 jsx 转换为 h 函数渲染的形式，而 Vue 是使用 vue-loader 将模版转为 h 函数渲染的形式（也可以通过 babel-plugin-transform-vue-jsx 插件在 vue 中使用 jsx，本质还是转换为 h 函数渲染形式）。 以react为例，使用 babel 将一段 jsx 代码，转换为一段 js 代码： 1234567891011121314151617181920212223function getVDOM() { return ( &lt;div id=&quot;app&quot;&gt; &lt;p className=&quot;text&quot;&gt;hello world!!!&lt;/p&gt; &lt;/div&gt; )}function getVDOM() { return h('div', { id: 'app' },h('p', { lassName: 'text' },'hello world!!!'))}// 可以看到，最终 HTML 代码会被转译成 h 函数的渲染形式。h 函数接受是三个参数，分别代表是 DOM 元素的标签名、属性、子节点，最终返回一个虚拟 DOM 的对象。function h(tag, props, ...children) { return { tag, props: props || {}, children: children.flat() }} 渲染虚拟DOM浏览器环境下如何渲染虚拟 DOM。 123456789101112131415161718192021222324252627282930313233343536function render(vdom) { // 如果是字符串或者数字，创建一个文本节点 if (typeof vdom === 'string' || typeof vdom === 'number') { return document.createTextNode(vdom) } const { tag, props, children } = vdom // 创建真实DOM const element = document.createElement(tag) // 设置属性 setProps(element, props) // 遍历子节点，并获取创建真实DOM，插入到当前节点 children .map(render) .forEach(element.appendChild.bind(element)) // 虚拟 DOM 中缓存真实 DOM 节点 vdom.dom = element // 返回 DOM 节点 return element}function setProps (element, props) { Object.entries(props).forEach(([key, value]) =&gt; { setProp(element, key, value) })}function setProp (element, key, vlaue) { element.setAttribute( // className使用class代替 key === 'className' ? 'class' : key, vlaue )} 将虚拟 DOM 渲染成真实 DOM 后，只需要插入到对应的根节点即可。 1234const vdom = &lt;div&gt;hello world!!!&lt;/div&gt; // h('div', {}, 'hello world!!!')const app = document.getElementById('app')const ele = render(vdom)app.appendChild(ele) 当然在现代化的框架中，一般会有一个组件文件专门用来构造虚拟 DOM，我们模仿 React 使用 class 的方式编写组件，然后渲染到页面中。 1234567891011121314151617181920212223242526class Component { vdom = null // 组件的虚拟DOM表示 $el = null // 虚拟DOM生成的真实节点 state = { text: 'Initialize the Component' } render() { const { text } = this.state return ( &lt;div&gt;{ text }&lt;/div&gt; ) }}function createElement (app, component) { const vdom = component.render() component.vdom = vdom component.$el = render(vdom) // 将虚拟 DOM 转换为真实 DOM app.appendChild(component.$el)}const app = document.getElementById('app')const component = new ComponentcreateElement(app, component) 很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI diff算法 diff 算法，顾名思义，就是比对新老 VDOM 的变化，然后将变化的部分更新到视图上。对应到代码上，就是一个 diff 函数，返回一个 patches（补丁）。 当数据发生改变时，set方法会调用 Dep.notify 通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图 12345678910111213141516171819202122232425262728293031323334353637function patch(oldVnode, vnode, hydrating, removeOnly) { if (isUndef(vnode)) { // 没有新节点，直接执行destory钩子函数 if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return } let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) { isInitialPatch = true createElm(vnode, insertedVnodeQueue) // 没有旧节点，直接用新节点生成dom元素 } else { const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) { // 判断旧节点和新节点自身一样，一致执行patchVnode patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) } else { // 否则直接销毁及旧节点，根据新节点生成dom元素 if (isRealElement) { if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) { oldVnode.removeAttribute(SSR_ATTR) hydrating = true } if (isTrue(hydrating)) { if (hydrate(oldVnode, vnode, insertedVnodeQueue)) { invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode } } oldVnode = emptyNodeAt(oldVnode) } return vnode.elm } }} patch函数前两个参数位为oldVnode 和 Vnode ，分别代表新的节点和之前的旧节点，主要做了四个判断： 没有新节点，直接触发旧节点的destory钩子 没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm 旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode 去处理这两个节点 旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点 下面主要讲的是patchVnode部分: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) { // 如果新旧节点一致，什么都不做 if (oldVnode === vnode) { return } // 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化 const elm = vnode.elm = oldVnode.elm // 异步占位符 if (isTrue(oldVnode.isAsyncPlaceholder)) { if (isDef(vnode.asyncFactory.resolved)) { hydrate(oldVnode.elm, vnode, insertedVnodeQueue) } else { vnode.isAsyncPlaceholder = true } return } // 如果新旧都是静态节点，并且具有相同的key // 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上 // 也不用再有其他操作 if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) { vnode.componentInstance = oldVnode.componentInstance return } let i const data = vnode.data if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) { i(oldVnode, vnode) } const oldCh = oldVnode.children const ch = vnode.children if (isDef(data) &amp;&amp; isPatchable(vnode)) { for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) } // 如果vnode不是文本节点或者注释节点 if (isUndef(vnode.text)) { // 并且都有子节点 if (isDef(oldCh) &amp;&amp; isDef(ch)) { // 并且子节点不完全一致，则调用updateChildren if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) // 如果只有新的vnode有子节点 } else if (isDef(ch)) { if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '') // elm已经引用了老的dom节点，在老的dom节点上添加子节点 addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) // 如果新vnode没有子节点，而vnode有子节点，直接删除老的oldCh } else if (isDef(oldCh)) { removeVnodes(elm, oldCh, 0, oldCh.length - 1) // 如果老节点是文本节点 } else if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, '') } // 如果新vnode和老vnode是文本节点或注释节点 // 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以 } else if (oldVnode.text !== vnode.text) { nodeOps.setTextContent(elm, vnode.text) } if (isDef(data)) { if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode) } } patchVnode主要做了几个判断： 新节点是否是文本节点，如果是，则直接更新dom的文本内容为新节点的文本内容 新节点和旧节点如果都有子节点，则处理比较更新子节点 只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新DOM，并且添加进父节点 只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把DOM 删除 子节点不完全一致，则调用updateChildren: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) { let oldStartIdx = 0 // 旧头索引 let newStartIdx = 0 // 新头索引 let oldEndIdx = oldCh.length - 1 // 旧尾索引 let newEndIdx = newCh.length - 1 // 新尾索引 let oldStartVnode = oldCh[0] // oldVnode的第一个child let oldEndVnode = oldCh[oldEndIdx] // oldVnode的最后一个child let newStartVnode = newCh[0] // newVnode的第一个child let newEndVnode = newCh[newEndIdx] // newVnode的最后一个child let oldKeyToIdx, idxInOld, vnodeToMove, refElm // removeOnly is a special flag used only by &lt;transition-group&gt; // to ensure removed elements stay in correct relative positions // during leaving transitions const canMove = !removeOnly // 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) { // 如果oldVnode的第一个child不存在 if (isUndef(oldStartVnode)) { // oldStart索引右移 oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left // 如果oldVnode的最后一个child不存在 } else if (isUndef(oldEndVnode)) { // oldEnd索引左移 oldEndVnode = oldCh[--oldEndIdx] // oldStartVnode和newStartVnode是同一个节点 } else if (sameVnode(oldStartVnode, newStartVnode)) { // patch oldStartVnode和newStartVnode， 索引左移，继续循环 patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] // oldEndVnode和newEndVnode是同一个节点 } else if (sameVnode(oldEndVnode, newEndVnode)) { // patch oldEndVnode和newEndVnode，索引右移，继续循环 patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] // oldStartVnode和newEndVnode是同一个节点 } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right // patch oldStartVnode和newEndVnode patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue) // 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后 canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) // oldStart索引右移，newEnd索引左移 oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] // 如果oldEndVnode和newStartVnode是同一个节点 } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left // patch oldEndVnode和newStartVnode patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue) // 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前 canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) // oldEnd索引左移，newStart索引右移 oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] // 如果都不匹配 } else { if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) // 如果未找到，说明newStartVnode是一个新的节点 if (isUndef(idxInOld)) { // New element // 创建一个新Vnode createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) // 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove } else { vnodeToMove = oldCh[idxInOld] /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !vnodeToMove) { warn( 'It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.' ) } // 比较两个具有相同的key的新节点是否是同一个节点 //不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。 if (sameVnode(vnodeToMove, newStartVnode)) { // patch vnodeToMove和newStartVnode patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue) // 清除 oldCh[idxInOld] = undefined // 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm // 移动到oldStartVnode.elm之前 canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) // 如果key相同，但是节点不相同，则创建一个新的节点 } else { // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) } } // 右移 newStartVnode = newCh[++newStartIdx] } } while循环主要处理了以下五种情景： 当新老 VNode 节点的 start 相同时，直接 patchVnode ，同时新老 VNode 节点的开始索引都加 1 当新老 VNode 节点的 end相同时，同样直接 patchVnode ，同时新老 VNode 节点的结束索引都减 1 当老 VNode 节点的 start 和新 VNode 节点的 end 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1 当老 VNode 节点的 end 和新 VNode 节点的 start 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1 如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况： 从旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希表中找到与 newStartVnode 一致 key 的旧的 VNode 节点，再进行patchVnode ，同时将这个真实 dom 移动到 oldStartVnode 对应的真实 dom 的前面 调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置小结 当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁 通过isSameVnode进行判断，相同则调用patchVnode方法 patchVnode做了以下操作： 找到对应的真实dom，称为el 如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点 如果oldVnode有子节点而VNode没有，则删除el子节点 如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点 updateChildren主要做了以下操作： 设置新旧VNode的头尾指针 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作参考 你了解diff算法吗 虚拟DOM &amp; diff算法 虚拟DOM原理的理解 虚拟DOM和DOM-diff 虚拟DOM到底是什么 diff算法详解 Vue底层架构 core watcher vnode diff算法Vue底层架构 数据监听参考 $setVue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？ 受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？通过Vue.set向响应式对象中添加一个property，并确保这个新 property 同样是响应式的，且触发视图更新 1234567891011121314151617181920212223242526// 源码export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any { // target 为数组 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) { // 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误 target.length = Math.max(target.length, key) // 利用数组的splice变异方法触发响应式 target.splice(key, 1, val) return val } // key 已经存在，直接修改属性值 if (key in target &amp;&amp; !(key in Object.prototype)) { target[key] = val return val } const ob = (target: any).__ob__ // target 本身就不是响应式数据, 直接赋值 if (!ob) { target[key] = val return val } // 对属性进行响应式处理 defineReactive(ob.value, key, val) ob.dep.notify() return val} 这里无非再次调用 defineReactive 方法，实现新增属性的响应式，关于defineReactive方法，内部还是通过 Object.defineProperty 实现属性拦截，大致代码如下： 1234567891011121314function defineReactive(obj, key, val) { Object.defineProperty(obj, key, { get() { console.log(`get ${key}:${val}`); return val }, set(newVal) { if (newVal !== val) { console.log(`set ${key}:${newVal}`); val = newVal } } })} 我们阅读以上源码可知，vm.$set 的实现原理是： 如果目标是数组，直接使用数组的 splice 方法触发相应式； 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）","link":"/2022/03/12/Vue/vue-diff/"}],"tags":[{"name":"数据结构&amp;算法","slug":"数据结构-算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"},{"name":"HTML&amp;CSS","slug":"HTML-CSS","link":"/tags/HTML-CSS/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"工程化","slug":"工程化","link":"/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"Safe","slug":"Safe","link":"/tags/Safe/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"}],"categories":[{"name":"数据结构&amp;算法","slug":"Arithmetic","link":"/categories/Arithmetic/"},{"name":"HTML&amp;CSS","slug":"Html-Css","link":"/categories/Html-Css/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"浏览器","slug":"Browser","link":"/categories/Browser/"},{"name":"性能优化","slug":"Optimizing","link":"/categories/Optimizing/"},{"name":"工程化","slug":"Engineering","link":"/categories/Engineering/"},{"name":"网络","slug":"NetWork","link":"/categories/NetWork/"},{"name":"其他","slug":"Other","link":"/categories/Other/"},{"name":"Safe","slug":"Safe","link":"/categories/Safe/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"}]}