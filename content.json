{"pages":[{"title":"关于我","text":"","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/03/07/hello-world/"},{"title":"测试文件","text":"测试测试测试HX22test","link":"/2022/03/08/%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"},{"title":"【译】下一代前端构建工具 ViteJS 中英双语字幕","text":"原视频地址：Next generation frontend tooling with ViteJS ✨ Open Source Friday ✨ 中英文字幕视频地址（B站）：【译】下一代前端工具 ViteJS 中英双语字幕 - Open Source Friday 中英文字幕视频地址（腾讯视频）：【译】下一代前端工具 ViteJS 中英双语字幕 - Open Source Friday 英文字幕：听译、YouTube 自动字幕 英文校对、翻译：Ivocin 视频字幕地址： Vite-Open-Source-Friday 原文链接：【译】下一代前端工具 ViteJS 中英双语字幕 - 掘金 关于 Vite，来看看作者本人怎么说。本视频是 Vue 以及 Vite 作者 尤雨溪 在 2021 年 2 月 12 日在 Twitch 上做客 GitHub Open Source Friday 节目的直播视频。在视频里有尤大关于 Vite 的各项功能的详细阐述、大神在线编码、在线 Debug、大佬 diss webpack 以及对 Vite 的哲学思考。本视频很长，接近 70 分钟，下面是视频摘录，大家可以选择自己感兴趣的点自行传送。强烈建议大家观看视频，里面有很多细节相信大家会有收获。 Vite 的发音问题视频传送 - 1:18 有关 Vite 发音的灵魂拷问：既然 Vite 使用的是其法语发音，那为什么 Vue 不用它的法语发音呢？（大概是因为法语读音不好听吧）。尤大告诉我们，作者说怎么读那就怎么读吧。 个人认为 Vue 和 Vite 的文档堪称良心了，首先就交代自己名字的发音，让全球开发者统一认知。再来看 Svelte，别说发音了，至今拼写还记不住。 Vite 是什么视频传送 - 2:33 尤大自己也说，很难一句话描述清楚 Vite 到底是什么。主要原因可能是它主要包括两个部分，一个基于 ESM 的利用 esbuild 的开发服务器，另一个部分是基于 Rollup 的配置化的打包器。当然还有很多其他强大的功能，但是已经超过一句话了。尤大说市面上最接近 Vite 的产品是 Parcel，但二者的实现原理完全不同。 为什么 Vite 在此刻出现视频传送 - 4:53 本质原因应该是大部分现代浏览器（除了 IE 11）已经对原生 ES 模块支持的很好了，而且新版的 Node 也支持 ESM 了。ESM 终于可以在不久的将来一统江湖。原生的就是香。 起步 Demo视频传送 - 7:05 不使用 @vitejs/create-app，从 0 开始创建一个 Vite 工程 demo。 入口文件是 index.html视频传送 - 14:25 Vite 是 Opinionated 的视频传送 - 17:08 划重点，Vite 是 Opinionated 的，视频里多次展示了这块内容。 其实 opinionated 本来是个贬义词，是固执己见的意思，而用在计算机科学领域，又变成了一个绝对的褒义词，号称自己 opinionated 的工具通过约定保证了易用性，又提供了配置以保证不会丧失灵活性。Vite 中内置了大量最佳实践的约定，省去了繁琐的配置，保证前端开发者常用的功能都是开箱即用的。 关于 Opinionated 的译法可以参考 掘金翻译计划的一个 PR，Vite 中文文档的一个 PR 这两处的讨论。 那么问题来了，列出几个 opinionated 和 unopinionated 的软件。我先来：Opinionated 的有 Vite、Prettier, Unopinionated 的比如 webpack，当然 unopinionated 可不是好词，应该不会有人在官方文档里写自己是 unopinionated 的。 这段是关于 webpack 的，看大佬如何 diss webpack： Vue CLI 会迁移到 Vite 上吗视频传送 - 23:56 暂时不会，目前依然是基于 webpack 的，但是最终肯定是会迁移到 Vite 上的。 Vite 是框架无关的视频传送 - 25:43 Vite 提供了定义得非常好的 JavaScript API，可以在更高层级使用，比如 VitePress，它是 VuePress 的孪生兄弟，基于 Vite 构建。 Tailwind CSS + Vite 实战视频传送 - 27:07 尤大在线编写 Tailwind 代码翻车。 主持人调侃，原来 Evan You 也需要 debug 啊。 Vite + React 实战视频传送 - 35:30 主持人调侃，我们在线围观尤雨溪写 React！ 关于 Esbuild —— “快”就一个字视频传送 - 38:24 Esbuild 是 Vite 为何如此快速的原因，它比传统 tsc 快 20-30 倍。Vite 用 esbuild 替代 Rollup 进行预打包，速度也非常快。 这里尤大透露了他的工作电脑，搭载 M1 芯片的 ARM 架构的 Mac Book Pro，遗憾的是，当时的 esbuild 还不支持 ARM 架构，但 Go 的最新版已经支持。没想到过了几天，esbuild 就发布了其支持 M1 芯片的版本，尤大在第一时间做了测试： DX 是啥视频传送 - 47:36 在视频翻译过程中，听到尤大说了 DX 一词，由于不知道是什么含义，反反复复听了好多遍，后来 Google 发现，原来 DX 是 Developer Experience 的意思，看来关爱开发者是有官方术语的，关于 DX 的解释可以参考 What Is DX? (Developer Experience)。 Vite 利用其快速的特性，极大提升了开发者的体验，尤大直言，他就像被宠坏了的孩子，项目启动超过 1 秒，他就很难忍受了。 关于 SSR视频传送 - 52:20 SSR 目前还处于实验阶段，详见官网文档。 关于 HMR视频传送 - 57:59 Vite 真正解决了 HMR 速度与随着应用越来越大而越来越慢的问题。 为啥生产模式不用 esbuild，不是更快吗？视频传送 - 65:31 其实也想用，但是 esbuild 目前对生产包支持不够健壮，很多配置无法通过 esbuild 实现。所以目前而言，Rollup 是一个好选择，虽然远比 esbuild 慢。 另外，可以用 esbuild 作为压缩器，替代 terser，详见 build.minify,这样会更快，但是包的体积可能会有 5% - 10% 左右的增长，看用户取舍。 后记好久没有做这么大型视频的翻译了，上一次还是 React Conf 2018 的翻译。本视频翻译从春节假期 2 月 15 日开始，开工后时间比较少，断断续续花了三周多时间。好在 GitHub 在 Twitch 视频失效后，视频上传到了 YouTube 上，利用其自动字幕功能，后期节省了很多时间。确实 YouTube 的语音转文字功能更为强大。本视频已经改为外挂字幕重新上传，字幕地址：Vite-Open-Source-Friday，如有问题，欢迎 pr。希望这个视频能够帮助到大家。","link":"/2021/03/08/next_generation_frontend_tooling_with_vitejs/"},{"title":"Hexo Icarus -- 搭建赛博朋克风格个人博客","text":"基于 Hexo ，使用酷炫的 Icarus 主题 且加入众多个性化配置，打造出的个人博客，效果惊艳，让我们从零开始，搭建一个专属自己的 赛博朋克 风格博客吧。 安装Node.js 安装Hexo 引入Icarus主题 个性化配置 创建GitHub个人仓库 绑定仓库 发布文章 Hexo及MarkDown语法 安装插件（评论，统计，分享等） 绑定个人域名 使用图床工具 安装Node.jsHexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包(或者使用 nvm 管理node版本)，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v : 1$ npm -v 安装Hexo初始化项目非常简单，按照 Hexo官网文档 操作即可:使用npm安装Hexo 123$ npm install -g hexo-cli# 更新版本# npm update hexo 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 标准的目录结构如下： 1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 使用 generate 命令生成静态文件，可简写如下： 1$ hexo g 使用 server 命令启动本地服务器查看页面效果，可简写如下： 1$ hexo s 此时，打开 localhost:4000, 一个默认的 landscape 主题的博客页面就出现了，如下： 引入Icarus主题引入主题也非常简单，我们查看 Icarus 主题 。更换主题主要有两种方式，一种是使用 npm 安装主题的方式，另一种是下载源码放到 theme 文件夹的方式。简单起见，我们先采用 npm 的方式： 1$ npm add hexo-theme-icarus 使用 hexo 命令修改主题为 Icarus: 1$ npm hexo config theme icarus 启动服务器，报错如下： 根据提示，添加依赖(提示缺少哪些就安装哪些)： 1$ npm add bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 再次尝试构建并启动，成功出现 Icarus 主题了： 在 _config.icarus.yml 文件中修改： 12# Icarus theme variant, can be &quot;default&quot; or &quot;cyberpunk&quot;$ variant: cyberpunk 再次构建启动，成功出现 赛博朋克 风格主题了： 刚才说到使用 Icarus 主题有两种方式， npm 包的方式虽然简便，但是如果想对 Icarus 主题有更深的配置就不太好弄了，尤其是过去 Icarus 一直都采用的是源码模式，很多 Issue 的解决方案都是修改源码的，而对应的 npm 包的方式则很少提及，所以我们也改为使用源码方式，方便后续配置。 首先删掉 hexo-theme-icarus 依赖，在 Icarus 仓库 下载代码，解压后拷贝到 theme 文件夹中。 个性化配置修改配置文件 _config.yml 和 _config.icarus.yml ，配置网站相关信息。 主要包括 logo、favicon、navbar 的 menu 和 links、footer、donates（赞助信息，注释掉没用的支付渠道）、widgets。 首页如果文章过长，用户向下滚动时就只会看到一篇文章，如果只想让用户看一部分内容怎么办呢？非常简单，在 md 文件中添加 &lt;!– more –&gt; 即可，添加完之后，就会出现“阅读更多”的按钮，首页就能看到多篇文章了。 目前文章页仍然和首页一样，是三栏布局，为了有效利用空间，希望文章页能够两栏布局。此时我们需要在 Icarus 源码文件夹添加 _config.post.yml 文件，并配置成两栏布局： 123456789101112widgets: # Profile widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: toc # Whether to show the index of each heading index: true # Whether to collapse sub-headings when they are out-of-view collapsed: false # Maximum level of headings to show (1-6) depth: 3 看看效果(头像及动态背景后面添加)： 创建GitHub个人仓库登录到 全球最大同性交友网站✨(GitHub),如果没有GitHub帐号，使用你的邮箱注册GitHub帐号(此处不赘述可参考: 廖雪峰老师Git教程)。点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.github.io 这个用户名使用你的GitHub帐号名称代替，这是固定写法，如图： 安装成功后，将你的Git与GitHub帐号绑定，同参考 廖雪峰老师Git教程 。 绑定仓库在 _config.yml 中配置你的 GitHub Pages 对应的仓库地址: 1234deploy: type: git repo: https://github.com/xx/xx.github.io branch: master 其中： type 对应部署的服务器类型，我们这里填写git就可以 repo 对应仓库地址，也就是仓库克隆的地址 branch 不写默认是master，通常我们写成master就可以 如图： 以上配置完成后保存 然后回到终端执行 npm install hexo-deployer-git –save 安装插件，将写好的文章部署到github服务器上并让别人浏览到。安装完成后在终端中依次执行如下代码(为了简单后续统称为三步)： hexo clean 清理缓存，整个public文件删除，简写为 hexo c hexo generate 进行渲染，将source中的文件按照某种规则方式渲染成静态的页面文件放到public中，简写为 hexo g hexo server 部署到本地，简写为 hexo s hexo deploy 将public中文件部署到git服务器，简写为 hexo d 发布文章创建一个自己的文章，建立好的文章在 source/_posts 中： 1hexo new post “文章名字” 注意头部配置文件相关信息，在新版 Icarus 中头图需要额外配置 cover 选项，如下： 1234567891011---title: &quot;hello&quot; # 标题date: 2021/03/08 # 日期categories: # 分类- Front-Endtags: # 标签- GitHubtoc: true # 是否显示目录thumbnail: '' # 缩略图cover: '/img/a.png' # 头图--- 编辑完成后执行上面三步操作，刷新下浏览器即可看到新文章啦. Hexo及MarkDown语法大家可前往对应官网学习 MarkDown基本语法 及 Hexo文档 ⚠️注意：可以将HTML标签添加到任何Markdown文件中使用。如果您更喜欢某些HTML标记而不是Markdown语法，这将很有帮助。例如，有些人发现将HTML标签用于图像更容易。 添加网易云音乐打开网页版的 网易云音乐，选择喜欢的音乐，点击生成外链播放器 可自定义配置： 安装插件（评论，统计，分享等）评论系统Hexo的评论插件官方推荐了disqus，但国内无法访问，不能保证所有人都有克服的方法。所有我们打算采用其他的第三方来实现，市面上产品很多，我们做如下对比： Github类：gitment， gitalk，gitter，风格很像github，评论需要github账号； 基于 leancloud 的无后端评论系统：Valine，需要实名注册leancloud帐号； livere 中文名字叫来必力，是一款韩国的评论系统； 畅言云评，安装需要备案号； disqus 比较大牌的评论系统，服务稳定，唯一的缺点是国内无法使用。 最终，推荐使用 valine 评论系统，操作步骤如下： 注册LeanCloud (https://leancloud.app/)，并实名认证 创建应用，应用名称随便取 点击 设置 &gt; 安全中心 把自己博客网址添加到安全中心，保证数据的调用安全。 点击设置 &gt; 应用Key 复制App ID 和 App Key 修改配置 1234567891011121314151617181920212223 # Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true # 启用 appid: xxx # leancloud应用中的appId 必填 appkey: xxx # leancloud应用中的appKey必填 notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: &quot;&quot; # 可选填 avatar: robohash # 默认头像 avatar_force: false # 可选填 meta: [&quot;nick&quot;, &quot;mail&quot;, &quot;link&quot;] # 可选填 page_size: 10 # 可选填 lang: zh-CN # 可选填 visitor: false # 可选填 highlight: true # 可选填 record_ip: false # 可选填 server_urls: # 可选填 emoji_cdn: # 可选填 emoji_maps: # 可选填 enable_qq: false # 可选填 required_fields: [] 测试valine评论执行 hexo c 三步，重启博客，查看效果，评论的数据存在leancloud应用中，如图： leancloud应用数据： ⚠️注意：在 Front-matter 中通过comments属性设置true或false控制该页面或者是文章的评论功能是否打开，如下： 123456---title: Tagsdate: 2019-12-19 16:10:19type: &quot;tags&quot;comments: false--- 其他个性化设置（统计，分享等），大家可以评论分享，共同探讨。 绑定个人域名域名购买购买渠道有很多，这里以 阿里云的万网域名购买为例，找到合适自己的域名： 选择域名，根据提示绑定邮箱上传实名认证信息，审核通过后即可付款 域名解析域名解析到购买厂商处进行解析，此处在阿里云的 控制台 &gt; 域名 &gt; 域名列表 找到域名右侧对应的解析按钮。点击然后添加解析 按照如下填写添加解析，记得把记录值替换成你自己的博客地址 仓库配置回到github仓库，进入你的仓库设置页面，在添加域名，然后保存即可，github默认在仓库里面创建一个CNAME文件，内容为你的域名，之后就可以通过你的域名访问博客啦。 此处的 Enforce HTTPS 配置，选中时将强制使用HTTPS，您的站点将只通过HTTPS服务，不能使用http服务（后面图床工具中我们将只能使用http，若域名未配置SSL证书），所以会导致图片无法显示 CNAME 即指别名记录，也被称为规范名字。这种记录允你将多个名字映射到同一台计算机。 当需要将域名指向另一个域名，再由另一个域名提供 ip地址，就需要添加 CNAME 记录。 在github中默认生成的CNAME文件，会在下次 hexo d 部署之后丢失，所以，我们可以在项目的 source文件下新建CNAME文件，内容依然是自己的域名，这样每次打包，都会在 public 文件中带有CNAME文件 ⚠️注意：以上步骤完成后可以通过域名访问，但是域名前是http协议，虽说不影响使用和阅读，但如何将自己的博客协议改为Https，可以通过使用一个国外的CDN服务提供商 Cloudflare，详细操作后续补全。 使用图床工具博文中有图片时，若是少量图片，可以直接把存放在source文件夹中，但会占据大量的存储的空间，加载时缓慢 ，所以考虑把博文里的图片上传到某一网站，然后获得外部链接，使用Markdown语法，![图片信息](外部链接) 完成图片的插入，这种网站就被成为图床。常见的简易的图床网站很多，大家有兴趣可以自行搜索，比如 SM.MS ，postimg ，七牛云 等，github也是可以用来当做图床。我们这边以 七牛云 为例。 ⚠️注意：七牛云注册帐号后免费提供一个测试域名，每个域名每日限总流量 10GB，每个测试域名自创建起 30 个自然日后系统会自动回收。所以有长久需求的用户需要自己的个人备案域名。具体步骤如下： 注册七牛云 创建七牛云存储空间 个人域名备案 绑定域名 注册帐号根据提示完成注册绑定邮箱等操作。 创建七牛云存储空间在 控制台 &gt; 对象存储 &gt; 空间管理 中新建存储空间，名称自定义，区域选离自己近的，访问控制可以选公开，若选私有，后续获取图片外链要授权。 ⚠️注意：此处有坑，尽量选择前面的5种，暂时别选华东-浙江2，后面配置PicGo时会有问题。 创建完之后，在 控制台 &gt; CDN &gt; 域名管理 中可看到免费的测试域名： 测试域名有使用限制： 所以需要绑定一个已备案的个人域名： 个人域名备案a. 进入阿里云 控制台 &gt; ICP备案 点击我要备案 b. 根据提示，填写信息 点击 信息校验 ，若报错，则根据提示修改，可以参考ICP备案文档 或右侧智能在线询问。因为域名实名认证通过后还需同步到工信局，需要1-2天时间，所以报如下错： 信息填写完毕之后，需要到app端确认信息 ⚠️注意：其中网站名称及备注等，限制较多词汇，且证件照需要白色背景等，导致阿里初审时可能会不通过，客服会打电话并发邮件通知需修改项，阿里初审通过后需要等待几个工作日工信部审批(我是3天左右)，最后备案成功。 绑定域名域名备案通过之后，即可在七牛云中点击 控制台 &gt; CDN &gt; 域名管理 &gt; 添加域名： 加速域名可以填一个二级域名。即在你的域名（假定为xxxx.com）面前增加一个比如cdn.xxxx.com或者qn.xxxx.com都是可以的，前缀随便输入。 创建完成后，就会有一个CNAME的域名，复制： 到阿里云域名控制台解析DNS增加新的记录（同上面域名解析操作）： 回到七牛云域名列表，可看到状态已成功： 在七牛云 控制台 &gt; 对象存储 &gt; 空间管理 中上传一张图片，复制外链到浏览器看是否成功： 使用图床工具PicGo图传工具就是说可以方便我们上传图片到图床的客户端工具，Mpic 或 PicGo等，我们使用PicGo。可以通过下载PicGo app，因为我主要使用vsCode编辑markdown，所以我们使用vscode PicGo 插件， 安装vscode插件 PicGo： 配置PicGo（绑定七牛云）： 选择七牛云为默认图床 修改其他配置 Access Key 对应 七牛云中 AccessKey Secret Key 对应 七牛云中 SecretKey Bucket 对应 七牛云中 空间名称(以当前博客为例: czh-2) Url 对应 七牛云中 二级域名(以当前博客为例: http://blog.xxx.cn) Area 对应 七牛云中 存储空间内的存储区域 当前插件中 Area 可选项只有5项，对应如图： 七牛云对象存储区域上传表（除华东-浙江2: cn-east-2）: 七牛云可选存储区域： 存储区域若是不能与七牛云匹配，上传图片时会报如下错：PicGo: 上传失败! incorrect region, please use up-cn-east-2.qiniup.com 使用PicGo上传图片 从剪贴板上传快捷键方式，Windows/Unix为 Ctrl + Alt + U，OsX为 Cmd + Opt + U。 从资源管理器选择上传快捷键方式，Windows/Unix为 Ctrl + Alt + E，OsX为 Cmd + Opt + E。 输入本地资源地址上传快捷键方式，Windows/Unix为 Ctrl + Alt + O，OsX为 Cmd + Opt + O。 以上三种方式上传时，若选中文本则以选中文本为上传文件名 其他写到此处，差不到也告一段落，总结一些经验，分享一些有趣的东西，开源精神不灭。希望能给正在阅读文章的你带来一些灵感与帮助。如果有任何疑问或者更好的想法欢迎在评论区交流， 大家一起学习。 —- End —-","link":"/2022/03/12/hexo-site/"},{"title":"理解JS 执行上下文 作用域 闭包","text":"执行上下文作用域闭包 执行上下文(参考文章)什么是执行上下文 执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。 三种执行上下文类型 全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。 函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。 Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里不讨论它。 创建执行上下文 有两个阶段：1) 创建阶段 和 2) 执行阶段 创建阶段 this 值的决定，即我们所熟知的 This 绑定。 创建词法环境组件。（存在差异，还需阅读源码） 创建变量环境组件。 this 绑定：在全局执行上下文中，this 的值指向全局对象。(在浏览器中，this引用 Window 对象)。在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined（在严格模式下）。例如： 12345678910111213let foo = { baz: function() { console.log(this); }}foo.baz(); // 'this' 引用 'foo', 因为 'baz' 被 // 对象 'foo' 调用let bar = foo.baz;bar(); // 'this' 指向全局 window 对象，因为 // 没有指定引用对象 执行阶段 完成对所有这些变量的分配，最后执行代码。 ⚠️注意：在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined。 执行栈什么是执行栈 是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。 引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。 123456789101112131415let a = 'Hello World!';function first() { console.log('Inside first function'); second(); console.log('Again inside first function');}function second() { console.log('Inside second function');}first();console.log('Inside Global Execution Context'); 当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 first() 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。 当从 first() 函数内部调用 second() 函数时，JavaScript 引擎为 second() 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 second() 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 first() 函数的执行上下文。 当 first() 执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。 基本概念 js的执行实际上是放到执行上下文栈的， 执行上下文就是为代码的执行做了一系列准备，包括this和词法环境变量环境等等 执行栈：存放执行上下文的地方，在栈顶的执行上下文就是当前执行上下文，js总会到这里寻找资源。函数执行上下文在执行完毕之后就会从栈顶弹出 创建执行上下文的四种情况：进入全局代码，进入function函数体代码，进入eval函数指定的代码，进入module函数 执行上下文的内部结构：词法环境【环境记录（申明，存放变量与函数的地方）+outer指向(形成作用域链的关键)】+ this绑定(这个就是我们熟悉的this指向)(参考文章) 这里我们把写在环境记录上的变量和函数统称为词法环境 作用域就是解析（查找）变量名的一个集合，就是当前运行上下文（也可以是当前上下文的词法环境) 全局作用域就是全局执行上下文 函数作用域就是函数执行上下文 全局执行上下文中的词法环境 1234567891011121314151617181920212223242526272829console.log(foo);if (true) { var foo = 'foo'}step1:创建执行上下文，并加入栈顶，当前执行上下文就是这个全局执行上下文，在栈顶tips:全局执行上下文的文本环境（花名册）有两部分组成：全局对象（浏览器执行环境就是window对象）以及全局[[scope]] (其实也是一个块作用域，全局的块)两者的区别：var和function声明创建在全局对象中，而let const class声明的变量创建在全局scope中先到全局scope中查找变量，然后再到全局对象中查找 step2:分析：找到所有非函数中的var声明找到所有的顶级函数声明找到let const class声明step3:名字重复处理1.let const class声明的名字之间不能重复2.let const class和var function的名字之间不能重复3.var 和 function名字重复的 functionstep4:创建绑定声明并初始化var为undefined顶级函数声明：申明function名字，并初始化为新创建对象（这里函数的对象就已经创建完成了）块级中函数声明（比如在if块中）：声明名字，初始化为undefined声明let const class 但未初始化,不能使用 所以会报错step5:执行语句 12345678910js中的代码总是遵循先申明再执行的准则，那么在申明的时候var function是申明在全局对象上的，而let const是登录在全局scope上的。var声明放入变量会提升并初始化为undefined,但是let const 也会提升(此处还需仔细探讨![let到底会不会造成变量提升](https://blog.csdn.net/amyleeYMY/article/details/122555195))，只是不会初始化，所以会报错。查找变量的时候总是从全局scope到全局对象上面查找var a = 10function foo() { console.log(a); let a}foo()// Uncaught ReferenceError: Cannot access 'a' before initialization 变量提升与函数提升的机制 块级作用域 块级作用域,不会形成自己的执行上下文，链接在原来的文本环境之前 执行完毕之后就会被销毁 123456let inIf = 'out if statement'if (true) { let inIf = 'in if statement' console.log(inIf); //in if statement}console.log(inIf); //out if statement 判断与我们之前找的var 顶级函数声明 let/const/class声明是否重复 如果重复了，就不做处理如果不重复，就在全局对象中创建一个以函数名命名的变量，并且将其初始化为undefined 12345678910111213141516171819202122232425262728293031323334console.log(foo); //undefinedif (true) { function foo() { console.log('in block'); //in block }}foo()因为块里面是函数，在函数foo执行完毕销毁之前，它会查看全局变量中有没有函数名foo没有的话，不做处理有的话，就会把全局变量中foo的值(undefined)替换 全局对象中已经变成函数对象在块里的函数也是会提升的，只不过它没有立即创建函数，它是undefinedconsole.log(foo);if (false) { // function foo() { // console.log('......'); // }}let foo;// 报错,let声明的变量在全局scope上，foo在全局对象上没有找到foo,于是不做处理var foo// ';;',var声明的变量在全局对象上，foo在全局对象上找到foo,于是在执行结束之前完成赋值if (true) { function foo() { console.log(';;'); }}foo()先申明后使用，申明的地方就是执行上下文 函数作用域 function函数会创建在全局执行上下文的词法环境（全局对象）之中，函数创建的时候就已经完成初始化有函数名了。并且函数创建的时候就会携带一个[[scope]]（类似于一个小背包，记录函数创建的环境）所以所函数在创建的时候体内就保存了它创建时执行上下文的文本环境。等到它执行的时候，会自动找到它的[[scope]],里面保存着创建时的文本环境 函数调用的执行上下文——函数在哪里创建，就保存哪里的运行上下文；函数的作用域是在函数创建的时候决定的而不是调用的时候决定 函数的作用域链是根据函数创建的位置形成的作用域链，这就是所谓的静态作用域，词法作用域 函数 函数创建JS声明函数的三种方式（参考文章）: // 函数表达式(function expression) var h = function() { // h } // 函数声明(function declaration) function h() { // h }1.函数声明: 即上面第二种方式,会声明一个具名函数, 且函数能在其所在作用域的任意位置被调用, 其创建的函数为具名函数, 证明这一点你可以 console.log(h.name); 可以看到打印为 “h”. 可在后面的代码中将此函数通过函数名赋值给变量或者对象属性 2.函数表达式: 即上面第一种方式, 这种方法使用function操作符创建函数, 表达式可以存储在变量或者对象属性里. 函数表达式往往被称为匿名函数, 因为它没有名字. 证明这一点你可以 console.log(h.name); 可以看到打印为空 “” 3.Function()构造器: 不推荐这种用法, 容易出问题 1-函数声明 12345关于函数声明，它最重要的一个特征就是函数声明提升，意思是执行代码之前先读取函数声明。不管函数声明写在前面，还是后面，都会出现函数声明的提升。add(1,2); //弹窗显示：3 function add(x,y){ alert(x+y) } 2-命名函数表达式 12345var add = function(x,y){ alert(x+y) }add(1,2) //弹窗显示：3 这种形式看起来好像是常规的变量赋值语句。但是函数表达式和函数声明的区别在于，函数表达式在使用前必须先赋值。所以这段代码执行的时候就会出错： 12345add(1,2) //无弹窗，报错： add is not a function var add = function(x,y){ alert(x+y) } 造成这种现象是因为解析器在向执行环境中加载数据时，解析器会率先读取函数声明，并使其在执行任何代码前可用；至于函数表达式，则必须等到解析器执行到它的所在的的代码行，才会真正的被解析。函数表达式中，创建的函数叫做匿名函数，因为function关键字后面没有标识符。 1234567891011121314151617181920212223242526272829303132333435363738394041先说两者的显著区别: - 第一种声明方式也就是var声明方式, 函数只有在var语句声明之后才能被调用 - 第二种生命方式也就是function声明方式, 函数可以在function声明之前被调用 这是因为, - 对第一种情况, 函数表达式是在函数运行阶段才赋值给变量h - 对第二种情况, 函数申明是在代码运行阶段之前, 也就是代码解析阶段就赋值给标识符h 可以看下面两个例子: var h = function () { // h } console.log(h) h = function () { // h1 } 打印： ƒ h() { // h } 因为赋值发生在代码运行阶段, 代码自上而下运行console.log(h)所在位置只能获取它之前的赋值 第二种情况： function h() { // h } console.log(h) function h() { // h1 } 打印： ƒ h() { // h1 } 因为赋值发生在代码解析阶段, 代码运行到console.log(h)时解析早已完成, 而解析的结果是后面那个函数h, 故会打印此结果 函数表达式（匿名函数）调用方式： 使用()将匿名函数括起来，然后后面再加一对小括号（包含参数列表）。我们再看一下以下一个例子： 1234567891011121314151617181920212223242526//表达式的调用/*const add = function (x, y){ return x + y;}const sum = add(1, 2)console.log(sum)*///匿名函数式调用//方式1//这种方式尽量少用const sum1 = function(x, y){ return x + y;}(1, 2);//方式2 自执行函数//推荐const sum = (function(x, y){ return x + y;})(1, 2);console.log(sum1);//方式3(new Function(&quot;x&quot;,&quot;y&quot;,&quot;return x+y&quot;))(1,2) 自执行函数，即定义和调用合为一体。我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。 123456789101112131415161718192021// 下面2个括弧()都会立即执行 (function () { /* code */ } ()) // 推荐使用这个 (function () { /* code */ })() // 但是这个也是可以用的 // 由于括弧()和JS的&amp;&amp;，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的 // 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了 var i = function () { return 10; } (); true &amp;&amp; function () { /* code */ } (); 0, function () { /* code */ } (); // 如果你不在意返回值，或者不怕难以阅读// 你甚至可以在function前面加一元操作符号 !function () { /* code */ } (); ~function () { /* code */ } (); -function () { /* code */ } (); +function () { /* code */ } (); // 还有一个情况，使用new关键字,也可以用，但我不确定它的效率 // http://twitter.com/kuvos/status/18209252090847232 new function () { /* code */ } new function () { /* code */ } () // 如果需要传递参数，只需要加上括弧() 函数声明的函数创建过程使用的是当前运行上下文的词法环境，但是命名函数表达式创建过程是在当前运行上下文词法环境之前加了新的词法环境，在自己的词法环境中添加对函数命名funname的绑定，并通过outer与当前运行上下文的词法环境链接起来。funname在函数外是没有定义的 3-new Function创建 只能访问全局变量，所以不管在哪儿创建都类似于在全局环境中创建 函数的执行不同的函数调用方式会给函数传递不同的thisArg值 普通函数包括IIDE：传递undefined 对象方法：传递对象 new方法：传递新创建的对象 不同调用方式的this指向this就是thisBinding，但是它是动态的，它与在哪儿调用密切相关 普通函数调用：undefined(非严格模式下是window) 作为方法调用：指向someObject new function调用：总是指向新创建的newObject call bind apply 指向参数对象 箭头函数与在哪儿创建有关，不能使用call bind apply 闭包 参考 我从来不理解JavaScript闭包，直到有人这样向我解释它… JS 闭包经典使用场景和含闭包必刷题 如果没有闭包的存在，函数执行完了之后，它的词法环境就会被销毁，正是有了闭包的存在，才能在全局环境中引用函数，继而保证整个函数环境的存在（函数体内总是携带着它初始化时的环境）。闭包可以让函数在运行完毕之后，其运行上下文的词法环境仍然能被访问。 123456789function foo() { console.log(a);}function bar() { var a = 3 foo()}var a = 2bar() //2","link":"/2022/03/12/JavaScript/javaScript-bibao/"},{"title":"概括总结 ES6 特性","text":"ES6 参考","link":"/2022/03/12/JavaScript/javaScript-ES6/"},{"title":"Cookie session localStorage sessionStorage的区别","text":"Cookie session localStorage sessionStorage的区别 一、cookie Cookie是服务器发送到用户浏览器并保存在本地的一小块数据。 客户端给服务端发送http请求时，服务端会在响应头里面添加一个 Set-Cookie 选项，浏览器收到响应后通常会保存下 Cookie。浏览器得到Cookie之后，每次请求都要带上Cookie Cookie会被用户篡改 临时Cookie（会话Cookie） 永久Cookie 不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。 设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。 二、session 服务器通过cookie给用户一个sessionID，sessionID对应服务器中的一小块内存。 每次用户访问服务器的时候，服务器通过sessionID 读取对应的session，然后获取用户的隐私信息。 三、localStorage html5提供的一个API而已 永久有效，除非用户主动清除缓存 设置缓存：localStorage.setItem(‘key’, ‘value’);// 获取缓存：localStorage.getItem(‘key’);// 清除缓存：localStorage.removeItem(‘key’)// 删除所有保存的数据localStorage.clear(); 四、sessionStorage sessionStorage用户关闭页面就失效 试题1: Cookie 和 Session 的区别 Cookie则是服务器通过set-cookie头给客户端发送的一段字符串，客户端每次访问同个域名都会带上这串字符串 Session是基于Cookie实现的，通过Cookie向客户端发送SessionID，Cookie进行存储。 cookie是浏览器上的hash表，session是服务器上的hash表。 cookie能被篡改，session更安全。 试题2: Cookie 和 LocalStorage SessionStorage 的区别 cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+ cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除 cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地","link":"/2022/03/12/Other/cookie-storage/"},{"title":"了解 HTTP HTTPS","text":"了解 HTTP HTTPS 一、HTTP和HTTPS简介 http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。 https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。 HTTP 和 HTTPS 的区别 http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。 http 协议的默认端口为 80，https 的默认端口为 443。 http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。 https 缓存不如 http 高效，会增加数据开销。 Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。 SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。 &gt;&gt; TCP三次握手 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包并确认客户的SYN（ack=j+1），同时也发送一个自己的SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。 &gt;&gt; TCP四次挥手 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 从输入URL到页面加载的全过程","link":"/2022/03/12/Other/http/"},{"title":"理解JS Event Loop","text":"Event Loop同步/异步 基本概念执行 &amp; 运行 JavaScript 的执行和运行是两个不同概念的，执行，一般依赖于环境，比如 node、浏览器 等， JavaScript 在不同环境下的执行机制可能并不相同。而今天我们要讨论的 Event Loop 就是 JavaScript 的一种执行方式。而运行呢，是指JavaScript 的解析引擎，这是统一的。 JavaScript Engine 和 JavaScript Runtime 为了让 JavaScript 运行起来，要完成两部分工作（当然实际比这复杂的多）： 编译并执行 JavaScript 代码，完成内存分配、垃圾回收等； 为 JavaScript 提供一些对象或机制，使它能够与外界交互。 这里的第一部分，是 Engine（执行引擎）；第二部分，是 Runtime（执行环境）。 关于 JavaScript JavaScript 是单线程语言，只有一个调用栈，决定了它在同一时间只能做一件事情。 在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！ 在 JavaScript 运行的时候，JavaScript Engine 会创建和维护相应的堆（Heap）和栈（Stack），同时通过 JavaScript Runtime 提供的一系列 API（例如 setTimeout、XMLHttpRequest 等）来完成各种各样的任务。 在 JavaScript 的运行过程中，真正负责执行 JavaScript 代码的始终只有一个线程，通常被称为主线程，各种任务都会用排队的方式来同步执行。这种方式最常见的一个问题就是：如果你尝试执行一段非常耗时的同步代码，浏览器就没办法同时去渲染 GUI，导致界面失去响应，也就是被阻塞了。 事件循环（Event Loop）什么是 Event Loop？ 事件循环（Event Loop） 是让 JavaScript 做到既是单线程，又绝对不会阻塞的核心机制，也是 JavaScript 并发模型（Concurrency Model）的基础，是用来协调各种事件、用户交互、脚本执行、UI 渲染、网络请求等的一种机制。 简单一点：Event Loop 只不过是实现异步的一种机制而已。 JavaScript 有一个主线程 main thread，和调用栈 call-stack 也称之为执行栈。所有的任务都会放到调用栈中等待主线程来执行。 任务队列(task queue)执行和协调各种任务时，Event Loop 会维护自己的任务队列。任务队列又分为 Task Queue 和 Microtask Queue 两种。 实际上，称任务队列为事件队列（Event Queue）可能会更容易理解。所谓的事件驱动（Event-driven），就是将一切抽象为事件（Event），比如 AJAX 完成、鼠标点击、I/O 操作等等，都是一个个的事件，而 Event Loop 就是一个事件循环的过程。同步任务(SyncTask): 主线程来执行的时候立即就能执行的代码异步任务(AsyncTask): 先去执行别的 task，等我这 xxx 完之后再往 Task Queue 里面塞一个 task 的同步任务来等待被执行 主线程自上而下执行所有代码 同步任务直接进入到主线程被执行，而异步任务则进入到 Event Table 并注册相对应的回调函数 异步任务完成后，Event Table 会将这个函数移入 Event Queue 主线程任务执行完了以后，会从Event Queue中读取任务，进入到主线程去执行。 循环如上 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 上述动作不断循环，就是我们所说的事件循环(Event Loop)。 例如： 123456789101112ajax({ url:www.Nealyang.com, data:prams, success:() =&gt; { console.log('请求成功!'); }, error:()=&gt;{ console.log('请求失败~'); }})console.log('这是一个同步任务'); ajax 请求首先进入到 Event Table ，分别注册了onError和onSuccess回调函数。 主线程执行同步任务：console.log(‘这是一个同步任务’); 主线程任务执行完毕，看Event Queue是否有待执行的 task,这里是不断地检查，只要主线程的task queue没有任务执行了，主线程就一直在这等着 ajax 执行完毕，将回调函数push 到Event Queue。（步骤 3、4 没有先后顺序而言） 主线程“终于”等到了Event Queue里有 task可以执行了，执行对应的回调任务。 如此往复。 Task Queue(宏任务队列)一个 Event Loop 会有一个或多个 Task Queue，这是一个先进先出（FIFO）的有序列表，存放着来自不同 Task Source（任务源）的 Task。在 HTML 标准中，定义了几种常见的 Task Source: DOM manipulation（DOM 操作）； User interaction（用户交互）； Networking（网络请求）； History traversal（History API 操作）。 Task Source 的定义非常的宽泛,包括整体代码script，setTimeout，setInterval，常见的鼠标、键盘事件，AJAX，数据库操作（例如 IndexedDB），等等都属于 Task Source，所有来自这些 Task Source 的 Task 都会被放到对应的 Task Queue 中等待处理。 Microtask Queue(微任务队列)Microtask Queue 与 Task Queue 类似，也是一个有序列表。不同之处在于，一个 Event Loop 只有一个 Microtask Queue。在 HTML 标准中，并没有明确规定 Microtask Source，通常认为有以下几种： Promise.then catch finally(注意我不是说 Promise) Process.nextTick MutationObserver setTimeoutsetTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？看一个例子： 12345setTimeout(() =&gt; { task();},3000)console.log('执行console'); 前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是： 12//执行console//task() 去验证一下，结果正确！ 然后我们修改一下前面的代码： 123456setTimeout(() =&gt; { task()},3000)sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明： 123456//代码1console.log('先执行这里');setTimeout(() =&gt; { console.log('执行啦')},0); 1234567//代码2console.log('先执行这里');setTimeout(() =&gt; { console.log('执行啦')},3000); 代码1的输出结果是： 1234//先执行这里//执行啦 代码2的输出结果是： 1234//先执行这里// ... 3s later// 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。 事件循环执行顺序整体script作为第一个宏任务进入主线程执行栈进，将宏任务(例如setTimeout)，其回调函数存放入宏任务队列中，微任务(例如process.nextTick())，将其回调函数存放入微任务队列中（队列：先进先出FIFO），所有异步任务都存在调用栈（栈：后进先出LIFO）中。开始第一次循环，接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。如下： 123456789101112setTimeout(function() { console.log('setTimeout');})new Promise(function(resolve) { console.log('promise'); resolve() // 注意：若无resolve将报错}).then(function() { console.log('then');})console.log('console'); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。结果如下：// promise console then setTimeout 事件循环，宏任务，微任务的关系如图所示： 分析一段较复杂的代码，看看你是否真的掌握了js的执行机制： 12345678910111213141516171819202122232425262728293031323334353637console.log('1');setTimeout(function() { console.log('2'); process.nextTick(function() { console.log('3'); }) new Promise(function(resolve) { console.log('4'); resolve(); }).then(function() { console.log('5') })})process.nextTick(function() { console.log('6');})new Promise(function(resolve) { console.log('7'); resolve();}).then(function() { console.log('8')})setTimeout(function() { console.log('9'); process.nextTick(function() { console.log('10'); }) new Promise(function(resolve) { console.log('11'); resolve(); }).then(function() { console.log('12') })}) 事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。 (请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 参考文章 【THE LAST TIME】彻底吃透 JavaScript 执行机制 这一次，彻底弄懂 JavaScript 执行机制 深入理解 JavaScript Event Loop","link":"/2022/03/12/JavaScript/javaScript-async/"}],"tags":[{"name":"Vite","slug":"Vite","link":"/tags/Vite/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Other","slug":"Other","link":"/tags/Other/"}],"categories":[{"name":"Front-End","slug":"Front-End","link":"/categories/Front-End/"},{"name":"Tools","slug":"Front-End/Tools","link":"/categories/Front-End/Tools/"},{"name":"Hexo","slug":"Front-End/Hexo","link":"/categories/Front-End/Hexo/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Other","slug":"other","link":"/categories/other/"}]}