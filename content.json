{"pages":[{"title":"关于我","text":"","link":"/about/index.html"}],"posts":[{"title":"Hexo Icarus -- 搭建赛博朋克风格个人博客","text":"基于 Hexo ，使用酷炫的 Icarus 主题✨ 且加入众多个性化配置，打造出的个人博客，效果惊艳，让我们从零开始，搭建一个专属自己的 赛博朋克 风格博客吧。 安装Node.js 安装Hexo 引入Icarus主题 个性化配置 创建GitHub个人仓库 绑定仓库 发布文章 Hexo及MarkDown语法 安装插件（评论，统计，分享等） 绑定个人域名 使用图床工具 安装Node.jsHexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包(或者使用 nvm 管理node版本)，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v : 1$ npm -v 安装Hexo初始化项目非常简单，按照 Hexo官网文档 操作即可:使用npm安装Hexo 123$ npm install -g hexo-cli# 更新版本# npm update hexo 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 标准的目录结构如下： 1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 使用 generate 命令生成静态文件，可简写如下： 1$ hexo g 使用 server 命令启动本地服务器查看页面效果，可简写如下： 1$ hexo s 此时，打开 localhost:4000, 一个默认的 landscape 主题的博客页面就出现了，如下： 引入Icarus主题引入主题也非常简单，我们查看 Icarus 主题 。更换主题主要有两种方式，一种是使用 npm 安装主题的方式，另一种是下载源码放到 theme 文件夹的方式。简单起见，我们先采用 npm 的方式： 1$ npm add hexo-theme-icarus 使用 hexo 命令修改主题为 Icarus: 1$ npm hexo config theme icarus 启动服务器，报错如下： 根据提示，添加依赖(提示缺少哪些就安装哪些)： 1$ npm add bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 再次尝试构建并启动，成功出现 Icarus 主题了： 在 _config.icarus.yml 文件中修改： 12# Icarus theme variant, can be &quot;default&quot; or &quot;cyberpunk&quot;$ variant: cyberpunk 再次构建启动，成功出现 赛博朋克 风格主题了： 刚才说到使用 Icarus 主题有两种方式， npm 包的方式虽然简便，但是如果想对 Icarus 主题有更深的配置就不太好弄了，尤其是过去 Icarus 一直都采用的是源码模式，很多 Issue 的解决方案都是修改源码的，而对应的 npm 包的方式则很少提及，所以我们也改为使用源码方式，方便后续配置。 首先删掉 hexo-theme-icarus 依赖，在 Icarus 仓库 下载代码，解压后拷贝到 theme 文件夹中。 个性化配置修改配置文件 _config.yml 和 _config.icarus.yml ，配置网站相关信息。 主要包括 logo、favicon、navbar 的 menu 和 links、footer、donates（赞助信息，注释掉没用的支付渠道）、widgets。 首页如果文章过长，用户向下滚动时就只会看到一篇文章，如果只想让用户看一部分内容怎么办呢？非常简单，在 md 文件中添加 &lt;!– more –&gt; 即可，添加完之后，就会出现“阅读更多”的按钮，首页就能看到多篇文章了。 目前文章页仍然和首页一样，是三栏布局，为了有效利用空间，希望文章页能够两栏布局。此时我们需要在 Icarus 源码文件夹添加 _config.post.yml 文件，并配置成两栏布局： 123456789101112widgets: # Profile widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: toc # Whether to show the index of each heading index: true # Whether to collapse sub-headings when they are out-of-view collapsed: false # Maximum level of headings to show (1-6) depth: 3 看看效果(头像及动态背景后面添加)： 创建GitHub个人仓库登录到 全球最大同性交友网站✨(GitHub),如果没有GitHub帐号，使用你的邮箱注册GitHub帐号(此处不赘述可参考: 廖雪峰老师Git教程)。点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.github.io 这个用户名使用你的GitHub帐号名称代替，这是固定写法，如图： 安装成功后，将你的Git与GitHub帐号绑定，同参考 廖雪峰老师Git教程 。 绑定仓库在 _config.yml 中配置你的 GitHub Pages 对应的仓库地址: 1234deploy: type: git repo: https://github.com/xx/xx.github.io branch: master 其中： type 对应部署的服务器类型，我们这里填写git就可以 repo 对应仓库地址，也就是仓库克隆的地址 branch 不写默认是master，通常我们写成master就可以 如图： 以上配置完成后保存 然后回到终端执行 npm install hexo-deployer-git –save 安装插件，将写好的文章部署到github服务器上并让别人浏览到。安装完成后在终端中依次执行如下代码(为了简单后续统称为三步)： hexo clean 清理缓存，整个public文件删除，简写为 hexo c hexo generate 进行渲染，将source中的文件按照某种规则方式渲染成静态的页面文件放到public中，简写为 hexo g hexo server 部署到本地，简写为 hexo s hexo deploy 将public中文件部署到git服务器，简写为 hexo d 发布文章创建一个自己的文章，建立好的文章在 source/_posts 中： 1hexo new post “文章名字” 注意头部配置文件相关信息，在新版 Icarus 中头图需要额外配置 cover 选项，如下： 1234567891011---title: &quot;hello&quot; # 标题date: 2021/03/08 # 日期categories: # 分类- Front-Endtags: # 标签- GitHubtoc: true # 是否显示目录thumbnail: '' # 缩略图cover: '/img/a.png' # 头图--- 编辑完成后执行上面三步操作，刷新下浏览器即可看到新文章啦. Hexo及MarkDown语法大家可前往对应官网学习 MarkDown基本语法 及 Hexo文档 ⚠️注意：可以将HTML标签添加到任何Markdown文件中使用。如果您更喜欢某些HTML标记而不是Markdown语法，这将很有帮助。例如，有些人发现将HTML标签用于图像更容易。 添加网易云音乐打开网页版的 网易云音乐，选择喜欢的音乐，点击生成外链播放器 可自定义配置： 安装插件（评论，统计，分享等）评论系统Hexo的评论插件官方推荐了disqus，但国内无法访问，不能保证所有人都有克服的方法。所有我们打算采用其他的第三方来实现，市面上产品很多，我们做如下对比： Github类：gitment， gitalk，gitter，风格很像github，评论需要github账号； 基于 leancloud 的无后端评论系统：Valine，需要实名注册leancloud帐号； livere 中文名字叫来必力，是一款韩国的评论系统； 畅言云评，安装需要备案号； disqus 比较大牌的评论系统，服务稳定，唯一的缺点是国内无法使用。 最终，推荐使用 valine 评论系统，操作步骤如下： 注册LeanCloud (https://leancloud.app/)，并实名认证 创建应用，应用名称随便取 点击 设置 &gt; 安全中心 把自己博客网址添加到安全中心，保证数据的调用安全。 点击设置 &gt; 应用Key 复制App ID 和 App Key 修改配置 1234567891011121314151617181920212223 # Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true # 启用 appid: xxx # leancloud应用中的appId 必填 appkey: xxx # leancloud应用中的appKey必填 notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: &quot;&quot; # 可选填 avatar: robohash # 默认头像 avatar_force: false # 可选填 meta: [&quot;nick&quot;, &quot;mail&quot;, &quot;link&quot;] # 可选填 page_size: 10 # 可选填 lang: zh-CN # 可选填 visitor: false # 可选填 highlight: true # 可选填 record_ip: false # 可选填 server_urls: # 可选填 emoji_cdn: # 可选填 emoji_maps: # 可选填 enable_qq: false # 可选填 required_fields: [] 测试valine评论执行 hexo c 三步，重启博客，查看效果，评论的数据存在leancloud应用中，如图： leancloud应用数据： ⚠️注意：在 Front-matter 中通过comments属性设置true或false控制该页面或者是文章的评论功能是否打开，如下： 123456---title: Tagsdate: 2019-12-19 16:10:19type: &quot;tags&quot;comments: false--- 加密插件参考文章对 Hexo 博客文章进行加密 ⚠️注意：部署后需使用https协议，问题参考 密码之后没反应 console报错如下 其他个性化设置（统计，分享等），大家可以评论分享，共同探讨。 绑定个人域名域名购买购买渠道有很多，这里以 阿里云的万网域名购买为例，找到合适自己的域名： 选择域名，根据提示绑定邮箱上传实名认证信息，审核通过后即可付款 域名解析域名解析到购买厂商处进行解析，此处在阿里云的 控制台 &gt; 域名 &gt; 域名列表 找到域名右侧对应的解析按钮。点击然后添加解析 按照如下填写添加解析，记得把记录值替换成你自己的博客地址 仓库配置回到github仓库，进入你的仓库设置页面，在添加域名，然后保存即可，github默认在仓库里面创建一个CNAME文件，内容为你的域名，之后就可以通过你的域名访问博客啦。 此处的 Enforce HTTPS 配置，选中时将强制使用HTTPS，您的站点将只通过HTTPS服务，不能使用http服务（后面图床工具中我们将只能使用http，若域名未配置SSL证书），所以会导致图片无法显示 CNAME 即指别名记录，也被称为规范名字。这种记录允你将多个名字映射到同一台计算机。 当需要将域名指向另一个域名，再由另一个域名提供 ip地址，就需要添加 CNAME 记录。 在github中默认生成的CNAME文件，会在下次 hexo d 部署之后丢失，所以，我们可以在项目的 source文件下新建CNAME文件，内容依然是自己的域名，这样每次打包，都会在 public 文件中带有CNAME文件 ⚠️注意：以上步骤完成后可以通过域名访问，但是域名前是http协议，虽说不影响使用和阅读，但如何将自己的博客协议改为Https，可以通过使用一个国外的CDN服务提供商 Cloudflare，详细操作后续补全。 使用图床工具博文中有图片时，若是少量图片，可以直接把存放在source文件夹中，但会占据大量的存储的空间，加载时缓慢 ，所以考虑把博文里的图片上传到某一网站，然后获得外部链接，使用Markdown语法，![图片信息](外部链接) 完成图片的插入，这种网站就被成为图床。常见的简易的图床网站很多，大家有兴趣可以自行搜索，比如 SM.MS ，postimg ，七牛云 等，github也是可以用来当做图床。我们这边以 七牛云 为例。 ⚠️注意：七牛云注册帐号后免费提供一个测试域名，每个域名每日限总流量 10GB，每个测试域名自创建起 30 个自然日后系统会自动回收。所以有长久需求的用户需要自己的个人备案域名。具体步骤如下： 注册七牛云 创建七牛云存储空间 个人域名备案 绑定域名 注册帐号根据提示完成注册绑定邮箱等操作。 创建七牛云存储空间在 控制台 &gt; 对象存储 &gt; 空间管理 中新建存储空间，名称自定义，区域选离自己近的，访问控制可以选公开，若选私有，后续获取图片外链要授权。 ⚠️注意：此处有坑，尽量选择前面的5种，暂时别选华东-浙江2，后面配置PicGo时会有问题。 创建完之后，在 控制台 &gt; CDN &gt; 域名管理 中可看到免费的测试域名： 测试域名有使用限制： 所以需要绑定一个已备案的个人域名： 个人域名备案a. 进入阿里云 控制台 &gt; ICP备案 点击我要备案 b. 根据提示，填写信息 点击 信息校验 ，若报错，则根据提示修改，可以参考ICP备案文档 或右侧智能在线询问。因为域名实名认证通过后还需同步到工信局，需要1-2天时间，所以报如下错： 信息填写完毕之后，需要到app端确认信息 ⚠️注意：其中网站名称及备注等，限制较多词汇，且证件照需要白色背景等，导致阿里初审时可能会不通过，客服会打电话并发邮件通知需修改项，阿里初审通过后需要等待几个工作日工信部审批(我是3天左右)，最后备案成功。 绑定域名域名备案通过之后，即可在七牛云中点击 控制台 &gt; CDN &gt; 域名管理 &gt; 添加域名： 加速域名可以填一个二级域名。即在你的域名（假定为xxxx.com）面前增加一个比如cdn.xxxx.com或者qn.xxxx.com都是可以的，前缀随便输入。 创建完成后，就会有一个CNAME的域名，复制： 到阿里云域名控制台解析DNS增加新的记录（同上面域名解析操作）： 回到七牛云域名列表，可看到状态已成功： 在七牛云 控制台 &gt; 对象存储 &gt; 空间管理 中上传一张图片，复制外链到浏览器看是否成功： 使用图床工具PicGo图传工具就是说可以方便我们上传图片到图床的客户端工具，Mpic 或 PicGo等，我们使用PicGo。可以通过下载PicGo app，因为我主要使用vsCode编辑markdown，所以我们使用vscode PicGo 插件， 安装vscode插件 PicGo： 配置PicGo（绑定七牛云）： 选择七牛云为默认图床 修改其他配置 Access Key 对应 七牛云中 AccessKey Secret Key 对应 七牛云中 SecretKey Bucket 对应 七牛云中 空间名称(以当前博客为例: czh-2) Url 对应 七牛云中 二级域名(以当前博客为例: http://blog.xxx.cn) Area 对应 七牛云中 存储空间内的存储区域 当前插件中 Area 可选项只有5项，对应如图： 七牛云对象存储区域上传表（除华东-浙江2: cn-east-2）: 七牛云可选存储区域： 存储区域若是不能与七牛云匹配，上传图片时会报如下错：PicGo: 上传失败! incorrect region, please use up-cn-east-2.qiniup.com 使用PicGo上传图片 从剪贴板上传快捷键方式，Windows/Unix为 Ctrl + Alt + U，OsX为 Cmd + Opt + U。 从资源管理器选择上传快捷键方式，Windows/Unix为 Ctrl + Alt + E，OsX为 Cmd + Opt + E。 输入本地资源地址上传快捷键方式，Windows/Unix为 Ctrl + Alt + O，OsX为 Cmd + Opt + O。 以上三种方式上传时，若选中文本则以选中文本为上传文件名 其他写到此处，差不到也告一段落，总结一些经验，分享一些有趣的东西，开源精神不灭。希望能给正在阅读文章的你带来一些灵感与帮助。如果有任何疑问或者更好的想法欢迎在评论区交流， 大家一起学习。 —- End —-","link":"/2022/03/12/Hexo/hexo-site/"},{"title":"V8垃圾回收","text":"V8垃圾回收机制 浏览器内核 浏览器中存在 渲染引擎（负责渲染页面） 和 JavaScript引擎（负责js执行）。以Chrome为例：渲染引擎为 Blink(13 年之前使用的是 Safari 的 Webkit, Blink 是谷歌与欧朋一起搞的) 以及 Javascript引擎： V8 内存 计算机五大硬件之一存储器的核心之一。分别为：运算器，控制器，存储器（内部存储，外部存储），输入设备（键盘鼠标等），输出设备（打印机等） 内部分配栈 简单说，栈内存，小且存储连续，操作起来简单方便，一般由系统自动分配，自动回收，所以文章内所说的垃圾回收，都是基于堆内存。 堆 堆内存 大(相对于栈内存)且不连续 V8 中内存分类 （堆内存） 在讲内存分配之前，先了解一下弱分代假说，V8 的垃圾回收主要建立在这个假说之上。 概念： 绝大部分的对象生命周期都很短，即存活时间很短 生命周期很长的对象，基本都是常驻对象 基于以上两个概念，将内存分为 新生代 (new space)与老生代 (old space) 两个区域。划重点，记一下。 垃圾产生&amp;为何回收JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。常见的内存泄漏： 意外声明的全局变量 被遗忘的定时器 使用不当的闭包 未清理的 DOM 引用 垃圾回收( Garbage Collection 简称 GC ) GC 即 Garbage Collection （垃圾回收），程序工作过程中会产生很多 垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 GC 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，GC 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 垃圾回收机制 了 新生代 新生代算法为 Scavenge 算法，分为 From区 和 To区，广度优先 首先，V8 引擎中的垃圾回收器检测到 from space 空间快达到上限了，此时要进行一次垃圾回收了 从根部开始遍历，不可达对象(即无法遍历到对象)就标记，可达的对象不标记然后复制到to区 清除 from space 中的数据，同时将 from space 置为空闲状态，即变为 to space ,对应的 to space 变为 from space，俗称翻转 当然优秀的 V8 是不可能容忍，一个对象来回的在 form space 和 to space 中蹦跶的，当经历一次 form =&gt; to 翻转之后，发现某些未被标记的对象居然还在，会直接扔到老生代里面去，好似后浪参加比赛，晋级了，优秀的嘞。 除了上面一种情况，还有一个情况也会晋级，当一个对象，在被复制的时候，大于 to space 空间的 25% 的时候，也会晋级了，这种自带背景的选手，那是不敢动的，直接晋级到老生代。 老生代 老生代回收算法为：标记和清除/整理（mark-sweep/mark-compact）。深度优先 标记过程中，引入三色： 白色： 未被标记的对象，即不可达对象（没有扫描到的对象），可回收 灰色： 已被标记，可达对象，未扫描完，不可回收 黑色： 已被编辑，可达对象，扫描完，不可回收 过程： 首先将所有的非根部对象全部标记为白色，然后使用深度优先遍历，是深度优先哈，和新生代不一样哈，按深度优先搜索沿途遍历，将访问到的对象，直接压入栈中，同时将标记结果放在 marking bitmap (灰色) 中，一个对象遍历完成，直接出栈，同时在 marking bitmap 中记录为黑色，直到栈空为止 标记完成后，接下来就是等待垃圾回收器来清除了，清除完了之后，会在原来的内存区域留下一大堆不连续的空间，小对象还好说，这个时候如果来一个稍微大一点的对象，没有内存可以放的下这个傻大个了，怎么办？只能触发 GC，但是吧，原来清除的不连续的空间加起来又可以放的下这个傻大个，很可惜啊，启动一次 GC 性能上也是嗖嗖的往下掉啊；V8 能容许这样的事发生？肯定不存在嘛！ 所以在清除完之后，新生代中对象，再一次分配到老生带并且内存不足的时候，会优先触发标记整理（mark-compact）, 在标记结束后，他会将可达对象(黑色)，移到内存的另一端，其他的内存空间就不会被占用，直接释放，等下次再有对象晋升的时候，轻松放下。 参考 V8 引擎垃圾回收与内存分配 一文搞懂V8引擎的垃圾回收","link":"/2022/04/12/Browser/V8/"},{"title":"概括总结 ES6 特性","text":"ES6 参考 1.5万字概括ES6全部特性(已更新ES2020)","link":"/2022/03/12/JavaScript/javaScript-ES6/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/03/07/hello-world/"},{"title":"理解JS Event Loop","text":"Event Loop同步/异步 基本概念执行 &amp; 运行 JavaScript 的执行和运行是两个不同概念的，执行，一般依赖于环境，比如 node、浏览器 等， JavaScript 在不同环境下的执行机制可能并不相同。而今天我们要讨论的 Event Loop 就是 JavaScript 的一种执行方式。而运行呢，是指JavaScript 的解析引擎，这是统一的。 JavaScript Engine 和 JavaScript Runtime 为了让 JavaScript 运行起来，要完成两部分工作（当然实际比这复杂的多）： 编译并执行 JavaScript 代码，完成内存分配、垃圾回收等； 为 JavaScript 提供一些对象或机制，使它能够与外界交互。 这里的第一部分，是 Engine（执行引擎）；第二部分，是 Runtime（执行环境）。 关于 JavaScript JavaScript 是单线程语言，只有一个调用栈，决定了它在同一时间只能做一件事情。 在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！ 在 JavaScript 运行的时候，JavaScript Engine 会创建和维护相应的堆（Heap）和栈（Stack），同时通过 JavaScript Runtime 提供的一系列 API（例如 setTimeout、XMLHttpRequest 等）来完成各种各样的任务。 在 JavaScript 的运行过程中，真正负责执行 JavaScript 代码的始终只有一个线程，通常被称为主线程，各种任务都会用排队的方式来同步执行。这种方式最常见的一个问题就是：如果你尝试执行一段非常耗时的同步代码，浏览器就没办法同时去渲染 GUI，导致界面失去响应，也就是被阻塞了。 事件循环（Event Loop）什么是 Event Loop？ 事件循环（Event Loop） 是让 JavaScript 做到既是单线程，又绝对不会阻塞的核心机制，也是 JavaScript 并发模型（Concurrency Model）的基础，是用来协调各种事件、用户交互、脚本执行、UI 渲染、网络请求等的一种机制。 简单一点：Event Loop 只不过是实现异步的一种机制而已。 JavaScript 有一个主线程 main thread，和调用栈 call-stack 也称之为执行栈。所有的任务都会放到调用栈中等待主线程来执行。 任务队列(task queue)执行和协调各种任务时，Event Loop 会维护自己的任务队列。任务队列又分为 Task Queue 和 Microtask Queue 两种。 实际上，称任务队列为事件队列（Event Queue）可能会更容易理解。所谓的事件驱动（Event-driven），就是将一切抽象为事件（Event），比如 AJAX 完成、鼠标点击、I/O 操作等等，都是一个个的事件，而 Event Loop 就是一个事件循环的过程。同步任务(SyncTask): 主线程来执行的时候立即就能执行的代码异步任务(AsyncTask): 先去执行别的 task，等我这 xxx 完之后再往 Task Queue 里面塞一个 task 的同步任务来等待被执行 主线程自上而下执行所有代码 同步任务直接进入到主线程被执行，而异步任务则进入到 Event Table 并注册相对应的回调函数 异步任务完成后，Event Table 会将这个函数移入 Event Queue 主线程任务执行完了以后，会从Event Queue中读取任务，进入到主线程去执行。 循环如上 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 上述动作不断循环，就是我们所说的事件循环(Event Loop)。 例如： 123456789101112ajax({ url:www.Nealyang.com, data:prams, success:() =&gt; { console.log('请求成功!'); }, error:()=&gt;{ console.log('请求失败~'); }})console.log('这是一个同步任务'); ajax 请求首先进入到 Event Table ，分别注册了onError和onSuccess回调函数。 主线程执行同步任务：console.log(‘这是一个同步任务’); 主线程任务执行完毕，看Event Queue是否有待执行的 task,这里是不断地检查，只要主线程的task queue没有任务执行了，主线程就一直在这等着 ajax 执行完毕，将回调函数push 到Event Queue。（步骤 3、4 没有先后顺序而言） 主线程“终于”等到了Event Queue里有 task可以执行了，执行对应的回调任务。 如此往复。 Task Queue(宏任务队列)一个 Event Loop 会有一个或多个 Task Queue，这是一个先进先出（FIFO）的有序列表，存放着来自不同 Task Source（任务源）的 Task。在 HTML 标准中，定义了几种常见的 Task Source: DOM manipulation（DOM 操作）； User interaction（用户交互）； Networking（网络请求）； History traversal（History API 操作）。 Task Source 的定义非常的宽泛,包括整体代码script，setTimeout，setInterval，常见的鼠标、键盘事件，AJAX，数据库操作（例如 IndexedDB），等等都属于 Task Source，所有来自这些 Task Source 的 Task 都会被放到对应的 Task Queue 中等待处理。 Microtask Queue(微任务队列)Microtask Queue 与 Task Queue 类似，也是一个有序列表。不同之处在于，一个 Event Loop 只有一个 Microtask Queue。在 HTML 标准中，并没有明确规定 Microtask Source，通常认为有以下几种： Promise.then catch finally(注意我不是说 Promise) Process.nextTick MutationObserver setTimeoutsetTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？看一个例子： 12345setTimeout(() =&gt; { task();},3000)console.log('执行console'); 前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是： 12//执行console//task() 去验证一下，结果正确！ 然后我们修改一下前面的代码： 123456setTimeout(() =&gt; { task()},3000)sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明： 123456//代码1console.log('先执行这里');setTimeout(() =&gt; { console.log('执行啦')},0); 1234567//代码2console.log('先执行这里');setTimeout(() =&gt; { console.log('执行啦')},3000); 代码1的输出结果是： 12//先执行这里//执行啦 代码2的输出结果是： 123//先执行这里// ... 3s later// 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。 事件循环执行顺序整体script作为第一个宏任务进入主线程执行栈进，将宏任务(例如setTimeout)，其回调函数存放入宏任务队列中，微任务(例如process.nextTick())，将其回调函数存放入微任务队列中（队列：先进先出FIFO），所有异步任务都存在调用栈（栈：后进先出LIFO）中。开始第一次循环，接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。如下： 123456789101112setTimeout(function() { console.log('setTimeout');})new Promise(function(resolve) { console.log('promise'); resolve() // 注意：若无resolve将报错}).then(function() { console.log('then');})console.log('console'); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。结果如下：// promise console then setTimeout 事件循环，宏任务，微任务的关系如图所示： 分析一段较复杂的代码，看看你是否真的掌握了js的执行机制： 12345678910111213141516171819202122232425262728293031323334353637console.log('1');setTimeout(function() { console.log('2'); process.nextTick(function() { console.log('3'); }) new Promise(function(resolve) { console.log('4'); resolve(); }).then(function() { console.log('5') })})process.nextTick(function() { console.log('6');})new Promise(function(resolve) { console.log('7'); resolve();}).then(function() { console.log('8')})setTimeout(function() { console.log('9'); process.nextTick(function() { console.log('10'); }) new Promise(function(resolve) { console.log('11'); resolve(); }).then(function() { console.log('12') })}) 事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。 (请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 参考文章 【THE LAST TIME】彻底吃透 JavaScript 执行机制 这一次，彻底弄懂 JavaScript 执行机制 深入理解 JavaScript Event Loop","link":"/2022/03/12/JavaScript/javaScript-async/"},{"title":"call apply bind","text":"call apply bind 三者的区别:1）三者都可以显式绑定函数的this指向2）三者第一个参数都是this要指向的对象，若该参数为undefined或null，this则默认指向全局window3）传参不同：apply是数组、call是参数列表，而bind可以分为多次传入，实现参数的合并4）call、apply是立即执行，bind是返回绑定this之后的函数，如果这个新的函数作为构造函数被调用，那么this不再指向传入给bind的第一个参数，而是指向新生成的对象 手写call: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 手写callFunction.prototype.Call = function(context, ...args) { // context为undefined或null时，则this默认指向全局window if (context === undefined || context === null) { context = window; } // 利用Symbol创建一个唯一的key值，防止新增加的属性与obj中的属性名重复 let fn = Symbol(); // this指向调用call的函数 context[fn] = this; // 隐式绑定this，如执行obj.foo(), foo内的this指向obj let res = context[fn](...args); // 执行完以后，删除新增加的属性 delete context[fn]; return res;};// apply与call相似，只有第二个参数是一个数组，Function.prototype.Apply = function(context, args) { if (context === undefined || context === null) { context = window; } let fn = Symbol(); context[fn] = this; let res = context[fn](...args); delete context[fn]; return res;};// bind要考虑返回的函数，作为构造函数被调用的情况Function.prototype.Bind = function(context, ...args) { if (context === undefined || context === null) { context = window; } let fn = this; let f = Symbol(); const result = function(...args1) { if (this instanceof fn) { // result如果作为构造函数被调用，this指向的是new出来的对象 // this instanceof fn，判断new出来的对象是否为fn的实例 this[f] = fn; let res = this[f](...args, ...args1); delete this[f]; return res; } else { // bind返回的函数作为普通函数被调用时 context[f] = fn; let res = context[f](...args, ...args1); delete context[f]; return res; } }; // 如果绑定的是构造函数 那么需要继承构造函数原型属性和方法 // 实现继承的方式: 使用Object.create result.prototype = Object.create(fn.prototype); return result;}; 参考 深入理解 JavaScript 原型)","link":"/2022/05/12/JavaScript/javaScript-call-apply-bind/"},{"title":"理解JS 执行上下文 作用域 闭包","text":"执行上下文作用域闭包 执行上下文(参考文章)什么是执行上下文 执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。 三种执行上下文类型 全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。 函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。 Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里不讨论它。 创建执行上下文 有两个阶段：1) 创建阶段 和 2) 执行阶段 创建阶段 this 值的决定，即我们所熟知的 This 绑定。 创建词法环境组件。（存在差异，还需阅读源码） 创建变量环境组件。 this 绑定：在全局执行上下文中，this 的值指向全局对象。(在浏览器中，this引用 Window 对象)。在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined（在严格模式下）。例如： 12345678910111213let foo = { baz: function() { console.log(this); }}foo.baz(); // 'this' 引用 'foo', 因为 'baz' 被 // 对象 'foo' 调用let bar = foo.baz;bar(); // 'this' 指向全局 window 对象，因为 // 没有指定引用对象 执行阶段 完成对所有这些变量的分配，最后执行代码。 ⚠️注意：在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined。 执行栈什么是执行栈 是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。 引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。 123456789101112131415let a = 'Hello World!';function first() { console.log('Inside first function'); second(); console.log('Again inside first function');}function second() { console.log('Inside second function');}first();console.log('Inside Global Execution Context'); 当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 first() 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。 当从 first() 函数内部调用 second() 函数时，JavaScript 引擎为 second() 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 second() 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 first() 函数的执行上下文。 当 first() 执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。 基本概念 js的执行实际上是放到执行上下文栈的， 执行上下文就是为代码的执行做了一系列准备，包括this和词法环境变量环境等等 执行栈：存放执行上下文的地方，在栈顶的执行上下文就是当前执行上下文，js总会到这里寻找资源。函数执行上下文在执行完毕之后就会从栈顶弹出 创建执行上下文的四种情况：进入全局代码，进入function函数体代码，进入eval函数指定的代码，进入module函数 执行上下文的内部结构：词法环境【环境记录（申明，存放变量与函数的地方）+outer指向(形成作用域链的关键)】+ this绑定(这个就是我们熟悉的this指向)(参考文章) 这里我们把写在环境记录上的变量和函数统称为词法环境 作用域就是解析（查找）变量名的一个集合，就是当前运行上下文（也可以是当前上下文的词法环境) 全局作用域就是全局执行上下文 函数作用域就是函数执行上下文 全局执行上下文中的词法环境 1234567891011121314151617181920212223242526272829console.log(foo);if (true) { var foo = 'foo'}step1:创建执行上下文，并加入栈顶，当前执行上下文就是这个全局执行上下文，在栈顶tips:全局执行上下文的文本环境（花名册）有两部分组成：全局对象（浏览器执行环境就是window对象）以及全局[[scope]] (其实也是一个块作用域，全局的块)两者的区别：var和function声明创建在全局对象中，而let const class声明的变量创建在全局scope中先到全局scope中查找变量，然后再到全局对象中查找 step2:分析：找到所有非函数中的var声明找到所有的顶级函数声明找到let const class声明step3:名字重复处理1.let const class声明的名字之间不能重复2.let const class和var function的名字之间不能重复3.var 和 function名字重复的 functionstep4:创建绑定声明并初始化var为undefined顶级函数声明：申明function名字，并初始化为新创建对象（这里函数的对象就已经创建完成了）块级中函数声明（比如在if块中）：声明名字，初始化为undefined声明let const class 但未初始化,不能使用 所以会报错step5:执行语句 12345678910js中的代码总是遵循先申明再执行的准则，那么在申明的时候var function是申明在全局对象上的，而let const是登录在全局scope上的。var声明放入变量会提升并初始化为undefined,但是let const 也会提升(此处还需仔细探讨[let到底会不会造成变量提升](https://blog.csdn.net/amyleeYMY/article/details/122555195))，只是不会初始化，所以会报错。查找变量的时候总是从全局scope到全局对象上面查找var a = 10function foo() { console.log(a); let a}foo()// Uncaught ReferenceError: Cannot access 'a' before initialization 变量提升与函数提升的机制 块级作用域 块级作用域,不会形成自己的执行上下文，链接在原来的文本环境之前 执行完毕之后就会被销毁 123456let inIf = 'out if statement'if (true) { let inIf = 'in if statement' console.log(inIf); //in if statement}console.log(inIf); //out if statement 判断与我们之前找的var 顶级函数声明 let/const/class声明是否重复 如果重复了，就不做处理如果不重复，就在全局对象中创建一个以函数名命名的变量，并且将其初始化为undefined 12345678910111213141516171819202122232425262728293031323334console.log(foo); //undefinedif (true) { function foo() { console.log('in block'); //in block }}foo()因为块里面是函数，在函数foo执行完毕销毁之前，它会查看全局变量中有没有函数名foo没有的话，不做处理有的话，就会把全局变量中foo的值(undefined)替换 全局对象中已经变成函数对象在块里的函数也是会提升的，只不过它没有立即创建函数，它是undefinedconsole.log(foo);if (false) { // function foo() { // console.log('......'); // }}let foo;// 报错,let声明的变量在全局scope上，foo在全局对象上没有找到foo,于是不做处理var foo// ';;',var声明的变量在全局对象上，foo在全局对象上找到foo,于是在执行结束之前完成赋值if (true) { function foo() { console.log(';;'); }}foo()先申明后使用，申明的地方就是执行上下文 函数作用域 function函数会创建在全局执行上下文的词法环境（全局对象）之中，函数创建的时候就已经完成初始化有函数名了。并且函数创建的时候就会携带一个[[scope]]（类似于一个小背包，记录函数创建的环境）所以所函数在创建的时候体内就保存了它创建时执行上下文的文本环境。等到它执行的时候，会自动找到它的[[scope]],里面保存着创建时的文本环境 函数调用的执行上下文——函数在哪里创建，就保存哪里的运行上下文；函数的作用域是在函数创建的时候决定的而不是调用的时候决定 函数的作用域链是根据函数创建的位置形成的作用域链，这就是所谓的静态作用域，词法作用域 函数 函数创建JS声明函数的三种方式（参考文章）: // 函数表达式(function expression) var h = function() { // h } // 函数声明(function declaration) function h() { // h }1.函数声明: 即上面第二种方式,会声明一个具名函数, 且函数能在其所在作用域的任意位置被调用, 其创建的函数为具名函数, 证明这一点你可以 console.log(h.name); 可以看到打印为 “h”. 可在后面的代码中将此函数通过函数名赋值给变量或者对象属性 2.函数表达式: 即上面第一种方式, 这种方法使用function操作符创建函数, 表达式可以存储在变量或者对象属性里. 函数表达式往往被称为匿名函数, 因为它没有名字. 证明这一点你可以 console.log(h.name); 可以看到打印为空 “” 3.Function()构造器: 不推荐这种用法, 容易出问题 1-函数声明 12345关于函数声明，它最重要的一个特征就是函数声明提升，意思是执行代码之前先读取函数声明。不管函数声明写在前面，还是后面，都会出现函数声明的提升。add(1,2); //弹窗显示：3 function add(x,y){ alert(x+y) } 2-命名函数表达式 12345var add = function(x,y){ alert(x+y) }add(1,2) //弹窗显示：3 这种形式看起来好像是常规的变量赋值语句。但是函数表达式和函数声明的区别在于，函数表达式在使用前必须先赋值。所以这段代码执行的时候就会出错： 12345add(1,2) //无弹窗，报错： add is not a function var add = function(x,y){ alert(x+y) } 造成这种现象是因为解析器在向执行环境中加载数据时，解析器会率先读取函数声明，并使其在执行任何代码前可用；至于函数表达式，则必须等到解析器执行到它的所在的的代码行，才会真正的被解析。函数表达式中，创建的函数叫做匿名函数，因为function关键字后面没有标识符。 1234567891011121314151617181920212223242526272829303132333435363738394041先说两者的显著区别: - 第一种声明方式也就是var声明方式, 函数只有在var语句声明之后才能被调用 - 第二种生命方式也就是function声明方式, 函数可以在function声明之前被调用 这是因为, - 对第一种情况, 函数表达式是在函数运行阶段才赋值给变量h - 对第二种情况, 函数申明是在代码运行阶段之前, 也就是代码解析阶段就赋值给标识符h 可以看下面两个例子: var h = function () { // h } console.log(h) h = function () { // h1 } 打印： ƒ h() { // h } 因为赋值发生在代码运行阶段, 代码自上而下运行console.log(h)所在位置只能获取它之前的赋值 第二种情况： function h() { // h } console.log(h) function h() { // h1 } 打印： ƒ h() { // h1 } 因为赋值发生在代码解析阶段, 代码运行到console.log(h)时解析早已完成, 而解析的结果是后面那个函数h, 故会打印此结果 函数表达式（匿名函数）调用方式： 使用()将匿名函数括起来，然后后面再加一对小括号（包含参数列表）。我们再看一下以下一个例子： 1234567891011121314151617181920212223242526//表达式的调用/*const add = function (x, y){ return x + y;}const sum = add(1, 2)console.log(sum)*///匿名函数式调用//方式1//这种方式尽量少用const sum1 = function(x, y){ return x + y;}(1, 2);//方式2 自执行函数//推荐const sum = (function(x, y){ return x + y;})(1, 2);console.log(sum1);//方式3(new Function(&quot;x&quot;,&quot;y&quot;,&quot;return x+y&quot;))(1,2) 自执行函数，即定义和调用合为一体。我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。 123456789101112131415161718192021// 下面2个括弧()都会立即执行 (function () { /* code */ } ()) // 推荐使用这个 (function () { /* code */ })() // 但是这个也是可以用的 // 由于括弧()和JS的&amp;&amp;，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的 // 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了 var i = function () { return 10; } (); true &amp;&amp; function () { /* code */ } (); 0, function () { /* code */ } (); // 如果你不在意返回值，或者不怕难以阅读// 你甚至可以在function前面加一元操作符号 !function () { /* code */ } (); ~function () { /* code */ } (); -function () { /* code */ } (); +function () { /* code */ } (); // 还有一个情况，使用new关键字,也可以用，但我不确定它的效率 // http://twitter.com/kuvos/status/18209252090847232 new function () { /* code */ } new function () { /* code */ } () // 如果需要传递参数，只需要加上括弧() 函数声明的函数创建过程使用的是当前运行上下文的词法环境，但是命名函数表达式创建过程是在当前运行上下文词法环境之前加了新的词法环境，在自己的词法环境中添加对函数命名funname的绑定，并通过outer与当前运行上下文的词法环境链接起来。funname在函数外是没有定义的 3-new Function创建 只能访问全局变量，所以不管在哪儿创建都类似于在全局环境中创建 函数的执行不同的函数调用方式会给函数传递不同的thisArg值 普通函数包括IIDE：传递undefined 对象方法：传递对象 new方法：传递新创建的对象 不同调用方式的this指向this就是thisBinding，但是它是动态的，它与在哪儿调用密切相关 普通函数调用：undefined(非严格模式下是window) 作为方法调用：指向someObject new function调用：总是指向新创建的newObject call bind apply 指向参数对象 箭头函数与在哪儿创建有关，不能使用call bind apply 闭包 参考 我从来不理解JavaScript闭包，直到有人这样向我解释它… JS 闭包经典使用场景和含闭包必刷题 如果没有闭包的存在，函数执行完了之后，它的词法环境就会被销毁，正是有了闭包的存在，才能在全局环境中引用函数，继而保证整个函数环境的存在（函数体内总是携带着它初始化时的环境）。闭包可以让函数在运行完毕之后，其运行上下文的词法环境仍然能被访问。 123456789function foo() { console.log(a);}function bar() { var a = 3 foo()}var a = 2bar() //2","link":"/2022/03/12/JavaScript/javaScript-bibao/"},{"title":"new","text":"new new一个对象，到底发生什么？ 1）创建一个对象，该对象的原型指向构造函数的原型2）调用该构造函数，构造函数的this指向新生成的对象3）判断构造函数是否有返回值，如果有返回值且返回值是一个对象或一个方法，则返回该值；否则返回新生成的对象 构造函数有返回值的案例: 123456function Dog(name) { this.name = name; return { test: 1 };}let obj = new Dog(&quot;ming&quot;);console.log(obj); // {test:1} 手写new: 12345678function selfNew(fn, ...args) { // 创建一个instance对象，该对象的原型是fn.prototype let instance = Object.create(fn.prototype); // 调用构造函数，使用apply，将this指向新生成的对象 let res = fn.apply(instance, args); // 如果fn函数有返回值，并且返回值是一个对象或方法，则返回该对象，否则返回新生成的instance对象 return typeof res === &quot;object&quot; || typeof res === &quot;function&quot; ? res : instance;} 参考 「历时8个月」10万字前端知识体系总结（基础知识篇）🔥","link":"/2022/03/12/JavaScript/javaScript-new/"},{"title":"节流 &amp; 防抖","text":"节流 &amp; 防抖 节流和防抖的区别节流：事件触发后，立即执行且n秒内只执行一次 防抖：事件触发后，等待n秒执行，n秒内再次触发，则取消上次，执行最后一次 节流和防抖的使用场景节流：表单重复提交，按钮高频点击，滚动加载 防抖：搜索框自动搜索，输入框校验，窗口大小改变重新渲染 节流和防抖的实现123456789101112131415# 节流函数 一个函数执行一次后，只有大于设定的执行周期才会执行第二次。有个需要频繁触发的函数，出于优化性能的角度，在规定时间内，只让函数触发的第一次生效，后面的不生效。# @param fn要被节流的函数# @param delay规定的时间function throttle(delay){ let lastTime = 0 return function (){ let nowTime = Date.now() if(nowTime - lastTime &gt; delay){ # 修正this指向问题 fn.call(this) lastTime = nowTime } }} 12345678910111213141516171819# 防抖函数 一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效# @param fn要被防抖的函数# @param delay规定的时间function debounce(delay){ let timer = null return function (){ # 清除上一次的演示器 clearTimeout(timer) timer = setTimeout(()=&gt;{ # 修正this指向问题 fn.apply(this) },delay) }}document.getElementById('btn').onclick = debounce(function () { console.log('按钮被点击了' + Date.now());}, 1000);","link":"/2022/03/12/JavaScript/javaScript-throttle/"},{"title":"原型 &amp; 原型链","text":"原型 &amp; 原型链 参考 深入理解 JavaScript 原型 「历时8个月」10万字前端知识体系总结（基础知识篇）🔥","link":"/2022/03/12/JavaScript/javaScript-prototype/"},{"title":"Cookie session localStorage sessionStorage的区别","text":"Cookie session localStorage sessionStorage的区别 一、cookie Cookie是服务器发送到用户浏览器并保存在本地的一小块数据。 客户端给服务端发送http请求时，服务端会在响应头里面添加一个 Set-Cookie 选项，浏览器收到响应后通常会保存下 Cookie。浏览器得到Cookie之后，每次请求都要带上Cookie Cookie会被用户篡改 临时Cookie（会话Cookie） 永久Cookie 不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。 设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。 二、session 服务器通过cookie给用户一个sessionID，sessionID对应服务器中的一小块内存。 每次用户访问服务器的时候，服务器通过sessionID 读取对应的session，然后获取用户的隐私信息。 三、localStorage html5提供的一个API而已 永久有效，除非用户主动清除缓存 设置缓存：localStorage.setItem(‘key’, ‘value’);// 获取缓存：localStorage.getItem(‘key’);// 清除缓存：localStorage.removeItem(‘key’)// 删除所有保存的数据localStorage.clear(); 四、sessionStorage sessionStorage用户关闭页面就失效 试题1: Cookie 和 Session 的区别 Cookie则是服务器通过set-cookie头给客户端发送的一段字符串，客户端每次访问同个域名都会带上这串字符串 Session是基于Cookie实现的，通过Cookie向客户端发送SessionID，Cookie进行存储。 cookie是浏览器上的hash表，session是服务器上的hash表。 cookie能被篡改，session更安全。 试题2: Cookie 和 LocalStorage SessionStorage 的区别 cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+ cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除 cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地","link":"/2022/03/12/NetWork/cookie-storage/"},{"title":"了解 HTTP HTTPS","text":"了解 HTTP HTTPS » HTTP和HTTPS http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。 https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。 HTTP 和 HTTPS 的区别 http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。 http 协议的默认端口为 80，https 的默认端口为 443。 http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。 https 缓存不如 http 高效，会增加数据开销。 Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。 SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。 » TCP三次握手 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包并确认客户的SYN（ack=j+1），同时也发送一个自己的SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。 » TCP四次挥手 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 » 从输入URL到页面加载的全过程 查找缓存 浏览器缓存 系统缓存 路由缓存 DNS域名解析 浏览器向DNS服务器发送请求，根据域名解析ip地址，DNS服务器基于UDP，因此会用到 UDP协议 建立TCP连接 三次握手 发起HTTP请求 服务器响应并返回结果 服务器发送相应的html文件给浏览器 关闭TCP连接 四次挥手 浏览器渲染 解析html文件内容并渲染 构建DOM树 构建CSS规则树 构建render树 布局 绘制 js引擎解析 调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等） » 参考 ☞ : 🔥 连八股文都不懂还指望在前端混下去么","link":"/2022/03/12/NetWork/http/"},{"title":"部署vue项目至服务器","text":"部署vue项目至服务器 步骤如下 下载 finalShell 点击文件夹点击ssh连接 名称 自定义 主机 服务器公网ip 连接名 root 密码 服务器登记密码 点击确认 接受并保存 进入命令界面 安装PCRE pcre-devel 和Zlib 可能还需安装GCC和OpenSSL 安装 Nginx 版本不对可能会报错（可以通过注释 -Wrong 或者 换版本 解决） 目前是 1.16.1 123456789101112131415161718192021222324252627# 下载[root@iZbp1e31bqkj6opg1bsdr0Z ~]# wget -c https://nginx.org/download/nginx-1.14.0.tar.gz# 解压并进入nginx目录[root@iZbp1e31bqkj6opg1bsdr0Z ~]# tar -zxvf nginx-1.14.0.tar.gz[root@iZbp1e31bqkj6opg1bsdr0Z ~]# cd nginx-1.14.0# 使用nginx的默认配置, 编译安装./configuremakemake install# 查找nginx位置[root@iZbp1e31bqkj6opg1bsdr0Z ~]# whereis nginx# 进入 nginx sbin 文件下启动[root@iZbp1e31bqkj6opg1bsdr0Z ~]# cd /usr/local/nginx[root@iZbp1e31bqkj6opg1bsdr0Z nginx]# cd sbin/[root@iZbp1e31bqkj6opg1bsdr0Z sbin]# ./nginx# 查看启动状态[root@iZbp1e31bqkj6opg1bsdr0Z sbin]# ps -ef|grep nginx# root 600651 1 0 13:57 ? 00:00:00 nginx: master process ./nginx# nobody 600652 600651 0 13:57 ? 00:00:00 nginx: worker process# root 665038 658796 0 14:35 pts/0 00:00:00 grep --color=auto nginx# 验证你的nginx.conf文件是否是正确的, 文件位置 /usr/local/nginx/conf[root@iZbp1e31bqkj6opg1bsdr0Z sbin]# ./nginx -t# nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok# nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful# 修改nginx.conf文件[root@iZbp1e31bqkj6opg1bsdr0Z nginx]# cd conf[root@iZbp1e31bqkj6opg1bsdr0Z conf]# vim /nginx.conf 浏览器输入服务器IP(公网IP)即可看到页面 若nginx启动成功，浏览器无法访问，可能是防火墙开了 服务器端口配置的不与.conf中一致（以我为例：服务器是22，.conf为80），修改conf或者服务器端口设置（阿里云服务器可设置一段区间都可访问） 打包个人vue项目 打包配置可能需设置 将dist文件放入nginx目录下 finalShell 无法直接上传文件夹，只能单文件（文档写的是支持的，可能是操作问题） 因为第一步的问题，所以我手动新建 dist 文件夹，再把 vue 打包的dist文件中单个文件共同上传至该文件夹中 修改.conf中访问文件的目录 12345location / { # root后默认是html root /usr/local/nginx/dist; index index.html index.html;} 重启nginx [root@iZbp1e31bqkj6opg1bsdr0Z sbin]# ./nginx -s reload 访问浏览器即可看到vue项目 完结linux服务器安装nginx以及vue项目打包部署(Mac)","link":"/2022/03/12/Other/nginx/"},{"title":"常见知识点汇总","text":"165d50f05814027fb7fe5e4ae8a088d829f96e3a1515b3df41063f132a3914ad9b36fd3758d13b07932d7c1410f1e84b6e35ce0794f98d746a18571012d14dcbd2ecda21e7914dddd82f7e15467ebe58bab0651ee3ce91318056e61547ce77833d0b54753e0095b6c2ee6cac3879645afc074cb758ca4ee5b928d8752283ce95d37cddcf7fc66ea2a40f080db3f8471d4502264dbdf8723f36d60061a33c01cbe8468d93ae7ee409d6ef9d66bcdccee73a95bebb2e87996ecac9e441e41ee6dfd9ab850412d461ab9fcf732296412e683a3df4ed71a6e5d745ba6ae7046b0e7546038712164cf61a196da9d24c637c2c380f1a2a7bd1a67d387b252517ef41f92b0d3582cb65e5d283c22ed3890dc890ed00e429550846d457a0a3710a4f39ed8c9afa9fb8c0d6584aa05b57025570e87e0948572e4e2a953a5a292040c303eb223007312f68b0abfad0aa4d56ae4aefece5392898b9b5b5b0e4d49c9dd3c393f828a4c30e2cc6a30919f94c2c8121fb00dc555ee50e887289b761de898fd706e3cc3a6d02b1c04c6f0dbef59ff748e6eb0b42d269479ef3cd996982c58d140239c90e013012ad4e3dcccb706f2b88cb6702bb81f76a970447e495794da5cf3907d83720aa03762bd251b5536e9d4431239048c5b5715744ac33d2d3655b1cf33c988ef2b5ee93e6a3b97d056bd7e7ed142f13d61e47be172962396d370b11842910282aad86486cb9393a27a63ac9dbbdc2b565c8242bc597758e2a60916864aeb492f7e0cc1375fce659a652d755973d0c6a5647b449c6a383fb66556fd9149f17043d333f34aea7614e8fff76b84975fe6514f0901138bc66ba15f694c310daa7e8d93da0e8de8ca9da0cc9d44afe5c7bdcc01dfbb721fa724f59c6ca93fa9f3109d11e260a15d4f7e860543852a0c5e14fb7b33550d13ca6912bf0088db5f40c2dd81fd5f19e76986eabbf33a08239df8c85b4c4ded38ea90b7414847a1a44afdbda9a6bb20b85130b030a8628dcbcfd6a1f35f5bb96d468b0f574057be25e6cac521c97bdc65327b7376675680622bd0bf3658b4b77ac8a21e05d64e7eef2e08cfb14008caf54effc1feb9925355319798ac570fbe0ac6de0d95d48d59ea494ad5631298db7ad24804cd2ba2f4bb6155064427afb7816db2285f5dd36203db47374d518a0e485effc67ed223797c29548541543375246b684f5cc47ed39315d9b2fca1b540e6a52a01ec012cdf9e9459bfd6f97ec3e02d8ca7d7ab050aca5cbbc19e664951aefce1ed344ed329f068e281ff9d977e90ebcc33b2fefb3b63ac82603afa041199193d64cb07974cf8050e07ced5112bd8ad37a0f21b56e85800eb01744fd222f4ff99659749964a4ac466e045deaeb3e0bc5f9c6449db81c316b8076ad8f6d242031420b4cd021b0fcce2ab214099e27af326b970ff7501ecc8faa203e766d550663b54a448f682554aca5dafca548dafaf1853be80085ed093f430ae2bf1d7dc4ab653307975c8fc9d6db798f106224094dcc3afc2fddaa459761f6fc18aa59d55ebaa9efa892159a396dee601415525b491ca3aa37bd85e92a6879c6b059449cbb5501e524be46adc748126b87785289e074c50c37319482f8a978ebed284944965df25368afb7e9ee89f0393f935b3f759aa3d942fc494f2d248ad302a8cf1c7a7594bb83bdeba49020079ca87b7056cc41122698d97d8fb55cee594aa41a04c18c3184110835788152b40692115c4f53136c799a2d17c9e51017a5267e6e27b24b2faa58173a7e0efc56b5465ba60e8796d9ecdd1178a5f86139db92a2d551c47635d9d505c8940606a290730da1118515c9b612a42366567428f56d455baa0f107c876e545f8168fb6550c863fe53b72a71656fe8bb02894c4199f68b02cd2023e3c1ad0b00c2249c9e248c8bc539a2aeef3531f5882f6a19fbf8fdbae8d1481707b6935f8c46c98582ebe40880cc545cfa47d77aea087265ee0391caeab4bf533e2bb41364bcef54c6e49c9f516ab51d119530f1d6eb74f48a691d907236452cedce524bc06d0d037b3cdd74359749ef3cf9bf2fb45e90e79fef9702947b9d4f98f54fed9710fddd9d64bf4b406e8cf575287d39cbef9eeb6628145bc24984a35cabf24fa86425a29d83ec123c9b6bbf33901df92ff8037dbb3d3ff62f233e0c29ca61e59390a5f0c147dc1801698a127355c43c9fb712b8982316c47c5e41c71427d02f02ecfb218e59828a9ec255c51a89e9e417e83ea681145a55e9a351ff8dd8309b8b1074647101b2048de1bcb8196c3e2a73f0aa6165552e4e095cf1282cc3e0fc4c6e68727d185c445838d861c4119e7049665ec00f4ae598bc8d8c55f6b072f5ba98886b1e907e172afd7741191dd71ac69a38717fd5e09c6606ce14f4bc1dc08a957678280806e609b5849c6d6ef6a13e86fd8c1a9a7cc260fc10fb8e9f18f0562d5a14a39745a42232ad5a17b41af18a48b34498171694d5f30647ad43f6d4b247527760535f4142eca53b9416ac330a4a174db6cc06569f742309e647e1adaf58ce8de197c7a4d32cad6e79acbc7050acdc4e6bae846426f86bb6185fe58b7bf7dcb187daa4da687d7f514baf5c59631d9920be6e593f00da74db5e00309d0f2af40c712c8b35f611e3305b965b4cb81dacbce2328af765065cd0e85198d35afdf91d394309b8a94b2f9cb9b7facc5a2747fd7f445dcd39687da5c0b0d627e11b219c971979e3feaa41d3cced1016438186a4954e39be03302b7797d25d306ca9867dbd837e7589ed042a732e038be6c2832a8997111a2d2c2ac9dbc2911b4a096f7273274b5005da704e3cdcf65f1419b18b5e5b88ec618ab8f5e7f674036ea226c2a85f4d4848d5ca195c9d3487cb616266ba1da0fc2a3fd74d65f7f058751712b3e1e641bab354a6fe9918b470d1653b2b0adac2d852e8c06f7dfbed9a1840dc7d5258209ec74a99fa408c251ea4a43d587ac1dffba8f51be86c649609b5cceba777aed1d722da5bc27db22446dd85f8e2ebec7f193cee844285fb278af950662d2c46b4b5446076a538700f66f8c282b7210cdb59fce7b35cfec8b47364c2a22ffab8d2ad9dba54e57592eeb94dae95302d2e30eae75fd6511faab81efdf1fc96a6db25112c0471c460c8513db9b26c443b5810127482b46c2c50c862ed77a119375ceb7e8cb6de370b8c0478b2275232b2b06e8deae3eb7bb24d4e64b33cee04ca9bb0a8663da5d8d69407bc5e16f7d71fa117d2d717a85c7e04527c6bc4188452e5761344b545aec7f641ef8337b8f600a2197b9d469a32898d75272820b73c7d646cb09007f59000dfeacc5b14006bfbf110db33f69107e86cfeacf40d61d484eb3cd47c56fe21388548fe0f2e9b5a798a389d2f252aaf60ffa8474bfeb654635892a103e48db29107c4921ca6eb5487f92c252e10e635e7a0032bedc8323d45f03a85c2cf29813ca13ff10643726133d3155d7bd1d1a068928676acf1f097319ed0681e5cba69ae3da406caa9d782ee0e3661cafbb92f004385cb6856d42f0eea830adc9e1f94a9a597372abdde750c00c58b370e4494fdca19170ee1e2c5277efbffdeb0ec588b305ad9afc861a51e9a3e8e9ce66c47e552d97563aa4f1c4b42789978fd5c642b9a1a9034264e66b1ea53f6407dceeee9cf9ba94c38910a068c506b6b863b48cd3f30e9dc7176bbe0496e3fa9d037a7fd5da33f978b47547b87d1733e8820eeca9b02868a794b3302e8a5c217f74bfe41d76529ceea51c9d10dfdfd3216ee937e9bb6b3db6005f748920db1432dc413049a79b6c5419455d5695745641dbbe5874ab04f4995524ecddd6f3bab4b10b0d2025452dd48e58bd072f3d5978fb5e6764e66808e1af3f6bedd388d54b34aac9aa0283716da741b9956fb1649534fbf0d8992dd6f3ae82e96c88c6541a444d6442690ec258246812a349ed5a75a1bb442281ab4ce7756c07217f11e2eef3228c3308285ffb80e2764e302c4af17a7c99f49aeaa6e82ae44c24c76d34e83381a3e39244ce2eab943907292cb61bc38edb724cf7f6060ca0a27dff6e0e1638058a8aac7534018868eacdf1b85535001f0e18c09c42f92d888a2dc81c3e4bd343f16878917dce48fcf5b9f2d07d186d0da6d3589c45dd14ee767a8ea689d0bad5a808fc0f4adb68287b159563dd7484cfd286d7dab9f5cfa9da405e7a64a5724227a9da14857f73de0696287a24ee79429d3185e68ddd80f82cd0c52322ea20a4dc929dc1cf61c5df2eb00828dbbd2375cc05614dff179960d79683516666b2f8f245389b658e807a77229989353db1a096cf8d853e11d59e5b326a5a2b76fdb0eab1d001e07f7af27197c15431e753b0eac35f67cb90d13320933031a71b471e108197d35b54e52f156338bf17735ab834fb02f09342b521509dd0fa64b641608cdf304b54d7ab69bc94cae5e2a0cf515ffcf731550f03c15e8349a69a1349d6d7dfe0bdf93dd09669fe5a34796d9b9e7aa7164882dee88aa5ef5717c20bf7ff288fa33bf88bd106c6f5322a07fa0c3485d6bb0faffc42a7dbdbd32255add951b77c8d7d83a904ccb09fe570015d553ef0c6ba11a7b27db90e6192473463dc6c100099573b4dfbd2113d60c78cd2aa0a9d44857179085f74f90f92dab02ac702ccacd4bac57c26bf735e3a772f802b9c95d6eccce9c8d169a30fbf647e05b2fc24af02290ae212fe0dd6a079d8455f91d7c29654f8812d7b2580756e073b07e0f4df8061de1ec6acdfcf1ac1967a62f99ea110f4ed1665f88460f92081149838f2fd078d1aae989077aad5bf7b645be55bd7fe2ab28a392bab597c1a5b70b4f795b83d809de391cfba2dd8de6df551fecddb2a7fc1db3a08692353648220e1442d94f76df36b5683e216088dfec3ca92c4774a048f6d5ba09b358161c1a89b8ab98d989c9e48592bdf6b533af60674e669e590060145023b32023e6cf3de8ee8698fa8cdb6ef57cdbe5bf81e38f90c606eb5a7f7a5bc3d97ecac9356c5ee265578f682464f735065bb3d1590f20e84bc9d5937fc5fc392d37ed20f14c5e4e7b561c01eaa9e65fd464a22558998d4a93c66951f7a2157f8de011d7605d021e41cd9ce1b429d5b9ee45eec30841905d82ea7f6d6797fc50adca36ad1802bac4ba550eda52e4b1b800e2e1366a7757fffb9dcd64ed8ea7d165ee0fabec9e971ae69aa9a2ae45d9522f54ca25017a9bfef0b3f0f9de91ac391bd21c6c3c030ecd64b3717378fbde590be2379049d0d6f31db5d5a1c08d32a0a3c6097e1f8283cefd08e2cd40422468ec8afa62ef5bc8fb8169309be29ed5587a2b17fcebca10b6e3068f14dcc7567d652c572c024340febcda2ba69a52e69b8ce474f105774a349f41cd388d73790951f0593e62c071eb053f979921e49725eeb92853bf41c4932bf2adf46afa875682edc459aa76b70e556562b7bc823a7dab15a6fb8e9520a15831eb523ed7d370deff7c67385f37c614390e83726ab31fd221222363f65f37f5d5301915fa47cb683cadc299de15717af81fb2496caafed39e5999162889f85836e9fbc7ad04d7d1e6665f2100ebf5d81f24d5cfdb45d394a0159b83cbcedb9d4727506f4b2b376e04d961c5d329fb977b0a3e74cff990aeefb8f54a1d69a090b573189e83c821061506eb5070675c2adfc32b1b2fd3734b72b0a1437d1e0bb9a0dd4089a4fcf578967b26f20bb20a858873ceb39b984f8f14eca4a962fab8efdcfa344214d67ad22cbb1010d87d6b4499f308015859d4108a26a6a045223d05e56a93c82987f9a853d231b02f4c2ec64522151c7de02ad4d026dd3393d348144db62c2f06c523ddb412bd259cc037afb8834f71791bb8c7a2b60e01c35aa5cc74295257f4cd7faf25610301476ee66c3455b99712bbc5abd6925b09d81d3a000d1f63e680a8644691ddfc61f4c116a4f89b62c1e5813d9b9af56ea47b8af7ceec35895c5bfc252ae0697e4689a800737bd666c30e01f1e5ade05b724e20d635fd3f51a8f94c353aa0e2ce17c9be747a892ee0947f547ae7f71c366587e62228fa92dc8ce6bf5071b47f800eb626ed9341f8307bd145759c097dfb13ad342da05d0430cf257f2033825b6da16d73dec8218c886d8d53bbc81f83c4a5a0d2a70dd5b643bf41ea05b8040d615b409c8d9c06f3eb7fcd84a23a7817189b580b44a38bb9123342861fea9bb308f8829eaad3c63242062c966d64c24dddb0ecd9442b4d3af7822e8f994ec84874a7bf27410cb4b99d690ba36d7c0400d4775075bd6aacd4bf6741134169614f2c6619d8512585b404aa7c9c4972b149a6ba845e9be38d14cb5afcffd0147aeaaf7b5366135400a35e5dcf35b693000b72349ff0eec0fa9eb14c512eb9771766c14eb9c88dcd482136bf19367fa4b75a63277c1eaaee6f21fd5cae19dce49a396bfab8397c018a56119bcf7ef55432ae5657a2d10db8c9badcdfeab0a223467c5d185697270af4ab153b72a8c9bf926dcbbf0f9e7955998a06347b6b494a82fbd5d22d8b5e8b334cb2b0be23843b2d19b50f86bd338597281e76dec3d006fb76e3f80b0e7be33a46ac95cc2189dfed68906bde2e7751a799af12cb3b51c49f3a86ea4a044241c75a4f8fae815d3593da772c1df16dbbee8d94c70abb19d16fe9ac232a6ee8be59785e331d289bc512c995772ea1d8e52e359bd46ad5594d7924ea6d3689b514a44411770feabf6f359f9e682a9f0d94a8529a25bb0fc87f4a55df969c55adca3da3f47d18e7ab4603e27af8ba3a7d2c09e27e9ea724e00d4316c0f41b140d78f05cb24f63771535ccda7c720e9bf71c23bc3b82359a6381a1a5086005e1233f5e9f017d9b2e101a34f8abbd58132e72c75931747001c98bc3e19ddaeb64252b0f30e5a2b467534a72fdc09de266251ffa06c04f0ee380e317ff661f626593beb9b9190f2b8a5c4356f46948e6551f62899cb116036f0837409791f517293c5d2e9e2a6b9ef17d27c5b9119315da76fc2f02b2df97204e7ba89efdec37f567ec46a72a9cfe10a18c2188aec3fc786a11cda00a9b03415a08efe3a774ce7fa457134798f551fb2404352683e68065c62032aa2d3bbad5a846075ad76ee62e0f2dd637b5bb48d95a79e5eccfb6a4edf92f3b750eb9cebebe2ffc7ca332331448e2742ad35052c03617c125bce2792e6f6e1d64c3938f7154e44e298210298bf813abfdc7e262f0a32ce666d5c60952674f36f8f194973238647d0ed45bdb673b7343d8a58e8c176fa8bfbb4e54e8530b2b06f45cbb40dc2fa6846d929bf3a0ed9b825aaf3d23b9209ff01f48df7e63ac551b9721066999dc8b2ed5b2109f1ffbe6fe9b4202ba9bb87f8e7498db6482385819b988649223418b51460ef895997e6c6122ac209d0bbd6a3d9993c1a09c49a244b57879b96805fcdbbac8a2a847a7fb368039a68422979b4ac53d19836ff184b4a9f8fe357d7c588463dc0119f607dea91b92f6e644cab54b395c3521e4cab33455df41f88f53ff365a205c8a6b2600b422720db6aa0679d5942b11da6df8317b396f02e44d07a68bb0f64220483413ee06e8828aa9335159f63db4703439ecf7dd61bf486ec289599221f6ad9047eaf12e141fce10e2a8df4f9f860c578df0053ce5c5d0d6c4cb70800b571c7f60febc3306d972aec6d4c5ca0e201a9f67bc718530b4ac2dbc196d35ec0d02c015fb1e6fefa5f9ffbdc4e77e2e60999ac9a31af89d3ba21c86e3e50080a7d687ae2c1b93b24f93aebf33ee36ab9d92610cac1b768a639b2b44f9bd2093d5ca640e6a4498d1ea66f647dc34299fa81e68c2acbe27e0be0fe928ce3b6bb713849ef31fbe19f57ddd8340ccb37b272feb998c264aea4833ce21f752d72b161cd6a93a48e019d097e9632778f97c68f6ad46ee8af815930c1ce3c027ee82147329841a6fa6899ea35f409000cf9b1c01fa58039ca516abc90cab3501fbe0f03b6ece91cf06afc1d05dd8663a05d12da9f36f4b1d367ea6c058a403f4f5297b559441d25eacac1557a543579b58dc1187bb8669a1bbad1d3fd853b66eb8fd60cee1f9076d1bc89e1c3d97506e6b14609cdaabe357b5f26d582a10762b5709501174ce036c8f4c9e0b8c50bec17cfb0e4a0fb3ffc9cbfb940ae65fff24e10a7ad3420a46147c6cbb1debda88b9b44779507e10a5df4771807dc73583e9815bf047a7312e555f6af9bfedf0f12ecde5b3e14f5f7e616a14a5a5e740bfea0524ec1c03dbe35a6fa51e7013710cdd66f1e6b4dcfc036c2b513b649526ec5cb9e35711c0dd46479bbeacb027142aa1ff84ca0fa94d2b540e28af4056fd96bbd6f1d2fa8e1c48350ab2fffc9a383330a2adf31c543a53f8ecc136adedb3fefdcf114ea8a251b7c366ade7852cd7afaaf4a1f09c50385a37658dbf4de4a47e9afdcdd8a44083b11f678ee10b208d907a4cd0d86858fa0a701edf350bbd3d4536ac7a067077e5fa484a05c46ff228065c8c0b69030f655502e4f96f36066b5b51d1467b2ffe84e9c6e8e4fc115aec9e4b03cc36204f48e5e696d1b15712e7f40e5eae36ab360fb2162eb644a078d3bb7d27c280b1a9fb35313d4ef46af075f2d82830057177b8fdeef513fc659c971f027238bd0a0f72d379b660b8d4883c8108693753c28b5b15207a76c9a21640fa113873312ab9e122ad623004a0df68406f3c3a8137ddf350fa62ddd5754d7532be14a80664538bd05edccb0e061d2ff930f196440abd960b0d5294b578a0028f64f116bf297c4266150fdd66146ef2042edcb72bf00b03bed9267146585fd06b76f8a490814105205aab8c8f60b063194b7d317801d91d4ca6c2cdf788c0eb433795c26ccd8cd200ab36e1f95677229ac9cda3034c0e0435d1a671f68cf2f6c73fbc8897a4b7c9b92a4704f7cb8935f224f28e59b7624767c69ef3c42bae59d0cffc1f618ea6426cdf5c865c199df95ad3d37a5ef7a453c3d172a3c3b2ae1b1aecb9369e6e1f36090a4a76db5f06200944c6d7f08fe89267a29e815d1b9364015a7627d32cbc42351ba90346d4e9d55c83c141ec147df594686216d8b836777b025e898743a3a7dbb764f95fd971e8802d809356638050c0d4f92b55207946483f3c64ab822525a8ee7589af125e5662b76d48f8b6b1ecdf7953fd3e32c884065b2d7186a7f1159b95a129fbbfe6ed40f3b5b461263f7c3416d3c0200c43ce8a429e9fb0a61ffe403a115da54d41fee5bd4429025e0167aab7c0ac7a178a17bc7cef6c62160bbc1fcc36e018cffc8b9655f363ed2438cd0d1c320ba1e4a7e5f7439250120d3d32dc6acea526e9496e28895bb3b206ab84dfbfd35a5ca7588d10b57f0201eaaa2024bb6ed15c6f84c459de8a011f635b4b394bfb1904d1b23fb8f2cbc563374e8ec37ba1b66ca344514a5362dce89c8c83faf7aff350d276d79b302dde9b56e0ab798289de7c17a8d0c1574fe309c8e6c48f887f5e869b11976c575c5f2fef820eaba4a05d65d8e5fcf8ca3d981c6a3551098a32f55bdc3f422d702427df818b05c72382a07c07e21625db89069a038d196607757ae9bb7591ac3cbf3d27d3e74a1d73366bed41fd0b3da29bf306228bcf8751295878d689b1c1fb2f2871dd9ef723d5602fa93950c34913095af0364f61b83845836835ed774e466883dc1ce14bf2047ec9026f77d7ebffefdee2ed28cb3f67d4c3429eacc073286a87764e037ba07ce7db5e61263c25d17be588577b110f22ee1f58b48406326ee3b9a3342cbd795db4d1af3df2051899f0a533d4063786279e9c02b446445eed99712f52b8fb859b2672fc0d287d4cb995e99b368f1880a7b370d5d7e7d55d7fead36375d968371ada0cfd00aacc86d98519e5a2eaaa3e472770ca6d497d9abcd719ec19583217e9b1e60fb9063677becba3cd7a644c30680af531b0a5da5fc26b7954185b55f86741ea4587ddea0672f3b9a8d9f17156088f4e69077e4c32c250d141457a2af2c4c8c5a81eed673862af64e71a459c6b6324b175af83ab00cfea99e9f0175ec2654781eb3f83b4e2a8db66fbc095307ce74f8fffd4c9dc5c23dc67aea7e64d62939f970f3e89da554debf2fc6a5b36a8589b6e7969a80d9ff4b0805515baa4d048f98005a258f00089d4bdd15f410d3ba6881b36a590293bf13a34f6357af0268d33e00a9eb48dcc295d04c406e6fd8ae232162ce184f66787eee0445a58c0343545aa4e50b235ad994855167367301bc4a884f078f4a5b1a63885a0c8ea3ff3ec73eadc009863b4b991121294731a2de809452b4d60f53a1e4cf86d8027b3587dcb5918a6c23f533ddbeec41d3940a5dd52a24fc8d2ad1896d3ecd3ebaba5832df371f3a0bad30e521fcb8f85650eda7b35459442e60ca1314c19afb329d454620672408fdad3e7d7127c3162dbad99469dff38e2fca233b5e42c917bac9fc78cb364c59df13f50c7b7555e2cb60f20f47bf3c115f9e912ecd035d28b8a2929c15bac6d92c227aece28f3d224d2a7e719641b3a817870258a5951b222aada25e1684d58e1ea2edfc82d5124ef3eeb297178dbc7a7155a8e97b2cb30eafb41c3d90862019879872581da1efdef5ad5d4a1470279374c7badbc179840b8e0847890ab2b0c36f35e0b13376179d23921a7ff07824a8869ac380a0544075ae4aaa2f0bc1bf311a4f5b8f9f9985ce588750e55fe27e1be34a4f17169cbff505dd16e30a4ac885baf4469857b6d42dde77eeb0a2310c56a2fae115e877ad8f6ea48a6a03afd3ebd19122d36972f397b64e44fdb123e7c54f592 请输入密码查看详细内容","link":"/2022/03/12/Other/question/"},{"title":"Vue组件通信的8种方式","text":"props 和 $emit $children 和 $parent ref provide 和 inject eventBus $attrs 和 $listeners Vuex localStorage 和 sessionStorage 参考","link":"/2022/03/12/Vue/vue-communication/"},{"title":"基于 vue + electron 编写一个桌面应用","text":"基于 vue-cli3.0 + Electron 编写一个桌面应用 「 说明 」 项目地址：Monit 根据 README.md 文件教程安装依赖并运行 由于对 Electron 暂不熟悉，详细代码实现后续详写，本次先对项目安装构建过程中遇到的几个注意事项记录一下。 ⚠️注意事项 安装依赖时有些依赖文件较大，需要等待下载一段时间； npm run build 过程中需要安装打包后应用的环境文件等，可能需要80M以上，若不想长时间等待可以使用科学上网或者根据地址手动下载安装包放入文件的方法解决； vue-cli-plugin-electron-builder已集成跨系统打包功能，只需修改打包命令及配置即可实现打包 mac 及 windows 应用；修改如下 vue.config.js 中修改构建选项 builderOptions 12345678910111213141516171819202122232425262728// 构建选项builderOptions: { productName: 'Monit', // 应用名 icon: 'public/logo/icon.png', // 图标 appId: 'top.fzf404.monit', // app id artifactName: '${productName}-${version}-${os}-${arch}.${ext}', // 打包命名方式 linux: { target: 'AppImage', publish: ['github'], }, mac: { target: { target: 'dmg', arch: ['x64', 'arm64'], }, }, win:{ //win相关配置 &quot;target&quot;: [ { &quot;target&quot;: &quot;nsis&quot;,//利用nsis制作安装程序 &quot;arch&quot;: [ &quot;x64&quot;,//64位 &quot;ia32&quot;//32位 ] } ] }} package.json 中修改构建命令 12345678 &quot;scripts&quot;: { &quot;serve&quot;: &quot;vue-cli-service electron:serve&quot;, &quot;build&quot;: &quot;vue-cli-service electron:build --win --ia32&quot;, &quot;package-win&quot;:&quot;electron-packager ./ --platform=win32 --out ./dist --overwrite --ignore=node_modules --arch=x64&quot;, &quot;release&quot;: &quot;vue-cli-service electron:build --publish always&quot;, &quot;prettier&quot;: &quot;prettier --write .&quot;}// 不加 --win --ia32 默认打包成当前系统应用 参考： 基于vue + electron创造一个随心开发组件的跨端桌面应用 使用vue-cli-plugin-electron-builder开发vue-cli3.0+Electron桌面开发应用","link":"/2022/06/12/Other/vue-electron/"},{"title":"了解 Vue diff算法","text":"生命周期 vuex vue-router 3种模式 虚拟dom 了解 Vue diff算法 vue3 及 与 vue2 的区别 vue 生命周期vue 的生命周期钩子核心实现是利用发布订阅模式，先把用户传入的生命周期钩子订阅好，内部使用数组方式存储，然后再创建实例过程中会一次执行对应的钩子方式(发布) beforeCreate: 是 new Vue() 之后触发的第一个钩子，当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能访问。 created: 可以使用数据，更改数据，无法与Dom 进行交互。在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，在当前阶段无法与 Dom 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 Dom。 beforeMount: 虚拟dom已生成，真实dom未挂载。发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 Dom 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。 mounted: 真实Dom已挂载，数据完成双向绑定，可以使用 $refs 对Dom 操作。在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点，使用 $refs 属性对 Dom 进行操作。 beforeUpdate: 发生在更新之前，也就是响应式数据发生更新，虚拟 dom 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。 updated: 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。 beforeDestroy: 发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。 destroyed: 发生在实例销毁之后，这个时候只剩下了 dom 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。 vue-router 有几种模式vue-router 有 3 种路由模式：hash、history、abstract： hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器; history: 依赖 HTML5 History API 和服务器配置(常用); abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式; vuex vuex的出现是为了解决组件间的通信问题,如果某个操作或者数据不涉及到公共操作,只是单一组件操作,不要把这些状态值或者function存储到vuex中,因为vuex会把自身挂载到所有组件上,不管当前组件是否用到里面的东西,因此这事实上肯定增加了性能的损耗的. vuex中，有默认的五种基本的对象： state：存储状态（变量） getters：对数据获取之前的再次编译，可以理解为state的计算属性。 mutations：修改状态，并且是同步的。这个和我们组件中的自定义事件类似。 actions：异步操作。 modules：store的子模块 项目的src文件夹如下： 1234567891011121314151617181920│ App.vue│ main.js│├─assets│ logo.png│├─components│ HelloWorld.vue│├─router│ index.js│└─store modules user.js app.js ... getters.js index.js index.js 文件内容如下： 1234567891011121314151617181920212223import Vue from 'vue'import Vuex from 'vuex'import getters from './getters'Vue.use(Vuex)const modulesFiles = require.context('./modules', true, /\\.js$/)// you do not need `import app from './modules/app'`// it will auto require all vuex module from modules fileconst modules = modulesFiles.keys().reduce((modules, modulePath) =&gt; { // set './app.js' =&gt; 'app' const moduleName = modulePath.replace(/^\\.\\/(.*)\\.\\w+$/, '$1') const value = modulesFiles(modulePath) modules[moduleName] = value.default return modules}, {})const store = new Vuex.Store({ modules, getters})export default store getters.js 文件内容如下： 12345678const getters = { userName: state =&gt; state.user.userName, userId: state =&gt; state.user.userId, sessionId: state =&gt; state.app.sessionId, ...}export default getters 存储数据 123# 调用存储# app 为 modules 文件名，setSessionId 为 actions 中方法名this.$store.dispatch('app/setSessionId', data.sessionId) 1234567891011121314151617181920212223# app.jsconst state = { sessionId: null,}const mutations = { SET_SESSIONID: (state, sessionId) =&gt; { state.sessionId = sessionId },}const actions = { setSessionId({ commit }, sessionId) { commit('SET_SESSIONID', sessionId) },}export default { namespaced: true, state, mutations, actions} 调用数据123computed: { ...mapGetters(['userId', 'sessionId']),} 虚拟DOM什么是虚拟DOM虚拟DOM简而言之就是，用JS去按照DOM结构来实现的树形结构对象，你也可以叫做DOM对象Virtual DOM是对真实DOM的抽象,本质上是树形结构JavaScript对象,这个对象就是更加轻量级的对DOM的描述. 虚拟DOM的优点 通过diff算法来对比dom新老节点，更新虚拟DOM，减少对真实DOM的操作开销，提高性能。 跨平台 抽象了原本的渲染过程实现了跨平台，不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI。以及使用Node.js（没有DOM）实现SSR(服务端渲染)。虚拟DOM对象1234567891011121314151617181920212223# 真实DOM&lt;div id=&quot;app&quot;&gt; &lt;p class=&quot;text&quot;&gt;hello world!!!&lt;/p&gt;&lt;/div&gt;# 虚拟DOM{ tag: 'div', props: { id: 'app' }, chidren: [ { tag: 'p', props: { className: 'text' }, chidren: [ 'hello world!!!' ] } ]} 如何转换为虚拟DOM React.createElement，以及 Vue 中的 render 方法中的 createElement，另外 React 是通过 babel 将 jsx 转换为 h 函数渲染的形式，而 Vue 是使用 vue-loader 将模版转为 h 函数渲染的形式（也可以通过 babel-plugin-transform-vue-jsx 插件在 vue 中使用 jsx，本质还是转换为 h 函数渲染形式）。 123456789101112131415161718192021222324已react为例，使用 babel 将一段 jsx 代码，转换为一段 js 代码：function getVDOM() { return ( &lt;div id=&quot;app&quot;&gt; &lt;p className=&quot;text&quot;&gt;hello world!!!&lt;/p&gt; &lt;/div&gt; )}function getVDOM() { return h('div', { id: 'app' },h('p', { lassName: 'text' },'hello world!!!'))}可以看到，最终 HTML 代码会被转译成 h 函数的渲染形式。h 函数接受是三个参数，分别代表是 DOM 元素的标签名、属性、子节点，最终返回一个虚拟 DOM 的对象。function h(tag, props, ...children) { return { tag, props: props || {}, children: children.flat() }} 渲染虚拟DOM浏览器环境下如何渲染虚拟 DOM。 123456789101112131415161718192021222324252627282930313233343536function render(vdom) { // 如果是字符串或者数字，创建一个文本节点 if (typeof vdom === 'string' || typeof vdom === 'number') { return document.createTextNode(vdom) } const { tag, props, children } = vdom // 创建真实DOM const element = document.createElement(tag) // 设置属性 setProps(element, props) // 遍历子节点，并获取创建真实DOM，插入到当前节点 children .map(render) .forEach(element.appendChild.bind(element)) // 虚拟 DOM 中缓存真实 DOM 节点 vdom.dom = element // 返回 DOM 节点 return element}function setProps (element, props) { Object.entries(props).forEach(([key, value]) =&gt; { setProp(element, key, value) })}function setProp (element, key, vlaue) { element.setAttribute( // className使用class代替 key === 'className' ? 'class' : key, vlaue )} 将虚拟 DOM 渲染成真实 DOM 后，只需要插入到对应的根节点即可。 1234const vdom = &lt;div&gt;hello world!!!&lt;/div&gt; // h('div', {}, 'hello world!!!')const app = document.getElementById('app')const ele = render(vdom)app.appendChild(ele) 当然在现代化的框架中，一般会有一个组件文件专门用来构造虚拟 DOM，我们模仿 React 使用 class 的方式编写组件，然后渲染到页面中。 1234567891011121314151617181920212223242526class Component { vdom = null // 组件的虚拟DOM表示 $el = null // 虚拟DOM生成的真实节点 state = { text: 'Initialize the Component' } render() { const { text } = this.state return ( &lt;div&gt;{ text }&lt;/div&gt; ) }}function createElement (app, component) { const vdom = component.render() component.vdom = vdom component.$el = render(vdom) // 将虚拟 DOM 转换为真实 DOM app.appendChild(component.$el)}const app = document.getElementById('app')const component = new ComponentcreateElement(app, component) diff算法diff 算法，顾名思义，就是比对新老 VDOM 的变化，然后将变化的部分更新到视图上。对应到代码上，就是一个 diff 函数，返回一个 patches （补丁）。 参考 虚拟DOM原理的理解 虚拟DOM和DOM-diff 虚拟DOM到底是什么","link":"/2022/03/12/Vue/vue-diff/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"}],"categories":[{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"浏览器","slug":"Browser","link":"/categories/Browser/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"网络","slug":"NetWork","link":"/categories/NetWork/"},{"name":"其他","slug":"Other","link":"/categories/Other/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}]}